{
    "Papers": [
        {
            "ID": "1",
            "Title": "Research on Charity System Based on Blockchain",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "No clear pattern presented (QQ1)",
            "Nb of found patterns": "0",
            "DOI": "10.1088/1757-899X/768/7/072020",
            "author": "Hu, Baokun and Li, He",
            "journal": "IOP Conference Series: Materials Science and Engineering",
            "year": "2020",
            "source": "Scopus",
            "volume": "768",
            "document_type": "article",
            "issn": "1757899X"
        },
        {
            "ID": "2",
            "Title": "Silver Bullet for All Trust Issues? Blockchain-Based Trust Patterns for Collaborative Business Processes",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "6",
            "DOI": "10.1007/978-3-030-58779-6_1",
            "author": "Müller, Marcel and Ostern, Nadine and Rosemann, Michael",
            "journal": "Lecture Notes in Business Information Processing",
            "year": "2020",
            "source": "Scopus",
            "pages": "3--18",
            "volume": "393 LNBIP",
            "document_type": "article",
            "keywords": "Blockchain,Business process management,Trust",
            "issn": "18651356"
        },
        {
            "ID": "3",
            "Title": "Modeling of Smart Contracts in Blockchain Solution for Renewable Energy Grid",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "No clear pattern presented (QQ1)",
            "Nb of found patterns": "0",
            "DOI": "10.1007/978-3-030-45093-9_61",
            "author": "G{ó}rski, Tomasz and Bednarski, Jakub",
            "journal": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)",
            "year": "2020",
            "source": "Scopus",
            "pages": "507--514",
            "volume": "12013 LNCS",
            "document_type": "article",
            "keywords": "Architectural views model 1+5,Blockchain,Distributed ledger,Smart contract,Software architecture",
            "issn": "16113349"
        },
        {
            "ID": "4",
            "Title": "Building Executable Secure Design Models for Smart Contracts with Formal Methods",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "Out-of-scope pattern (EQ2)",
            "Nb of found patterns": "0",
            "DOI": "10.1007/978-3-030-43725-1_12",
            "author": "Xu, Weifeng and Fink, Glenn A.",
            "journal": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)",
            "year": "2020",
            "source": "Scopus",
            "pages": "154--169",
            "volume": "11599 LNCS",
            "document_type": "article",
            "issn": "16113349"
        },
        {
            "ID": "5",
            "Title": "Opportunities, challenges, and future extensions for smart-contract design patterns",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "12",
            "DOI": "10.1007/978-3-030-04849-5_24",
            "author": "Worley, Carl R. and Skjellum, Anthony",
            "journal": "Lecture Notes in Business Information Processing",
            "year": "2019",
            "source": "Scopus",
            "pages": "264--276",
            "volume": "339",
            "document_type": "article",
            "keywords": "Blockchain,Design pattern,Ethereum,Pattern language,Smart contract",
            "issn": "18651348"
        },
        {
            "ID": "6",
            "Title": "Inter-family communication in hyperledger sawtooth and its application to a crypto-asset framework",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "1",
            "DOI": "10.1007/978-3-030-05366-6_32",
            "author": "Owens, Luke and Razet, Benoit and Smith, W. Bryan and Tanner, Theodore C.",
            "journal": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)",
            "year": "2019",
            "source": "Scopus",
            "pages": "389--401",
            "volume": "11319 LNCS",
            "document_type": "article",
            "issn": "16113349"
        },
        {
            "ID": "7",
            "Title": "Designing Secure Ethereum Smart Contracts: A Finite State Machine Based Approach",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "4",
            "DOI": "10.1007/978-3-662-58387-6_28",
            "author": "Mavridou, Anastasia and Laszka, Aron",
            "journal": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)",
            "year": "2018",
            "source": "Scopus",
            "pages": "523--540",
            "volume": "10957 LNCS",
            "document_type": "article",
            "keywords": "Automatic code generation,Design patterns,Ethereum,Finite state machine,Security,Smart contract,Solidity",
            "issn": "16113349"
        },
        {
            "ID": "8",
            "Title": "Blockchain Application Development Techniques",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "Paper not in English or French (EQ1)",
            "Nb of found patterns": "0",
            "DOI": "10.13328/j.cnki.jos.005232",
            "author": "Tsai, Wei Tek and Yu, Lian and Wang, Rong and Liu, Na and Deng, En Yan",
            "journal": "Ruan Jian Xue Bao/Journal of Software",
            "year": "2017",
            "source": "Scopus",
            "pages": "1474--1487",
            "volume": "28",
            "document_type": "article",
            "keywords": "ABC/TBC,Blockchain,Blockchain application requirements,Chaincode",
            "issn": "10009825"
        },
        {
            "ID": "9",
            "Title": "An Empirical analysis of smart contracts: Platforms, applications, and design patterns",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "9",
            "DOI": "10.1007/978-3-319-70278-0_31",
            "author": "Bartoletti, Massimo and Pompianu, Livio",
            "journal": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)",
            "year": "2017",
            "source": "Scopus",
            "pages": "494--509",
            "volume": "10323 LNCS",
            "document_type": "article",
            "issn": "16113349"
        },
        {
            "ID": "10",
            "Title": "CHASM: A Blockchain Design Pattern",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "Out-of-scope pattern (EQ2)",
            "Nb of found patterns": "0",
            "author": "Sengupta, Arijit and Subramanian, Hemang",
            "year": "2020",
            "source": "Scopus",
            "document_type": "article"
        },
        {
            "ID": "11",
            "Title": "Emerging Design Patterns for Blockchain Applications",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "19",
            "author": "Rajasekar, Vijay and Sondhi, Shiv and Saad, Sherif and Mohammed, Shady",
            "year": "2020",
            "source": "Scopus",
            "document_type": "article"
        },
        {
            "ID": "12",
            "Title": "Co-creation with Customers to Accelerate Digital Innovation",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "No clear pattern presented (QQ1)",
            "Nb of found patterns": "0",
            "author": "Hara, Hideki and Echigo, Shinya and Ota, Tomonori and Komatsu, Ryota and Matsumoto, Satoshi",
            "journal": "FUJITSU SCIENTIFIC \\& TECHNICAL JOURNAL",
            "year": "2018",
            "source": "Scopus",
            "pages": "47--54",
            "volume": "54",
            "document_type": "article"
        },
        {
            "ID": "13",
            "Title": "A Pattern Collection for Blockchain-Based Applications",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "15",
            "DOI": "10.1145/3282308.3282312",
            "author": "Xu, Xiwei and Pautasso, Cesare and Zhu, Liming and Lu, Qinghua and Weber, Ingo",
            "year": "2018",
            "source": "ACM Digital Library",
            "document_type": "inproceedings",
            "url": "https://doi.org/10.1145/3282308.3282312",
            "keywords": "Patterns, Blockchain, Smart contract",
            "publisher": "Association for Computing Machinery"
        },
        {
            "ID": "14",
            "Title": "Design Patterns for Blockchain-Based Self-Sovereign Identity",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "12",
            "DOI": "10.1145/3424771.3424802",
            "author": "Liu, Yue and Lu, Qinghua and Paik, Hye-Young and Xu, Xiwei",
            "year": "2020",
            "source": "ACM Digital Library",
            "document_type": "inproceedings",
            "url": "https://doi.org/10.1145/3424771.3424802",
            "keywords": "Blockchain, Identity Management, Pattern, Architecture, Self-sovereign Identity",
            "publisher": "Association for Computing Machinery"
        },
        {
            "ID": "15",
            "Title": "Patterns for Blockchain Data Migration",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "11",
            "DOI": "10.1145/3424771.3424796",
            "author": "Bandara, HMN Dilum and Xu, Xiwei and Weber, Ingo",
            "year": "2020",
            "source": "ACM Digital Library",
            "document_type": "inproceedings",
            "url": "https://doi.org/10.1145/3424771.3424796",
            "keywords": "smart contract, transactions, blockchain, patterns, data migration",
            "publisher": "Association for Computing Machinery"
        },
        {
            "ID": "16",
            "Title": "Towards Swarm Intelligence Architectural Patterns: An IoT-Big Data-AI-Blockchain Convergence Perspective",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "Out-of-scope pattern (EQ2)",
            "Nb of found patterns": "0",
            "DOI": "10.1145/3372938.3372962",
            "author": "Hibti, Meryem and Baïna, Karim and Benatallah, Boualem",
            "year": "2019",
            "source": "ACM Digital Library",
            "document_type": "inproceedings",
            "url": "https://doi.org/10.1145/3372938.3372962",
            "keywords": "AI, patterns, Big Data analytics, IoT, swarm intelligence, decision making",
            "publisher": "Association for Computing Machinery"
        },
        {
            "ID": "17",
            "Title": "BlockBD: A Security Pattern to Incorporate Blockchain in Big Data Ecosystems",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "1",
            "DOI": "10.1145/3361149.3361166",
            "author": "Moreno, Julio and Fernandez, Eduardo B. and Fernandez-Medina, Eduardo and Serrano, Manuel A.",
            "year": "2019",
            "source": "ACM Digital Library",
            "document_type": "inproceedings",
            "url": "https://doi.org/10.1145/3361149.3361166",
            "keywords": "security pattern, big data, blockchain",
            "publisher": "Association for Computing Machinery"
        },
        {
            "ID": "18",
            "Title": "Securing Physical Assets on the Blockchain: Linking a Novel Object Identification Concept with Distributed Ledgers",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "Out-of-scope pattern (EQ2)",
            "Nb of found patterns": "0",
            "DOI": "10.1145/3211933.3211944",
            "author": "Hepp, Thomas and Wortner, Patrick and Schönhals, Alexander and Gipp, Bela",
            "year": "2018",
            "source": "ACM Digital Library",
            "pages": "60–65",
            "document_type": "inproceedings",
            "url": "https://doi.org/10.1145/3211933.3211944",
            "keywords": "Blockchain, Manufacturing Supply Chain, Traceability System",
            "publisher": "Association for Computing Machinery"
        },
        {
            "ID": "19",
            "Title": "Secure and Privacy-Preserving Data Computing Scheme Based on Blockchain for Double-Loop Governance of Smart Society",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "No patterns",
            "Nb of found patterns": "0",
            "DOI": "10.1145/3446983.3446995",
            "author": "Hou, Yujiao and Luo, Mengxiao and Liu, Yutong and Wang, Ning and Zhang, Jinjin and Xu, Weisheng",
            "year": "2020",
            "source": "ACM Digital Library",
            "pages": "75–80",
            "document_type": "inproceedings",
            "url": "https://doi.org/10.1145/3446983.3446995",
            "keywords": "Data privacy protection, Smart society, Blockchain, Secure multi-party computation",
            "publisher": "Association for Computing Machinery"
        },
        {
            "ID": "20",
            "Title": "Design Patterns for Gas Optimization in Ethereum",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "24",
            "DOI": "10.1109/IWBOSE50093.2020.9050163",
            "author": "Marchesi, Lodovica and Marchesi, Michele and Destefanis, Giuseppe and Barabino, Giulio and Tigano, Danilo",
            "journal": "IWBOSE 2020 Proceedings of the 2020 IEEE 3rd International Workshop on Blockchain Oriented Software Engineering",
            "year": "2020",
            "source": "IEEE Xplore",
            "pages": "9--15",
            "document_type": "article",
            "keywords": "Blockchain,Ethereum,design patterns,gas optimization,gas saving,smart contracts",
            "publisher": "IEEE"
        },
        {
            "ID": "21",
            "Title": "Design Patterns for Smart Contract in Ethereum",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "No patterns",
            "Nb of found patterns": "0",
            "DOI": "10.1109/ICSA-C52384.2021.00032",
            "author": "Destefanis, Giuseppe",
            "journal": "Proceedings 2021 IEEE 18th International Conference on Software Architecture Companion, ICSA-C 2021",
            "year": "2021",
            "source": "IEEE Xplore",
            "pages": "121--122",
            "document_type": "article"
        },
        {
            "ID": "22",
            "Title": "Design Pattern as a Service for Blockchain-Based Self-Sovereign Identity",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "No clear pattern presented (QQ1)",
            "Nb of found patterns": "0",
            "DOI": "10.1109/MS.2020.2992783",
            "author": "Liu, Yue and Lu, Qinghua and Paik, Hye Young and Xu, Xiwei and Chen, Shiping and Zhu, Liming",
            "journal": "IEEE Software",
            "year": "2020",
            "source": "IEEE Xplore",
            "pages": "30--36",
            "volume": "37",
            "document_type": "article",
            "url": "http://arxiv.org/abs/2005.01346",
            "keywords": "Blockchain,Design Pattern,Identity,Self-Sovereign Identity",
            "issn": "19374194"
        },
        {
            "ID": "23",
            "Title": "A blockchain-based pattern for confidential and pseudo-anonymous contract enforcement",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "1",
            "DOI": "10.1109/TrustCom50675.2020.00268",
            "author": "Six, Nicolas and Ribalta, Claudia Negri and Herbaut, Nicolas and Salinesi, Camille",
            "journal": "Proceedings 2020 IEEE 19th International Conference on Trust, Security and Privacy in Computing and Communications, TrustCom 2020",
            "year": "2020",
            "source": "IEEE Xplore",
            "pages": "1965--1970",
            "document_type": "article",
            "keywords": "Blockchain,Business processes,Smart Contracts,Software Architecture"
        },
        {
            "ID": "24",
            "Title": "Engineering Software Architectures of Blockchain-Oriented Applications",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "3",
            "DOI": "10.1109/ICSA-C.2018.00019",
            "author": "Wessling, Florian and Gruhn, Volker",
            "journal": "Proceedings 2018 IEEE 15th International Conference on Software Architecture Companion, ICSA-C 2018",
            "year": "2018",
            "source": "IEEE Xplore",
            "pages": "45--46",
            "document_type": "article"
        },
        {
            "ID": "25",
            "Title": "A typology of blockchain recordkeeping solutions and some reflections on their implications for the future of archival preservation",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "3",
            "DOI": "10.1109/BigData.2017.8258180",
            "author": "Lemieux, Victoria L.",
            "journal": "Proceedings 2017 IEEE International Conference on Big Data, Big Data 2017",
            "year": "2017",
            "source": "IEEE Xplore",
            "pages": "2271--2278",
            "volume": "2018-January",
            "document_type": "article",
            "keywords": "blockchain,digital preservation,distributed ledger,recordkeeping"
        },
        {
            "ID": "26",
            "Title": "Design patterns and framework for blockchain integration in supply chains",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "No clear pattern presented (QQ1)",
            "Nb of found patterns": "0",
            "DOI": "10.1109/ICBC51069.2021.9461062",
            "author": "Lamken, Dennis and Wagner, Tobias and Hoiss, Tim and Seidenfad., Karl and Hermann, Andreas and Kus, Mehmet and Lechner, Ulrike",
            "journal": "2021 IEEE International Conference on Blockchain and Cryptocurrency (ICBC)",
            "year": "2021",
            "source": "IEEE Xplore",
            "pages": "1--3",
            "document_type": "article",
            "url": "https://ieeexplore.ieee.org/document/9461062/",
            "publisher": "IEEE"
        },
        {
            "ID": "27",
            "Title": "Design Patterns for Smart Contracts in the Ethereum Ecosystem",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "12",
            "DOI": "10.1109/Cybermatics_2018.2018.00255",
            "author": "Wohrer, Maximilian and Zdun, Uwe",
            "year": "2018",
            "source": "IEEE Xplore",
            "pages": "1513--1520",
            "document_type": "inproceedings",
            "keywords": "Smart contracts;Blockchain;Security;Encoding;Ecosystems;Programming"
        },
        {
            "ID": "28",
            "Title": "Design pattern as a service for blockchain applications",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "6",
            "DOI": "10.1109/ICDMW.2018.00025",
            "author": "Lu, Qinghua and Xu, Xiwei and Liu, Yue and Zhang, Weishan",
            "year": "2019",
            "source": "IEEE Xplore",
            "pages": "128--135",
            "volume": "2018-November",
            "document_type": "inproceedings",
            "keywords": "architecture,blockchain,blockchain as a service,design pattern,smart contract",
            "issn": "23759259"
        },
        {
            "ID": "29",
            "Title": "Tracking GDPR Compliance in Cloud-based Service Delivery",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "No clear pattern presented (QQ1)",
            "Nb of found patterns": "0",
            "DOI": "10.1109/tsc.2020.2999559",
            "author": "Barati, Masoud and Rana, Omer",
            "journal": "IEEE Transactions on Services Computing",
            "year": "2020",
            "source": "IEEE Xplore",
            "pages": "1--1",
            "document_type": "article",
            "keywords": "Blockchain;Smart contracts;General Data Protection Regulation;Law;Cloud computing;user privacy;cloud security;blockchain;smart contracts;general data protection regulation",
            "issn": "1939-1374"
        },
        {
            "ID": "30",
            "Title": "Architectural Design Decisions for Blockchain-Based Applications",
            "Selected in phase": "1",
            "Rejected after reading": "Yes",
            "Reason (if yes)": "No patterns",
            "DOI": "10.1109/ICBC51069.2021.9461109",
            "author": "W{ö}hrer, Maximilian and Zdun, Uwe",
            "year": "2021",
            "source": "IEEE Xplore",
            "pages": "1--5",
            "document_type": "inproceedings",
            "url": "http://eprints.cs.univie.ac.at/6815/",
            "keywords": "Privacy;Software architecture;Scalability;Decision making;Blockchain;Computer architecture;Usability;blockchain;software architecture;decentralized application;DApp;smart contract;design pattern"
        },
        {
            "ID": "31",
            "Title": "How to Disclose Selective Information from Permissioned DLT-Based Traceability Systems?",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "3",
            "DOI": "10.1109/DAPPS49028.2020.00020",
            "author": "Schinle, Markus and Erler, Christina and Vetter, Adrian Rudolf and Stork, Wilhelm",
            "year": "2020",
            "source": "IEEE Xplore",
            "pages": "153--158",
            "document_type": "inproceedings",
            "keywords": "Blockchain,Competitor Analysis,Distributed Ledger Technology,Sensitive Data,Supply Chain,Traceability"
        },
        {
            "ID": "32",
            "Title": "From Domain-Specific Language to Code: Smart Contracts and the Application of Design Patterns",
            "Selected in phase": "1",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "18",
            "DOI": "10.1109/MS.2020.2993470",
            "author": "Wohrer, Maximilian and Zdun, Uwe",
            "journal": "IEEE Software",
            "year": "2020",
            "source": "IEEE Xplore",
            "pages": "37--42",
            "volume": "37",
            "document_type": "article",
            "issn": "19374194"
        },
        {
            "ID": "33",
            "Title": "Security checklists for ethereum smart contract development: patterns and best practices",
            "Selected in phase": "2",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "22",
            "DOI": "https://arxiv.org/abs/2008.04761",
            "author": "Marchesi, Lodovica and Marchesi, Michele, and Pompianu, Livio and Tonelli, Roberto",
            "journal": "arXiv.org",
            "year": "2020",
            "document_type": "preprint"
        },
        {
            "ID": "34",
            "Title": "Applying software patterns to address interoperability in blockchain-based healthcare apps",
            "Selected in phase": "2",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "4",
            "DOI": "https://arxiv.org/abs/1706.03700",
            "author": "Zhang, Peng and White, Jules and Schmidt, Douglas C. and Lenz, Gunther",
            "journal": "arXiv.org",
            "year": "2017",
            "document_type": "preprint"
        },
        {
            "ID": "35",
            "Title": "Smart contracts: security patterns in the ethereum ecosystem and solidity",
            "Selected in phase": "2",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "6",
            "DOI": "10.1109/IWBOSE.2018.8327565",
            "author": "Wohrer, Maximilian and Zdun, Uwe",
            "journal": "2018 International Workshop on Blockchain Oriented Software Engineering (IWBOSE)",
            "year": "2018",
            "document_type": "inproceedings",
            "url": "https://ieeexplore.ieee.org/document/8327565/"
        },
        {
            "ID": "36",
            "Title": "On or off the blockchain? Insights on off-chaining computation and data",
            "Selected in phase": "2",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "5",
            "DOI": "10.1007/978-3-319-67262-5_1",
            "author": "Eberhardt, Jacob and Tai, Stefan",
            "journal": "Service-Oriented and Cloud Computing",
            "year": "2017",
            "document_type": "inproceedings",
            "url": "https://link.springer.com/chapter/10.1007/978-3-319-67262-5_1"
        },
        {
            "ID": "37",
            "Title": "Applying design patterns in smart contracts",
            "Selected in phase": "2",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "8",
            "DOI": "10.1007/978-3-319-94478-4_7",
            "author": "Liu, Yue and Lu, Qinghua and Xu, Xiwei and Zhu, Liming and Yao, Haonan",
            "journal": "Blockchain -- ICBC 2018",
            "year": "2018",
            "document_type": "inproceedings",
            "url": "https://link.springer.com/chapter/10.1007/978-3-319-94478-4_7"
        },
        {
            "ID": "38",
            "Title": "Blockchain Technology Use Cases in Healthcare",
            "Selected in phase": "2",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "4",
            "author": "Raj, Pethuru and Deka, Ganesh Chandra",
            "journal": "Blockchain Technology: Platforms, Tools and Use Cases",
            "year": "2018",
            "document_type": "incollection",
            "url": "https://www.sciencedirect.com/science/article/pii/S0065245818300196"
        },
        {
            "ID": "39",
            "Title": "Foundational Oracle Patterns: Connecting Blockchain to the Off-Chain World",
            "Selected in phase": "2",
            "Rejected after reading": "No",
            "Reason (if yes)": "N/A",
            "Nb of found patterns": "4",
            "DOI": "10.1007/978-3-030-58779-6_3",
            "author": "Mühlberger, Roman and Bachhofner, Stefan and Ferrer, Eduardo Castelló and Ciccio, Claudio Di and Weber, Ingo and Wöhrer, Maximilian and Zdun, Uwe",
            "journal": "Business Process Management: Blockchain and Robotic Process Automation Forum",
            "year": "2020",
            "document_type": "inproceedings",
            "url": "https://link.springer.com/chapter/10.1007/978-3-030-58779-6_3"
        }
    ],
    "Paper patterns": [
        {
            "ID": "1",
            "Name": "Hash Storage",
            "Paper": "2",
            "Context & Problem": "In collaborative processes where different organizations use shared data, the integrity of this common piece of data is a crucial trust concern. When data can be altered and manipulated, this might lead to anomalies and malicious behavior. For collaborators, it is hard to verify the integrity of the data and trace its provenance. Data integrity is an uncertainty where collaborators have to rely on the organization providing data.",
            "Solution": "In the tamper-proof hashed data storage pattern, the collaborator who acts as the data origin hashes the file. The hash is submitted through a transaction to the blockchain. A message with the hash is sent to data consumers. At any point in time, data consumers can verify the file’s integrity by comparing the hash of the received file with the hash on the blockchain. If the hashes do not match up, data has been changed.",
            "Application examples": "• Xueping Liang, Sachin Shetty, Deepak Tosh, Charles Kamhoua, Kevin Kwiat, and Laurent Njilla. Provchain: A blockchain-based data provenance architecture in cloud environment with enhanced privacy and availability. In 2017 17th IEEE/ACM International Symposium on Cluster, Cloud and Grid Computing (CCGRID), pages 468–477. IEEE, 2017.• Bin Liu, Xiao Liang Yu, Shiping Chen, Xiwei Xu, and Liming Zhu. Blockchain based data integrity service framework for iot data. In 2017 IEEE International Conference on Web Services (ICWS), pages 468–475. IEEE, 2017.",
            "Benefits": "Integrity",
            "Drawbacks/Liabilities": "Data processing outside the scope",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "BPM"
        },
        {
            "ID": "2",
            "Name": "Transparent Event Log",
            "Paper": "2",
            "Context & Problem": "Non-repudiation of event occurrences is a trust concern in collaborative business processes. During the inter-organizational collaboration, incidents like failures during an activity execution might imply following different workflows. One instance of this is the error event. Therefore, it is essential that organizations cannot deny the occurrence of an event afterward to avoid compensation claims from other stakeholders. In terms of trust-aware business processes, the organization causes a trust concern regarding the non-repudiation of event occurrences.",
            "Solution": "Using the blockchain as a decentralized event log means to save the occurrence of events and data related to them immutably on a shared distributed ledger, as described in [21]. Technically, this can be implemented similar to the blockchain hashed data storage trust pattern. ",
            "Application examples": "• Pradipta K Banerjee, Pooja Kulkarni, and Harshal S Patil. Distributed logging of application events in a blockchain, June 11 2019. US Patent 10,320,566.",
            "Benefits": "Non-repudiation",
            "Drawbacks/Liabilities": "Non-submission of events",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Storage pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "BPM"
        },
        {
            "ID": "3",
            "Name": "Blockchain BP Engine",
            "Paper": "2",
            "Context & Problem": "For the successful execution of an instance of a business process, it is inevitable to ensure the correct control flow between subprocesses and activities of different organizations and within the same organization. To ensure the execution of a business process according to its defining model, business process engines [22] are commonly utilized. Traditionally, such engines are centrally managed. This implies that all other collaborators have to trust that the business process engine managed by one collaborator acts as intended. From a trust-aware BPM view, this means that there is uncertainty regarding the correctness (integrity) of the process flow present.",
            "Solution": "Blockchain-based business processes engines, as proposed by Lopez-Pintado et al. [23], store business process models in smart contracts on a blockchain. All collaborators have access to the smart contract and can, at any point, verify the model’s correctness.",
            "Benefits": "Integrity",
            "Drawbacks/Liabilities": "Lack of time-based features",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "BPM pattern",
            "Requires": "Oracle",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "BPM"
        },
        {
            "ID": "4",
            "Name": "Smart Contract Activities",
            "Paper": "2",
            "Context & Problem": "In an inter-organizational process, different collaborators are responsible for certain activities. The execution of activities carried out by one organization can be seen as a “black box” for other organizations. Without any modifications, collaborators cannot verify the correct execution of the activities of other collaborators. Further, it is also not traceable to them if even the resources to execute the activity at a certain point in time are available.",
            "Solution": "In this trust pattern, the business logic of an activity is encoded in a smart contract and deployed on the blockchain. The execution of the smart contract is either triggered by the responsible collaborator or by another smart contract, such as a decentralized business process engine.",
            "Benefits": "Integrity, Availability",
            "Drawbacks/Liabilities": "Lack of privacy",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "BPM pattern",
            "Requires": "Oracle",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "BPM"
        },
        {
            "ID": "5",
            "Name": "Blockchain-based reputation system",
            "Paper": "2",
            "Context & Problem": "Reputation systems are a well-established method that has been used from the early ages of e-commerce to symbolize the trustworthiness of online business partners. Hence, they are an approach to build confidence in a process. From a technical perspective, reputation systems store the reputation claim that a source makes regarding a specific reputation target [26]. This requires the user to trust the centralized authority not to manipulate the saved reputation data. ",
            "Solution": "The blockchain technology can be leveraged to implement fully decentralized reputation systems. In such decentralized systems, there is no need to trust a centralized party for the integrity of reputation statements and their aggregation since all blockchain participants have access to the data",
            "Benefits": "Integrity",
            "Drawbacks/Liabilities": "Potential attacks",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "BPM"
        },
        {
            "ID": "6",
            "Name": "Decentralize business process",
            "Paper": "2",
            "Context & Problem": "In collaborative business processes, activities executed by one organization are usually outside of the domain of influence of other organizations. If one organization is in charge of particularly many tasks in a process, this can lead to a significant dependency on the organization. ",
            "Solution": "Blockchain can be used as a tool to connect subprocesses in a decentralized process and as a tool for incentivization of correct behavior. As a software connector, the blockchain technology can be used as an interface for message flows between different organizations.",
            "Application examples": "• Marcel Müller, Sandro Rodriguez Garzon, Martin Westerkamp, and Zoltan Andras Lux. Hidals: A hybrid iot-based decentralized application for logistics and supply chain management. In 2019 IEEE 10th Annual Information Technology, Electron• ics and Mobile Communication Conference (IEMCON), pages 0802–0808. IEEE, 2019.",
            "Benefits": "Integrity",
            "Drawbacks/Liabilities": "Lack of incentives",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "BPM pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "BPM"
        },
        {
            "ID": "7",
            "Name": "Key-value store",
            "Paper": "5",
            "Context & Problem": "Many smart contracts store nontrivial amounts of data. A common use case is a contract that serves a registry, storing data in a manner that takes advantage of the blockchain’s censorship-resistant and DDoS-resistant nature.  How can this data be stored and retrieved effectively?",
            "Solution": "A key-value store is well-suited to blockchain data management, where the store is dynamically resizable and provides a value given a specific key.",
            "Application examples": "• Ethereum Name Service (ENS) (https://ens.domains/fr/)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Storage pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "8",
            "Name": "Address mapping",
            "Paper": "5",
            "Context & Problem": "Smart contracts often interact with various users, all of whom must be tracked independently. How can relationships between the smart contract and user accounts be managed correctly?",
            "Solution": "Establish a mapping from addresses to contract-relevant data, defined for all possible Ethereum addresses. In the case of accounts that the contract has never interacted with, the mapping is from the address to a default value of the codomain (the set being mapped to). This mapping may be changed by the contract to other values of the type.",
            "Application examples": "• Native support from Solidity language (https://docs.soliditylang.org/en/latest/types.html)• ERC20 token implementation of OpenZeppelin (https://docs.openzeppelin.com/contracts/2.x/api/token/erc20)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Storage pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "9",
            "Name": "Authorization",
            "Paper": "5",
            "Context & Problem": "A smart contract may need to transition to a new state that isn’t defined by its internal logic because of some external event or internal flaw. Since smart contracts are immutable, how can this transition be performed?",
            "Solution": "Establish a permissioning system where the contract is hard-coded to perform special actions in response to specific users. This permission may come from a single user or a vote of many, and privileges may range from setting state variables to completely destroying the contract. The exact details of the permissions and privileges must be specified at creation.",
            "Application examples": "• Ownable contract implementation of OpenZeppelin (https://docs.openzeppelin.com/contracts/2.x/api/ownership)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "10",
            "Name": "Judge",
            "Paper": "5",
            "Context & Problem": "Multiple parties are participating in a contract that is dependent on real-world data.",
            "Solution": "All parties identify a third-party actor that they all trust. This entity is given Authorization to update the contract with real-world state.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Variant of": "26",
            "Requires": "9",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "11",
            "Name": "Ticker Tape",
            "Paper": "5",
            "Context & Problem": "A contract must constantly supply up-to-date information about some real-world data.",
            "Solution": "Create a contract whose only purpose is to store regularly updated data about the external world. Use the Authorization pattern to allow a trusted source to update the state periodically/regularly. This contract is a service to other contracts that use the data.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Variant of": "26",
            "Requires": "9",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "12",
            "Name": "Vote",
            "Paper": "5",
            "Context & Problem": "A contract must supply data that cannot rely on a single source. A large number of data sources are present and must be decided between.",
            "Solution": "Allow the input sources to vote on the correct answer. And, provide disincentives for voting incorrectly, as determined by the eventual consensus.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Variant of": "26",
            "Benefits from": "5",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "13",
            "Name": "Anti-Oracle",
            "Paper": "5",
            "Context & Problem": "Information from different sources on the blockchain must be accessed off-chain.",
            "Solution": "Create an off-chain daemon that periodically examines the blockchain for specific events and collates the records of those events into a single off-chain source. Off-chain entities can then read a well-formatted digest of the relevant information.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "14",
            "Name": "Blocklist",
            "Paper": "5",
            "Context & Problem": "A contract needs to record a set of entities that will be disallowed access to some asset off-chain",
            "Solution": "Define a contract that stores a Bloom filter coefficient set. Off-chain clients may download the coefficients to calculate with the Bloom filter",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "15",
            "Name": "Announcement",
            "Paper": "5",
            "Context & Problem": "Information from different sources on the blockchain must be accessed by entities on-chain.",
            "Solution": "Create a contract that serves as a space where Authorized contracts can post announcements. These announcements can then be viewed by any other contract.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Requires": "9",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "16",
            "Name": "Bulletin Board",
            "Paper": "5",
            "Context & Problem": "A contract must supply irregular updates on real-world data, from multiple sources.",
            "Solution": "Create a Bulletin Board contract, where requests for data can be posted and answered by users. Define a decision process for acceptance of the answers, perhaps using the Vote or Judge patterns, and expose the answer data.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Benefits from": "10, 12",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "17",
            "Name": "Token",
            "Paper": "5",
            "Context & Problem": "A contract needs a flexible unit of accounting for access to a certain resource.",
            "Solution": "Define a token, or contract-based cryptocurrency. Use the Address Mapping pattern to associate each Ethereum address with a balance and provide functions for transfer of balance between users.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Tokenization patterns",
            "Requires": "8",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "18",
            "Name": "Migration",
            "Paper": "5",
            "Context & Problem": "A contract has a defined lifespan, passing through multiple stages related to its development or obsolescence.",
            "Solution": "Create a special Migration contract that serves as a pointer to the current version of the contract. When the contract is upgraded, the Migration contract is updated with a pointer to the latest version.",
            "Application examples": "• Truffle framework (https://www.trufflesuite.com/)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "19",
            "Name": "Inter-family communication",
            "Paper": "6",
            "Context & Problem": "In a smart contract environment, a desirable property is to have the capability for smart contracts to call other smart contracts. Ideally, this functionality should be as easy as having the ability to do a function call within another function in any programming language. Nevertheless, in a blockchain, the execution environment involves some form of cryptography, and it is challenging to pass along these cryptographic guarantees along smart contract calls without passing along more context. In Sawtooth, there is an additional challenge because the platform is language agnostic and transaction families can be written in different programming languages on the same blockchain deployment.",
            "Solution": "In this article, we have introduced a design pattern – called Inter-Family Communication – that provides a design solution to enable smart contracts to communicate with one another, even in the case where the smart contracts are written in different programming languages. ",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Target": "Hyperledger Sawtooth",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "20",
            "Name": "Locking",
            "Paper": "7",
            "Solution": "To prevent reentrancy vulnerabilities, we provide a security plugin (ie. design pattern) for locking the smart contract. The locking feature eliminates reentrancy vulnerabilities in a “foolproof” manner: functions within the contract cannot be nested within each other in any way.",
            "Application examples": "• FSolidM tool (from the same paper)",
            "Benefits": "Reentrancy protection",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Based on non-blockchain pattern": "Mutex",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "21",
            "Name": "Transition Counter",
            "Paper": "7",
            "Context & Problem": "The state and the values of the variables stored in an Ethereum contract may be unpredictable. When a user invokes a function (i.e. transition in an FSM), she cannot be sure that the contract does not change in some way before the function is actually executed. This issue has been referred to as “transaction-ordering dependence” [6] and “unpredictable state” [13], and it can lead to various security issues. Furthermore, it is rather difficult to prevent since multiple users may invoke functions at the same time, and these function invocations might be executed in any order.",
            "Solution": "We provide a plugin that can prevent unpredictable-state vulnerabilities by enforcing a strict ordering on function executions. The plugin expects a transition number in every function as a parameter (i.e., as a transition input variable) and ensures that the number is incremented by one for each function execution. As a result, when a user invokes a function with the next transition number in sequence, she can be sure that the function is executed before any other state changes can take place (or that the function is not executed).",
            "Application examples": "• FSolidM tool (from the same paper)",
            "Benefits": "Predictability",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "22",
            "Name": "Automatic Timed Transitions",
            "Paper": "7",
            "Solution": "We implement timed transitions as a modifier that is applied to every function. When a transition is invoked, the modifier checks whether any timed transitions must be executed before the invoked transition is executed. If so, the modifier executes the timed transitions before the invoked transition. ",
            "Application examples": "• FSolidM tool (from the same paper)",
            "Drawbacks/Liabilities": "Potential vulnerabilities",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "23",
            "Name": "Access Control",
            "Paper": "7",
            "Context & Problem": "In many contracts, access to certain transitions (i.e., functions) needs to be controlled and restricted.",
            "Solution": "For example, any user can participate in a typical blind auction by submitting a bid, but only the creator should be able to cancel the auction. To facilitate the enforcement of such constraints, we provide a plugin that 1) manages a list of administrators at runtime (identified by their addresses) and 2) enables developers to forbid non-administrators from accessing certain functions. ",
            "Application examples": "• FSolidM tool (from the same paper)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "24",
            "Name": "Token",
            "Paper": "9",
            "Solution": "This pattern is used to distribute some fungible goods (represented by tokens) to users. Tokens can represent a wide variety of goods, like e.g. coins, shares, outcomes or tickets, or everything else which is transferable and countable.",
            "Application examples": "• DVIP contract (https://etherscan.io/address/0xadc46ff5434910bd17b24ffb429e585223287d7f#code)• ETCSurvey contract (https://etherscan.io/address/0xdb6d68e1d8c3f69d32e2d83065492e502b4c67ba#code)",
            "Benefits": "Standardization",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Tokenization patterns",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "25",
            "Name": "Authorization",
            "Paper": "9",
            "Solution": "This pattern is used to restrict the execution of code according to the caller address. The majority of the analysed contracts check if the caller address is that of the contract owner, before performing critical operations (e.g., sending ether, invoking suicide or selfdestruct).",
            "Application examples": "• Doubler contract (https://etherscan.io/address/0xdc84953D7C6448e498Eb3C33ab0F815da5D13999#code)• Corporation contract (https://etherscan.io/address/0x684282178b1d61164febcf9609ca195bef9a33b5#code)• CharlyLifeLog (https://etherscan.io/address/0x5A5eFF38DA95b0D58b6C616f2699168B480953C9#code)",
            "Benefits": "Authentication and Authorization",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "26",
            "Name": "Oracle",
            "Paper": "9",
            "Context & Problem": "Some contracts may need to acquire data from outside the blockchain, e.g. from a website, to determine the winner of a bet. The Ethereum language does not allow contracts to query external sites: otherwise, the determinism of computations would be broken, as different nodes could receive different results for the same query",
            "Solution": "Oracles are the interface between contracts and the outside.Technically, they are just contracts, and as such their state can be updated by sending them transactions. In practice, instead of querying an external service, a contract queries an oracle; and when the external service needs to update its data, it sends a suitable transaction to the oracle.",
            "Application examples": "• Oraclize (http://www.oraclize.it/)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "27",
            "Name": "Randomness",
            "Paper": "9",
            "Context & Problem": "Dealing with randomness is not a trivial task in Ethereum. Since contract execution must be deterministic, all the nodes must obtain the same value when asking for a random number: this struggles with the randomness requirements wished.",
            "Solution": "To address this issue, several contracts (e.g., Slot) query oracles that generate these values off-chain.",
            "Application examples": "• Slot contract (https://etherscan.io/address/0x76bc9e61a1904b82cbf70d1fd9c0f8a120483bbb#code)• Lottery contract (https://etherscan.io/address/0x302fE87B56330BE266599FAB2A54747299B5aC5B#code)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Requires": "Oracle",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "28",
            "Name": "Poll",
            "Paper": "9",
            "Solution": "Polls allows users to vote on some question. Often this is a side feature in a more complex scenario. For instance, in the Dice game, when a certain state is reached, the owner issues a poll to decide whether an emergency withdrawal is needed. To determine who can vote and to keep track of the votes, polls can use tokens, or they can check the voters’ addresses.",
            "Application examples": "• Dice game contract (https://etherscan.io/address/0x2AB9f67A27f606272189b307052694D3a2B158bA#code)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Benefits from": "Token, Address mapping",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "29",
            "Name": "Time Constraint",
            "Paper": "9",
            "Solution": "Many contracts implement time constraints, e.g. to specify when an action is permitted. For instance, BirthdayGift allows users to collect funds, which will be redeemable only after their birthday. In notary contracts, time constraints are used to prove that a document is owned from a certain date.",
            "Application examples": "• BirthdayGift contract (https://etherscan.io/address/0x9828f591b21ee4ad4fd803fc7339588cb83a6b84#code)• Lottery contract (https://etherscan.io/address/0x302fE87B56330BE266599FAB2A54747299B5aC5B#code)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "30",
            "Name": "Termination",
            "Paper": "9",
            "Context & Problem": "Since the blockchain is immutable, a contract cannot be deleted when its use has come to an end. Hence, developers must forethink a way to disable it, so that it is still present but unresponsive.",
            "Solution": "This can be done manually, by inserting ad-hoc code in the contract, or automatically, calling selfdestruct or suicide.",
            "Application examples": "• SimpleCoinFlipGame contract (https://etherscan.io/address/0xe941e5d4a66123dc74886699544fbbb942f1887a#code)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "31",
            "Name": "Math",
            "Paper": "9",
            "Solution": "Contracts using this pattern encode the logic which guards the execution of some critical operations. For instance, Badge implements a method named subtractSafely to avoid subtracting a value from a balance when there are not enough funds in an account",
            "Application examples": "• Badge contract (https://etherscan.io/address/0x54bda709fed875224eae569bb6817d96ef7ed9ad#code)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "32",
            "Name": "Fork check",
            "Paper": "9",
            "Context & Problem": "The Ethereum blockchain has been forked four times, starting from July 20th, 2016, when a fork was performed to contrast the effect of the DAO attack [4].",
            "Solution": "To know whether or not the fork took place, some contracts inspect the final balance of the DAO. Other contracts use this check to detect whether they are running on the main chain or on the fork, performing different actions in the two cases.",
            "Application examples": "• AmIOnTheFork contract (https://etherscan.io/address/0x2bd2326c993dfaef84f696526064ff22eba5b362#code)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "33",
            "Name": "Checks-Effect-Interactions",
            "Paper": "11",
            "Context & Problem": "If the ”interactions” occur before the ”effects” are recorded and the invoked contract makes a callback to the original one, the system state can be exploited.",
            "Solution": "The contract first checks whether the necessary conditions are met, then makes necessary changes to the contract state (effects) and finally passes control to another contract (interactions)",
            "Benefits": "Avoid unexpected errors",
            "Drawbacks/Liabilities": "Counter-intuitiveness",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "187",
            "Based on non-blockchain pattern": "Chain of Responsibility",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "34",
            "Name": "Secure Ether Transfer",
            "Paper": "11",
            "Context & Problem": "Since the low-level function will forward all remaining gas to the invoked contract, using it allows further invocations to be made, provided the gas sent in the original call is sufficiently larger than the required minimum.",
            "Solution": "This is infact an anti-pattern. The low-level Solidity function, address.call() should not be used to invoke a contract. Instead, the high-level address.send() or address.transfer() should be preferred because they set a limit on the amount of gas1 the contract can forward to any invoked contract.",
            "Benefits": "Minimize risk",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "From pattern": "187",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "35",
            "Name": "Oracle",
            "Paper": "11",
            "Context & Problem": "A contract or blockchain-based application may sometimes need to access information from the external world.",
            "Solution": "The oracle pattern uses a third-party verifier to verify that information stored off-chain is valid, before it can be relayed to the blockchain.",
            "Benefits": "Maintain integrity",
            "Drawbacks/Liabilities": "Lack of trustability",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "From pattern": "52, 125, 201",
            "Related to": "45",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "36",
            "Name": "Off-chain Datastore",
            "Paper": "11",
            "Context & Problem": "Since the blockchain is a distributed store of data, many nodes in the network must store the entire blockchain, which becomes infeasible if too much data is stored in every block.",
            "Solution": "If the raw data to be stored on the blockchain takes too much memory, calculate a hash for the entire raw data and store this on the blockchain instead.",
            "Benefits": "Storage and cost efficiency, Data integrity",
            "Drawbacks/Liabilities": "Non-immutability",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "From pattern": "155",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "37",
            "Name": "State Channel",
            "Paper": "11",
            "Context & Problem": "As mentioned, storing large amounts of data on the blockchain is not sustainable for scalability and sometimes cost issues. In the case of micro-transactions, the amount being transacted is significantly lesser than the processing fees and will take up as much space as any other transaction on the chain.",
            "Solution": "Micro-transactions should not be stored on the blockchain; they should be stored off-chain and only the final settled amounts should be stored on-chain. There are some use-cases of this pattern, the most common being the Lightning Network in Bitcoin and Plasma in Ethereum.",
            "Application examples": "• Bitcoin Lightning Network (https://lightning.network/)• Plasma (https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/plasma/)",
            "Benefits": "Storage and cost efficiency",
            "Drawbacks/Liabilities": "Lack of trustability",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "From pattern": "58",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "38",
            "Name": "(Off-chain) Contract Registry",
            "Paper": "11",
            "Context & Problem": "Code on a smart contract may need to be modified or updated to deal with bugs and changing requirements.",
            "Solution": "Every contract and its address are stored off-chain as key-value pairs. This mapping is mutable since it is off-chain, which means that the address of a contract can be updated in the registry. Since calls to any contract will now go through the registry, this leaves all dependencies intact. ",
            "Benefits": "Flexibility",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "62, 132",
            "Related to": "48",
            "Based on non-blockchain pattern": "Proxy Pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "39",
            "Name": "Data Contract",
            "Paper": "11",
            "Context & Problem": "If a contract stores its data within itself, modifying the contract using the registry or proxy pattern will mean rewriting all of the data to the updated version as well. Since the outdated contracts still remain on the blockchain, and are only indirectly replaced by the updated versions, the data will be stored redundantly with every new version of the contract (Volland, 2018). Conversely, storing the data on a data contract would reduce redundant data storage.",
            "Solution": "Store data and code on separate contracts to decouple them.",
            "Benefits": "Storage and cost efficiency, Separation of concerns, Avoid unexpected errors",
            "Drawbacks/Liabilities": "Code complexity",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "64, 130",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "40",
            "Name": "Embedded Permission",
            "Paper": "11",
            "Context & Problem": "A good example of a critical or sensitive function is self destruct() in Solidity2. The absence of embedded permission to execute this particular function was leveraged in the Parity Wallet hack.",
            "Solution": "Contracts must have an embedded permission field for certain critical functions, which allows only authorized users to run them. This is comparable to an end-user not having access to all the back-end code.",
            "Benefits": "Authentication and Authorization",
            "Drawbacks/Liabilities": "Setup complexity",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "63, 160",
            "Based on non-blockchain pattern": "Facade",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "41",
            "Name": "Factory Contract",
            "Paper": "11",
            "Context & Problem": "Using a factory contract helps make a DApp’s code modular and reduces the amount of updates required when new functionality is added to the DApp. It also ensures that certain design principles are consistent throughout the application.",
            "Solution": "This pattern is similar to the idea of a class in programming languages. It entails storing a template contract on the blockchain to instantiate other contracts having a similar structure and flow",
            "Benefits": "Convenience",
            "Drawbacks/Liabilities": "Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "65, 198",
            "Based on non-blockchain pattern": "Factory",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "42",
            "Name": "Emergency Stop",
            "Paper": "11",
            "Context & Problem": "If a contract is executing malicious functions recursively or for several iterations, without the ability to interrupt, the malicious function can run indefinitely and the nodes can do nothing till execution completes.",
            "Solution": "Include the ability for an authorized party to stop the execution of a contract.",
            "Benefits": "Minimize risk",
            "Drawbacks/Liabilities": "Centralization risk",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "188",
            "Based on non-blockchain pattern": "Memento",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "43",
            "Name": "Mutex",
            "Paper": "11",
            "Context & Problem": "Having a recursive call (or a callback) that modifies the state of the parent, before it has finished its execution, can cause serious issues as described several times above.",
            "Solution": "This patern is similar to mutexes in traditional programming. It prevents a contract from executing code in its parent contract, until the parent has executed completely. ",
            "Benefits": "Synchronization",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "191",
            "Based on non-blockchain pattern": "Mutex",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "44",
            "Name": "Contract Balance Limit",
            "Paper": "11",
            "Context & Problem": "Having a contract with too much capital reduces the target area for a potential attack to take place.",
            "Solution": "This pattern states that a contract should not hold any more funds than a predefined balance-limit. It must reject any further transactions made to it except for forced payments.",
            "Benefits": "Minimize risk",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "192",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "45",
            "Name": "Reverse Verifier",
            "Paper": "11",
            "Context & Problem": "It is common to have application data in a traditional database and store only a hash on the blockchain. One shortcoming of this is that we cannot prevent tampering of data in the database.",
            "Solution": "Sometimes an application may need to access data from the blockchain. Like the oracle pattern, reverse verifier is used to verify data being sent to an external source from the blockchain.",
            "Benefits": "Availability and Authentication",
            "Drawbacks/Liabilities": "Lack of trustability, Efficiency",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "From pattern": "53",
            "Related to": "35",
            "Based on non-blockchain pattern": "Observer",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "46",
            "Name": "Incentive Execution",
            "Paper": "11",
            "Context & Problem": "Some functions perform tasks like cleaning up expired records, making dividend payouts and destroying deprecated contracts. These utility functions also require gas to be executed, and the payout is usually not enough to offset the execution cost. ",
            "Solution": "Make seldom-run utility functions piggyback onto contracts that execute more often.",
            "Benefits": "Good practice",
            "Drawbacks/Liabilities": "Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "From pattern": "66",
            "Based on non-blockchain pattern": "Composite",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "47",
            "Name": "Commit and Reveal",
            "Paper": "11",
            "Context & Problem": "If a contract’s internal state is visible to the network, it is possible for a malicious user to take advantage, and invoke the contract with deliberately selected variables that change the state to one they desire.",
            "Solution": "This pattern works by hiding certain secret variables in a contract’s function, and only displaying the final values. Authorized users may have access to the secret.",
            "Benefits": "Authentication and Authorization",
            "Drawbacks/Liabilities": "Code complexity, Centralization risk",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Encryption pattern",
            "From pattern": "124",
            "Based on non-blockchain pattern": "Iterator",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "48",
            "Name": "Proxy Contract",
            "Paper": "11",
            "Solution": "Create a proxy for each contract, which will accept, and then forward the parameters to the current version of the contract.",
            "Benefits": "Flexibility",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "133",
            "Related to": "38",
            "Based on non-blockchain pattern": "Proxy Pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "49",
            "Name": "Dynamic Binding",
            "Paper": "11",
            "Solution": "Create a dynamic association between a contract and its authorized users’ addresses, in such a way that the addresses are not defined in the contract. Instead, the users send a secret key to another, designated contract, which forwards the request to the the main one if the key is valid.",
            "Benefits": "Authentication and Authorization, Privacy",
            "Drawbacks/Liabilities": "Cost expensive, Compromized key vulnerable",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "159",
            "Based on non-blockchain pattern": "Chain of Responsibility",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "50",
            "Name": "Flyweight",
            "Paper": "11",
            "Solution": "Inspired in part by the data contract design pattern, the flyweight contract stores data that is shared by a group of clients in one common place.",
            "Benefits": "Storage and cost efficiency, Separation of concerns",
            "Drawbacks/Liabilities": "Cost expensive at request (on a public blockchain)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "199",
            "Related to": "39",
            "Based on non-blockchain pattern": "Flyweight",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "51",
            "Name": "Tight Variable Packing",
            "Paper": "11",
            "Solution": "Store static variables in smart contracts as the smallest possible data type that they can fit in. For example don’t store a value as an int if it could be stored as a byte.",
            "Benefits": "Storage and cost efficiency",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "From pattern": "Volland 2018",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "52",
            "Name": "Oracle",
            "Paper": "13",
            "Context & Problem": "From the software architecture perspective, blockchain can be viewed as a component or connector within a large software system [19]. In the case the blockchain is used as a distributed database for more general purposes other than financial services, the applications built on blockchain might need to interact with other external systems. Thus, the validation of transactions on blockchain might depend on states of external systems. The execution environment of a blockchain is self-contained. It can only access information present in the data and transactions on the blockchain. Smart contracts running on blockchain are pure functions by design. The state of external systems are not directly accessible to smart contracts. Yet, function calls in smart contracts sometimes need to access state of the external world. How can function calls in smart contracts be enabled to access the state of the external world from within smart contracts?",
            "Solution": "To connect the closed execution environment of blockchain with the external world, a oracle is introduced to evaluate conditions that cannot be expressed in a smart contract running within the blockchain environment. A oracle is a trusted third party that provides the smart contracts with information about the external world. When validation of a transaction depends on external state, the oracle is requested to check the external state and to provide the result to the validator (miner), which then takes the result provided by the oracle into account when validating the transaction. The oracle can be implemented inside a blockchain network as a smart contract with external state being injected into the oracle periodically by an off-chain injector. Later, other smart contracts can access the data from the oracle smart contract. ",
            "Application examples": "• Bitcoin Oracle (https://en.bitcoin.it/wiki/Contract#Example_4:_Using_external_state)• Gnosis (https://gnosis.pm)• Orisi (http://orisi.org)",
            "Benefits": "Connectivity",
            "Drawbacks/Liabilities": "Lack of trust, Lack of validity",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Related to": "53",
            "Requires": "Injector",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "53",
            "Name": "Reverse oracle",
            "Paper": "13",
            "Context & Problem": "In a software system, where blockchain is one of the components, the off-chain components might need to use the data stored on the blockchain and the smart contracts running on the blockchain to check certain conditions. Some domains use very large and mature (or even legacy) systems, which comply with existing standards. For such domains, an non-intrusive approach is desired to leverage the existing complex systems with blockchain without changing the core of the existing systems.",
            "Solution": "The unique ID ofthe transactions or blocks on blockchain is a piece of data that can be easily integrated into the existing systems. Validation of the data can be implemented by smart contracts running on blockchain. An off-chain component is required to query the blockchain through using the ID of the data.",
            "Application examples": "• Identitii (https://identitii.com)• Slock.it (https://slock.it/)",
            "Benefits": "Connectivity",
            "Drawbacks/Liabilities": "Intrusive to the system using it",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Related to": "52",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "54",
            "Name": "Legal and smart-contract pair",
            "Paper": "13",
            "Context & Problem": "The legal industry is becoming digitized, for example, using digital signatures has become a valid way to sign legal agreements. The Ricardian contract [8] was developed in the mid 1990s to interpret legal contracts digitally without losing the value of the legal prose. Digital legal agreements need to be executed and enforced. An independent trustworthy execution platform trusted by all the involved participants is needed to execute the digital legal agreement. How to bind a legal agreement to the corresponding smart contract on a trusted execution environment to ensure a 1-to-1 mapping?",
            "Solution": "Blockchain can be an ideal trusted platform to run digital legal agreements, which are bound with corresponding on-chain smart contracts. The smart contract implements conditions defined in the legal agreement. When deployed, there is a variable to store the hash value of the legal agreement, but is initially a blank value. The address of the smart contract is included in the legal agreement, and then the hash of the legal agreement is calculated and added to the contract variable. By binding a physical agreement with a smart contract, the bridge between the off-chain physical agreement and the on-chain smart contract is established. The two directional binding makes sure that the legal agreement and smart contract have",
            "Application examples": "• OpenLaw (http://openlaw.io)• Corda Smart Contract Template from Barclays• Project DnA (https://github.com/KingandWoodMallesonsAU/Project-DnA)• Accord Project (https://www.accordproject.org)• Florian Idelberger, Guido Governatori, Régis Riveret, and Giovanni Sartor. 2016. Evaluation of Logic-Based Smart Contracts for Blockchain Systems. In Rule Technologies. Research, Tools, and Applications. Springer, Stony Brook, NY, USA, 167–183.",
            "Benefits": "Automation, Audit trail, Clarification",
            "Drawbacks/Liabilities": "Lack of expressiveness, Difficulty of enforceability, Difficulty of interpretation",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "55",
            "Name": "Encrypting on-chain data",
            "Paper": "13",
            "Context & Problem": "For some applications on blockchain, there might be commercially critical data that should be only accessible to the involved participants. An example would be a special discount price offered by a service provider to a subset of its users. Such information should not be accessible to the other users who do not get the discount. The lack of data privacy is one of the main limitations of blockchain. All the information on blockchain is publicly available to the participants of the blockchain. There is no privileged user within the blockchain network, no matter the blockchain is public, consortium or private. On a public blockchain, new participants can join the blockchain network freely and access all the information recorded on blockchain. Any confidential data on public blockchain is exposed to the public.",
            "Solution": "To preserve the privacy ofthe involved participants, symmetric or asymmetric encryption can be used to encrypt data before inserting the data into blockchain. One possible design for sharing encrypted data among multiple participants is as follows. First, one of the involved participants creates a secret key for encrypting data and distributes it during an initial key exchange. When one of the participants needs to add a new data item to the blockchain, they first symmetrically encrypt it using the secret key. Only the participants allowed to access the transaction have the secret key and can decrypt the information.",
            "Application examples": "• Encrypted queries from Oraclize (https://blog.oraclize.it/encrypted-queries-private-data-on-a-public-blockchain-71d893fac2bf)• Crypto digital Signature from MLGBlockchain (https://mlgblockchain.com/crypto-signature.html)• Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos Papa• manthou. 2016. Hawk: The Blockchain Model of Cryptography and Privacy• Preserving Smart Contracts. In 37th IEEE Symposium on Security and Privacy (S&P2016). IEEE, Fairmont, SAN JOSE, CA, 839–858. https://doi.org/10.1109/SP. 2016.55",
            "Benefits": "Data confidentiality",
            "Drawbacks/Liabilities": "Compromized key, Impossibility to revoke access, Data immutability, Difficulties in key sharing",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Encryption pattern",
            "Related to": "57",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "56",
            "Name": "Tokenisation",
            "Paper": "13",
            "Context & Problem": "The concept of tokenisation has emerged centuries ago with the first currency systems. Tokenisation is a means to reduce risk in handling high value financial instruments by replacing them with equivalents, for example, the tokens used in casino. Tokens can represent a wide range of goods which are transferable and fungible, like shares, or tickets. Tokens representing assets should be the authoritative source of the corresponding assets.",
            "Solution": "Tokenisation is a process starting from an asset (e.g., money) is locked under a custody (e.g., a bank), and gets represented in the cryptographic world through a token. The ownership of the digital token matches the ownership of the corresponding asset. The reverse process can take place by which the user redeems the token to recover the value which is sitting within the bank. A token on blockchain is the authoritative source of the physical asset. By using smart contracts, some conditions can be implemented and associated with the ownership transfer.",
            "Application examples": "• Coloredcoin (http://coloredcoins.org)• Digix (https://digix.global)",
            "Benefits": "Mitigate risks, Trustworthiness",
            "Drawbacks/Liabilities": "Token authenticity, Lack of standardization, Ownership issues ",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Tokenization patterns",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "57",
            "Name": "Off-chain data storage",
            "Paper": "13",
            "Context & Problem": "Some applications consider using the blockchain to guarantee the integrity of large amounts of data. The blockchain, due to its full replication across all participants of the blockchain network, has limited storage capacity. Storing large amounts of data within a transaction may be impossible due to the limited size of the blocks of the blockchain (for example, Ethereum has a block gas limit to determine the number, computational complexity, and data size ofthe transactions included in the block). Data cannot take advantage of the immutability or integrity guarantees without being stored on the blockchain. How to store data of arbitrary size and take advantage of the immutability and integrity guarantees provided by the blockchain?",
            "Solution": "The blockchain can be used as a general-purpose replicated database, as transactions logged in the blockchain can include arbitrary data on some blockchain platforms. For data of big size (essentially data that is bigger than its hash value), rather than storing the raw data directly on blockchain, a representation of the data with smaller size can be stored on blockchain with other small sized metadata about the data (e.g., a URI pointing to it). The solution is to store a hash value (also called digest) of the raw data on chain. The value is generated by a hash function which maps data of arbitrary size to data of fixed size. Hash function is a one-way function which is easy to compute, but hard to invert given the output of a random input. If even one bit of the data changes, its corresponding hash value would change as well. The hash value is used for ensuring the integrity of the raw data stored off-chain, and the transaction on blockchain that includes the hash value guarantees the integrity of the hash value as well as the original raw data from which the hash was derived.",
            "Application examples": "• Proof-of-Existence (https://poex.io)• Chainy (https://chainy.info)",
            "Benefits": "Data integrity, Cost saving",
            "Drawbacks/Liabilities": "Data integrity, Data loss, Difficulty in sharing data",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Related to": "185",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "58",
            "Name": "State channel",
            "Paper": "13",
            "Context & Problem": "Micro-payments are payments that can be as small as a few cents, e.g., payment of a very small amount of money to a WiFi hot-spot for every 10 kilobytes of data usage. Blockchain has potential to be used for such financial transactions with tiny monetary value. The question is if it is necessary and cost effective to store all the micro-payment transactions on blockchain. The decentralized design of blockchain has limited performance. Transactions can take several minutes or even one hour (for Bitcoin blockchain) to be committed on the blockchain [17]. Due to the long commit time and high transaction fees on a public blockchain (where fees are largely independent of the transacted amount), it is often infeasible to store every micro-payment transaction on the blockchain network. ",
            "Solution": "A solution is to establish a payment channel between two participants, with a deposit from one or both sides of the participants locked up as security in a smart contract for the lifetime of the payment channel. The payment channel keeps the intermediate states of the micro-payment off-chain, and only stores the finalized payment on chain. The frequency of transaction settlement depends on the use case, and agreement between the two sides. A network of micro-payment channels can be built where the transactions transferring small values occur off-chain. The individual transactions take place entirely off the blockchain and exclusively between the participants, across multiple hops where needed. Only the final transaction that settles the payment for a given channel or set of channels is submitted to the blockchain. ",
            "Application examples": "• Bitcoin Lightning Network (https://lightning.network/)• Plasma (https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/plasma/)• Raiden Network (https://raiden.network)• Orinoco (http://www.orinocopay.com)• Gnosis (https://forum.gnosis.pm/t/how-offchain-trading-will-work/63)",
            "Benefits": "Efficiency, Privacy, Cost saving",
            "Drawbacks/Liabilities": "Lack of trust, Reduced liquidity, Complexity",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Related to": "194",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "59",
            "Name": "Multiple authorization",
            "Paper": "13",
            "Context & Problem": "In blockchain-based applications, activities might need to be authorized by multiple blockchain addresses. For example, a monetary transaction may require authorization from multiple blockchain addresses. The actual addresses that authorize an activity might not be able to be decided due to the availability of the authorities.",
            "Solution": "It would enable more dynamism if the set of blockchain addresses for authorization are not decided before the corresponding transaction being submited into the blockchain network, or the corresponding smart contract being deployed on blockchain. On the Bitcoin blockchain, a multi-signature mechanism can be used to require more than one private key to authorize a Bitcoin transaction. In Ethereum, smart contract can mimic multi-signature mechanism. More flexibly, an M-of-N multi-signature can be used to define that M out of N private keys are required to authorize the transaction. M is the threshold of authorization. This on-chain mechanism enables more flexible binding of authorities.",
            "Application examples": "• Bitcoin MultiSignature mechanism (https://en.bitcoin.it/Multisignature)• Solidity MultiSignature wallet through Mist (https://github.com/ethereum/mist)",
            "Benefits": "Flexibility, Lost key tolerance",
            "Drawbacks/Liabilities": "Setup complexity, Management costs, Difficulty of key management",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Benefits from": "60",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "60",
            "Name": "Off-chain secret enabled dynamic authentication",
            "Paper": "13",
            "Context & Problem": "In blockchain-based applications, some activities need to be authorized by one or more participants that are unknown when a first transaction is submitted to blockchain. Sometimes, the authority who can authorize a given activity is unknown when the corresponding smart contract is deployed, or the corresponding transaction is submitted to the blockchain. Blockchain uses digital signature for authentication and transaction authorization. Blockchain does not support dynamic binding with an address of a participant which is not defined in the respective transaction or smart contract. All accounts that can authorize a second transaction have to be defined in the first transaction before that transaction is added to the blockchain.",
            "Solution": "An off-chain secret can be used to enable a dynamic authorization when the participant authorizing a transaction is unknown beforehand. In the context of payment, for example, a smart contract can be used as an escrow. When the sender deposits the money to an escrow smart contract, a hash of a secret (e.g. a random string, called pre-image) is submitted with the money as well. Whoever receives the secret off-chain can claim the money from the escrow smart contract by revealing the secret. With this solution, the receiver of the money does not need to be defined beforehand in the escrow contract. This can be generalized to any transaction that needs authorization from a dynamically bound participant. Note that since the secret is revealed, it cannot be reused. One variant is to lock multiple transactions with the same secret – by unlocking one, all of them are unlocked.",
            "Application examples": "• Raiden network (https://raiden.network)• Bitcoin atomic cross-chain trading (https://en.bitcoin.it/wiki/Atomic_cross-chain_trading)",
            "Benefits": "Flexibility, Lost key tolerance, Routability, Interoperability",
            "Drawbacks/Liabilities": "One-off secret, Lost secret, Signature reveal at usage",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Encryption pattern",
            "Benefits from": "59",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "61",
            "Name": "X-confirmation",
            "Paper": "13",
            "Context & Problem": "Immutability of a blockchain using Proof-of-work (Nakamoto) consensus is probabilistic immutability. There is always a chance that the most recent few blocks are replaced by a competing chain fork. At the time a fork occurs, there is usually no certainty as to which branch will be permanently kept in the blockchain and which branches will be discarded. The transactions that were included in the branches being discarded eventually go back to the transaction pool and being added into a later block.",
            "Solution": "From the application perspective, one security strategy is to wait for a certain number (X) of blocks to be generated after the transaction is included into one block. After X blocks, the transaction is taken to be committed and thus perceived as immutable [17]. The value of X can be decided by the developers of the blockchain-based applications.",
            "Application examples": "• Bitcoin• Ethereum",
            "Benefits": "Immutability",
            "Drawbacks/Liabilities": "Latency",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Transactions pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "62",
            "Name": "Contract registry",
            "Paper": "13",
            "Context & Problem": "As any software application, blockchain-based applications need to be upgraded to new versions. To do so, the on-chain functions defined in smart contracts need to be updated to fix bugs as well as to fulfil new requirements. Smart contracts deployed on blockchain cannot be upgraded because the code of the smart contracts as a type of data, stored on blockchain is immutable.",
            "Solution": "An on-chain registry contract is used to maintain a mapping between user-defined symbolic names and the blockchain addresses of the registered contracts. The address of the registry contract needs to be advertised off-chain. The creator of a contract can register the name and the address ofthe new contract to the registry contract after the new contract being deployed. The invoker of a registered contract retrieves the latest version of the new smart contract from the registry contract. The corresponding functions provided by the registered contract can be upgraded by replacing the address of the old version contract in the registry contract with the address of a new version without breaking the dependency between the upgraded smart contract and other smart contracts that depend on its functions. The address of a contract is stored as a variable in the registry contract. The value of contract variables can be updated. The registry contract can have a permission control module to maintain the writing permission. Note that all the previous values of the variable are still stored on the blockchain.",
            "Application examples": "• Ethereum Name Service (ENS) (https://ens.domains/fr/)• Regis (https://regis.nu)",
            "Benefits": "Human-readable contract name, Consistent contract name, Transparent upgradeability, Version control",
            "Drawbacks/Liabilities": "Limited upgradeability, Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Benefits from": "63, 64",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "63",
            "Name": "Embedded permission",
            "Paper": "13",
            "Context & Problem": "All the smart contracts running on blockchain can be accessed and called by all the blockchain participants and other smart contracts by default, because there are no privileged users and, in the case of public blockchain, every participant can join the network to access all the information and code stored and running on blockchain. A smart contract by default has no owner, meaning that once deployed the author of the smart contract has no special privilege on the smart contract. A permission-less function can be triggered by unauthorized users accidentally. Such a permissionless function becomes vulnerability ofblockchain-based application.",
            "Solution": "Adding permission control to every smart contract function to check permissions for every caller that triggers the functions defined in the smart contract based on the blockchain addresses of the caller. This can be done by checking the authorization of the caller before executing the logic of the function: unauthorized calls are rejected and the execution of the function terminated before reaching the core logic of the function.",
            "Application examples": "• Solidity tutorial Mortal contract (https://docs.soliditylang.org/en/develop/contracts.html)• Solidity Restrict access pattern (https://docs.soliditylang.org/en/develop/contracts.html)",
            "Benefits": "Security, Secure authorization",
            "Drawbacks/Liabilities": "Cost expensive, Lack of flexibility",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Benefits from": "9, 59, 60",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "64",
            "Name": "Data contract",
            "Paper": "13",
            "Context & Problem": "The need to upgrade a blockchain-based application over time is ultimately necessary, so as the smart contracts used by the application. In general, logic and data change at different times and with different frequencies. There are different ways to store a data on blockchain, as discussed in Hash Integrity pattern (Section 5.3).Problem: Storing data on blockchain is expensive and there is a limitation on the amount ofdata and amount ofcomputation a transaction can contain. In the context of upgrading smart contracts, the upgrading transactions might contain a large data storage for copying the data from the old version of the smart contract to the new version of the smart contract. Porting data to a new version might even require multiple transactions, e.g. when the block gas limit on Ethereum prevents an overly complex data migration transaction. ",
            "Solution": "To avoid moving data during upgrades ofsmart contracts, the data store is isolated from the rest of the code. In the context of blockchain, data could be separately stored in different smart contracts to enable isolation. Depending on the circumstances of the application, how large of a data store it needs and whether the data structure is expected to change often, the data store could use a strict definition or a loosely typed flat store. The more generic and flexible data structure can be used by all the other logic smart contracts and is unlikely to require changes. One example of a generic data structure is a mapping to store SHA3 key and value pairs.",
            "Application examples": "• Chronobank (https://chronobank.io)• Colony (https://colony.io)",
            "Benefits": "Upgradeability, Cost saving with reuse, Generality",
            "Drawbacks/Liabilities": "Cost expensive at storage",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Benefits from": "62",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "65",
            "Name": "Factory contract",
            "Paper": "13",
            "Context & Problem": "Applications based on blockchain might need to use multiple instances of a standard contract with customization. Each contract instance is created by instantiating a contract template. For example, in a business process management system, each of the business process instances might be represented by a smart contract being generated from a contract template representing the business process model [18]. The template can be stored off-chain in a code repository, or on-chain, within its own smart contract. Keeping the contract template off-chain cannot guarantee consistency between different smart contract instances created from the same template because the source code of the template can be independently modified.",
            "Solution": "Smart contracts are created from a contract factory deployed on blockchain. The factory contract is deployed once from the off-chain source code. The factory may contain the definition of multiple smart contracts. Smart contract instances are generated by passing parameters to the contract factory to instantiate customized smart contract instances. Factory contract is analogous to a Class in an object-oriented programming language. Every transaction that generates a smart contract instance essentially instantiates an object of the factory contract class. This contract instance (the object) will maintain its own properties independently of the other instances but with a structure consistent with its original template.",
            "Application examples": "• Ingo Weber, Xiwei Xu, Regis Riveret, Guido Governatori, Alexander Ponomarev, and Jan Mendling. 2016. Untrusted Business Process Monitoring and Execution Using Blockchain. In BPM. Springer, Rio de Janeiro, Brazil, 329–347.• Peng Zhang, Jules White, Douglas C. Schmidt, and Gunther Lenz. 2017. Applying Software Patterns to Address Interoperability in Blockchain-based Healthcare Apps. (June 2017). arXiv:1706.03700• Ethereum developer tutorial (https://ethereumdev.io/interact-with-other-contracts-from-solidity/)",
            "Benefits": "Security, Efficiency",
            "Drawbacks/Liabilities": "Cost expensive at deployment, Cost expensive at call",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Benefits from": "62",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "66",
            "Name": "Incentive execution",
            "Paper": "13",
            "Context & Problem": "Smart contracts are event-driven programs, which cannot execute autonomously. All the functions defined in a smart contract need to be triggered either by a transaction from external account or another smart contract to execute. Other than the functions that provide regular services to users, some functions need to run asynchronously from regular user interaction, for example, to clean up the expired records, or make dividend payouts etc. Such functions usually involve a time, after which the function should start. Users of a smart contract have no direct benefit from calling the accessorial functions. If a public blockchain is used, executing these functions causes extra monetary cost. Some accessorial functions are expensive to execute.",
            "Solution": "Reward the caller of a function defined in a smart contract for invoking the execution, for example, sending back a percentage of payout to the caller to reimburse the (gas) execution cost.",
            "Application examples": "• Regis (https://regis.nu)• Ethereum Alarm Clock (http://www.ethereum-alarm-clock.com/)",
            "Benefits": "Completeness, Fairness to user",
            "Drawbacks/Liabilities": "Unguaranteed execution",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "67",
            "Name": "Master & Sub Key",
            "Paper": "14",
            "Context & Problem": "Public key cryptography and digital signatures are used to identify accounts and authorise transactions submitted to a blockchain. Using a single key for all transactions has serious privacy implication for an identity owner since transactions can be correlated to expose all the identities an entity holds.",
            "Solution": "Each entity can have a master-key to manage subkeys which are used for signing messages under different identities. For example, a person can have a sub-key for the student identity and another sub-key for the company intern identity. Each sub-key is linked to a unique identifier and stored as part of the identifier’s data in the identifier registry, which can be updated using the master-key. The use of masterkey must be minimised (i.e., only used for controlling subkeys) due to its importance.",
            "Application examples": "• uPort (https://www.uport.me)• Ethereum ERC 725 standard (https://github.com/ethereum/EIPs/issues/725)• Trinity on IOTA (https://trinity.iota.org)",
            "Benefits": "Identifiability, Privacy, Availability",
            "Drawbacks/Liabilities": "Compromized key vulnerable",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Wallet and keys pattern",
            "Requires": "68",
            "Benefits from": "69",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "68",
            "Name": "Hot & Cold Wallet Storage",
            "Paper": "14",
            "Context & Problem": "As a blockchain network participant, one entity can rely on so-called “wallets” to manage its accounts and interact with blockchain. An entity’s wallet may suffer malicious attacks, leading to key theft. The attacker can send transactions under that entity’s name to blockchain using a compromised key.",
            "Solution": "Users can choose to store keys in two types of wallets, namely hot wallet and cold wallet. Hot wallet refers to the blockchain gateways that are connected to Internet. Through a hot wallet, a user is able to directly conduct specific operations (e.g. generation) to its accounts and related decentralised identifiers stored on-chain. Cold wallet refers to key storage that is off-line, keeping the accounts from being hacked. A cold wallet can be any device disconnected from the internet or even a paper recording an entity’s keys. When the keys stored in a cold wallet are required for signing transactions, the user needs to connect the cold wallet device to a computer and copy-paste the key in the relevant field. A user can combine these two wallets: storing accounts that are frequently used in a hot wallet while using a cold wallet to keep those that are not used often.",
            "Application examples": "• MyEtherWallet (https://www.myetherwallet.com)• Trezor (https://trezor.io)• Ledger (https://www.ledger.com)",
            "Benefits": "Secure storage for Cold Wallet, Usability for Hot Wallet",
            "Drawbacks/Liabilities": "Unsecure storage for Hot Wallet, Lack of usability for Cold Wallet",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Wallet and keys pattern",
            "Benefits from": "74",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "69",
            "Name": "Key Sharding",
            "Paper": "14",
            "Context & Problem": "In self-sovereign identity, a participant may have multiple keys, for instance, signing key for transaction authorisation, public/private key pair for encryption/decryption, etc. Consequently, key management is significant to the users, especially credential issuers and holders. A user may lose or forget his/her secret keys under some circumstances, e.g. the device containing the keys is lost or broken. Losing the keys denotes that the owner could lose control over its blockchain accounts in self-sovereign identity and the related identities.",
            "Solution": "To protect the security of a secret key, one can spilt that key into several pieces as its requirement, and define a regrouping threshold. The key pieces can be kept in any way the user prefers, e.g., wrote on a paper and locked in a safe box, given to family and friends, etc. When a key is lost, the user needs to regain enough key pieces (more than the preset regrouping threshold), and these pieces can help rebuild the complete key. ",
            "Application examples": "• Parity (https://www.parity.io)• Crypto++ (https://cryptopp.com)",
            "Benefits": "Lost key tolerance, Decentralization, Flexibility",
            "Drawbacks/Liabilities": "Maintenance cost, Lack of security",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Wallet and keys pattern",
            "Related to": "74",
            "Requires": "68",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "70",
            "Name": "Identifier Registry",
            "Paper": "14",
            "Context & Problem": "Identity is defined as sets of attributes related to an entity. In software applications, identity attribute data needs to be accessed for a specific purpose. An identifier is a globally unique persistent series of digits and/or characters that is used to uniquely identify an entity (e.g. human, organisation, device) within one domain and can be used to retrieve the storage location of the identity attribute data. A Decentralised Identifier (DID) is a new type of identifier which is designed for cryptographically verifiable self-sovereign identity. In traditional centralised software systems, mappings between an identifier and the identity data storage location is maintained by a centralised single authority which may become a potential single point of failure. ",
            "Solution": "Implementing an identifier registry designed as a smart contract to maintain bindings between an identifier and the location of associated off-chain identity data attributes. This identifier registry smart contract is the main entry point for accessing the attributes of an identity, which can map each identifier to a storage (e.g. IPFS, Dropbox, etc.) location for the respective identity attributes (e.g. an IPFS hash linking to the IPFS storage location containing the user’s identity attributes). Only the identifier owner is allowed to update the storage location of identity attributes. Each identifier points to an identifier document which describes how to use that specific identifier, e.g. public keys used for digital signatures, service endpoints for interaction.",
            "Application examples": "• uPort (https://www.uport.me)• Sovrin (https://sovrin.org)• Jolocom (https://jolocom.io)",
            "Benefits": "Upgradeability, Scalability, Cost saving",
            "Drawbacks/Liabilities": "Integrity, Data loss",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Decentralized identity pattern",
            "Related to": "195, 184",
            "Requires": "67",
            "Benefits from": "74",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "71",
            "Name": "Multiple Registration",
            "Paper": "14",
            "Context & Problem": "An identifier is used to uniquely identify an entity and to retrieve the identity attribute data. Sending all transactions using a single identifier has serious privacy implication for an entity since these transactions can be correlated to expose all the identities this entity holds.",
            "Solution": "Each entity can establish a unique identifier for every relationship (i.e. every identity) they have, which allows keeping interactions with one entity entirely separate from any other entity. For example, the relationship a person builds with a hospital is completely separate to the one that is established with a university. Neither the hospital nor the university could proactively use the identifiers to correlate this person’s activities.",
            "Application examples": "• Sovrin (https://sovrin.org)• Blockstack (https://blockstack.org)• DAML (https://daml.com)",
            "Benefits": "Privacy, Availability",
            "Drawbacks/Liabilities": "Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Decentralized identity pattern",
            "Requires": "70, 67",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "72",
            "Name": "Bound with Social Media",
            "Paper": "14",
            "Context & Problem": "Social media profiles can be considered as one of the most important assets, which are critical to achieve more exposure on the internet, attract more attention, or improve online reputation. The trustworthiness of a social media profile can be improved by verifying the account using traditional identity issued by some central authority. On the other hand, blockchain provides a decentralised infrastructure for self-sovereign identity, where entities are in control over their own identities. In addition to verification by some certain people or central authorities, a user can link his/her social media profile (e.g. Twitter) to his/her identity registered on blockchain to improve the trustworthiness of both social media profile and blockchain-based identity. The problem here is how to bind a social media profile with the corresponding blockchain-based identity to ensure mapping.",
            "Solution": "An entity can create an attribute of social media in the identifier document. Signing the attribute with the blockchain signing key creates a claim that the blockchainbased identity controls the social media account. The attribute also contains a URL which links to a social media post stating that the social media account also controls this particular blockchain identity. Thus, a two-way link is established for connecting the blockchain identity with the social media profile. The two directional binding makes sure that that the social media profile and blockchain-based identity have a 1-to-1 mapping.",
            "Application examples": "• Onename (https://www.onename.com)",
            "Benefits": "Authoritative source, Secure storage, Verified accounts",
            "Drawbacks/Liabilities": "Lack of trustworthiness",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Decentralized identity pattern",
            "Requires": "70",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "73",
            "Name": "Dual Resolution",
            "Paper": "14",
            "Context & Problem": "In self-sovereign identity, entities interact with each other. When two or more entities want to establish interactions (e.g., for business purposes), each entity first needs to determine the target entity’s basic information and ways of communicating before going further.",
            "Solution": "A DDO contains verification methods (i.e. public keys) and service endpoints (e.g., messaging service details) which can be utilised by an entity to establish interactions with the corresponding DID owner. Before any formal activity between two entities in a relationship, they should first mutually resolve each other’s DID and obtain the interaction information stored in DDO. Such a process is considered as “Dual Resolution” and it forms the first step for any entity to establish an interoperation with its target entity.",
            "Benefits": "Interoperability, Independance",
            "Drawbacks/Liabilities": "Lack of privacy",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Decentralized identity pattern",
            "Requires": "70",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "74",
            "Name": "Delegate List",
            "Paper": "14",
            "Context & Problem": "Each identity has a key pair to authenticate the transactions initiated by the user by means of digital signatures. A master-key may be compromised/stolen by malicious hackers. A compromised master-key results in the loss of ownership over all sub-keys and corresponding identifiers. The hacker may utilise the identifiers to further steal the entity’s identity data.",
            "Solution": "Delegate List relies on a web of trust architecture. This requires an identity owner to designate its own set of trustees that the owner trusts to assist in identity ownership update when the owner asks for it. An identifier maintains a list of recovery delegates and an update threshold that can help the user recover identity. These delegates can be individuals or organisations. If key loss happens, the original identity owner needs to request for ownership update using a new key pair, and a minimum number of the trustees (e.g. 2 out of 3) must sign a new identity record transaction respectively. When there are enough confirmations (i.e. reaching the threshold) of the new key pair, the ownership of the identifier is updated and thus the identity is recovered. A timelock period can be specified to prevent an attacker who tries to compromise an identity owner’s key and immediately change the owner’s identity records, including his/her designated trustees to prevent identifier ownership recovery.",
            "Application examples": "• uPort (https://www.uport.me)• Sovrin (https://sovrin.org)",
            "Benefits": "Lost key tolerance, Reusability",
            "Drawbacks/Liabilities": "Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Decentralized identity pattern",
            "Related to": "74",
            "Variant of": "59",
            "Benefits from": "70, 191",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "75",
            "Name": "Selective Content Generation",
            "Paper": "14",
            "Context & Problem": "A verifier requires certain information to prove a holder’s identity, thus, a holder only needs to share a credential with necessary data to the verifer. If issuers publish general credentials to holders, a verifier can learn all identity data involved when only some particular attributes are needed. For instance, if a person shows his/her ID to identify the age, his/her address is presented either. This may cause data leak as extra information is provided.",
            "Solution": "Selective Content Generation allows issuers to decide what identity attributes are contained in a credential. An issued credential needs to satisfy the target verifier’s specific requirements of holder’s identity, without revealing extra data.",
            "Application examples": "• uPort (https://www.uport.me)• Sovrin (https://sovrin.org)",
            "Benefits": "Data privacy",
            "Drawbacks/Liabilities": "Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Requires": "78",
            "Benefits from": "76, 77",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "76",
            "Name": "Time-Constrained Access",
            "Paper": "14",
            "Context & Problem": "Usually an identification process lasts for a certain time period. After proving the identity of an entity, the presented credential has accomplished its mission and should not be accessed again. After receiving a credential, a verifier then has the ability to access, read, and verify certain identity data of the holder. If the credential is long-term or even permanently effective, the verifier then can verify the credential after current identification process, which means that it can still access and check the holder’s identity data when there is not a legitimate permission for proving the identity, resulting identity data leak.",
            "Solution": "A holder is able to generate an identifiable link, and define its accessible period (e.g. certain days). The link can redirect to a page presenting credential content. Afterwards, the holder can share the time-constrained link to verifiers instead of the original credential itself. Within the predefined accessible period, a verifier can visit and verify the credential for identification without limit. Nevertheless, when the link is expired, there is no approach for the verifier to obtain credential content again.",
            "Application examples": "• Snapchat (https://www.snapchat.com/)• Snappass (https://oneoffsecret.com/)",
            "Benefits": "Privacy, Flexibility",
            "Drawbacks/Liabilities": "Cost expensive, Privacy threats",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Variant of": "77",
            "Benefits from": "75",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "77",
            "Name": "One-Off Access",
            "Paper": "14",
            "Context & Problem": "A verifier does not require a long-term effective credential but only needs to check the identity of a holder once for a specific purpose. Sometimes an identification process does not require a strict verification procedure, but only needs to check the identity for once. For instance, travelling by train/airplane or going to a theme park only asks for checking credentials before entering. If a holder presents a long-term effective link redirecting to the credential content, a malicious verifier may access the holder’s data illegally after identification process. This can be considered as an extreme version of Time-Constrained Access.",
            "Solution": "A holder is able to generate an identifiable link, which redirects to a one-off page presenting the credential content. One-off links can be shared with verifiers on some special occasions. After being visited once, the link becomes invalid that no one can use it to access the credential content.",
            "Application examples": "• Snapchat (https://www.snapchat.com/)• Snappass (https://oneoffsecret.com/)",
            "Benefits": "Privacy, Constrained Access, Flexibility",
            "Drawbacks/Liabilities": "Cost expensive, Privacy threats",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Variant of": "76",
            "Benefits from": "75",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "78",
            "Name": "Anchoring to Blockchain",
            "Paper": "14",
            "Context & Problem": "Blockchain’s nature configurations may limit its performance when facing a large number of transactions. Blockchain can ensure data integrity via storing data on-chain, but it costs real money to process the transaction in many public blockchain networks. In addition, according to the nature consensus mechanism, blockchain generates a block in a fixed period (i.e. block interval), which only includes a restricted number of transactions due to the block size. Consequently, blockchain’s performance may be restricted when users frequently initiate transactions.",
            "Solution": "Blockchain Anchor relies on the hashing technology that one does not need to store everything on-chain, but periodically sends the unique hash value of off-chain data to blockchain.",
            "Application examples": "• Blockstack (https://blockstack.org/)• Chainpoint (https://chainpoint.org/)• I. Weber, Q. Lu, A. B. Tran, A. Deshmukh, M. Gorski, and M. Strazds, “A platform architecture for multi-tenant blockchain-based systems,” in2019 IEEE International Conference on Software Architecture (ICSA), March 2019, pp. 101–110.",
            "Benefits": "Cost saving, Scalability, Opacity",
            "Drawbacks/Liabilities": "Opacity",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Related to": "197, 57",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Identity management"
        },
        {
            "ID": "79",
            "Name": "Snapshotting",
            "Paper": "15",
            "Context & Problem": "The latest states and transactions of all accounts and smart contracts of the concert application need to be migrated to the target blockchain. Source blockchain is currently active; hence, the global state continues to change as new transactions arrive. The state to be migrated is already aggregated on the source blockchain.How to get a complete account of states, smart contracts, and transactions on the source blockchain before migration?",
            "Solution": "Get a snapshot of relevant states, smart contracts, and transactions on the source blockchain at a given time. First, select a block number to initiate the snapshotting process and number of blocks to wait for finality (aka., x-confirmation). Second, update all instances of the BAL (Blockchain Access/API Layer). Third, the BAL should wait until the chosen block number is reached. Once reached, it should freeze processing further transactions to prevent any state changes. BAL should further wait for x-confirmation to ensure the finality of already issued transactions. Once it is reached, the migration tool can extract all required states, smart contracts, and transactions by querying the source blockchain via the BAL. Finally, all extracted data are saved as a snapshot file",
            "Application examples": "• VeChain, “VeChainThor wallet manual including token swap and X node migration,” July 2018. https://cdn.vechain.com/vechainthor wallet manual en v1.0.pdf.• A. Milano, “$3 billion blockchain Tron kicks off token migration,” June 2018. https: //coindesk.com/3-billion-blockchain-tron-kicks-off-token-migration-today.• R. Peter, “Spin-offs: Bootstrap your alt-coin with a Bitcoin-blockchain-based initial coin distribution,” Apr. 2014. https://bitcointalk.org/index.php?topic=563972.0.• T. Foundation, “Telos token distribution - Use of the EOS genesis snapshot & why,” Aug. 2018. https://medium.com/telos-foundation/telos-token-distribution-use-of-the-eos-genesis-snapshot-why-2d849a2b0055.• T. Publisher, “TomoChain’s mainnet launch, and token swapping schedule,” Nov. 2018. https://medium.com/tomochain/tomochains-mainnet-launch-and-token-swapping-schedule-6f556e2f772.• TRONbet, “ANTE/WIN: Prepare for take-off,” July 2019. @tronbethelp/ante-win-prepare-for-take-off-353d41b43401.https://medium.com/",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Requires": "83, 84, 85",
            "Based on non-blockchain pattern": "Snapshot",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "80",
            "Name": "State Aggregation",
            "Paper": "15",
            "Context & Problem": "Concert application has a large number of accounts and states. Extracting all states from the source blockchain and recreating them on the target blockchain is both costly and time-consuming. The list of states to be migrated is given in the snapshot or ID database. How to extract and recreate a large number of states while minimizing the time and cost?",
            "Solution": "Transfer all ConcertCoins to a single account, such that only the closing balance needs to be migrated. Fig. 5 shows the sequence of activities required to perform such an aggregation of state. To aggregate blockchain native assets, first, create a new account on the source blockchain. To aggregate states embedded in smart contracts, deploy a new Smart Contract (SC). Both cases will produce a new address (aggregateAddress). Then get the users’ consent to transfer their states by signing a transaction with the current state as payload and aggregateAddress as the recipient. Next, submit the signed transaction to the source blockchain. Finally, trigger the aggregate function at the aggregateAddress.",
            "Application examples": "• B. C. Assistant, “Binance chain mainnet swap,” May 2019.community.binance.org/topic/44/binance-chain-mainnet-swap.• B. Wiki, “How to cheaply consolidate coins to reduce miner fees,” May 2019. https: //en.bitcoin.it/wiki/How to cheaply consolidate coins to reduce miner fees.• Storj, “Token migration plan pt.1,” Apr. 2017. https://storj.io/blog/2017/04/token• migration-plan-pt.1/.• J. Wilcke, “To fork or not to fork,” July 2016. https://blog.ethereum.org/2016/07/15/ to-fork-or-not-to-fork/.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Requires": "57",
            "Benefits from": "79",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "81",
            "Name": "Token Burning",
            "Paper": "15",
            "Context & Problem": "Because the source blockchain used by the nonprofit is public, it is not decommissioned after the migration. Therefore, any state and smart contracts left in the source blockchain could be misused (e.g., double spending). The list of states and smart contracts to be migrated is given in the snapshot or ID database. How to prevent the misuse of states and smart contracts after migration?",
            "Solution": "Use transactions to transfer states such as native assets and tokens to an unusable account. Delete tokens by calling respective functions on the smart contracts that created them. Similarly, smart contracts can call the self-destruct function. All such attempts to make states and smart contracts unusable are referred to as token burning.",
            "Application examples": "• B. C. Assistant, “Binance chain mainnet swap,” May 2019.community.binance.org/topic/44/binance-chain-mainnet-swap. https://• S. News, “Prepare yourself for the Safex blockchain swap,” Sep. 2018. https://safexnews.net/prepare-for-safex-blockchain-swap/.• VeChain, “VeChainThor wallet manual including token swap and X node migration,” July 2018. https://cdn.vechain.com/vechainthor wallet manual en v1.0.pdf.• A. Garoffolo and R. Viglione, “Sidechains: Decoupled consensus between chains,” Oct. 2018. https://horizen.global/assets/files/Horizen-Sidechains-Decoupled-Consensus-Between-Chains.pdf.• B. Sigman and A. Siniscalchi, “Teleport your ERC20 tokens to EOS.” https://github.com/ sheos-org/eos21.• Qubicles, “Migrating ethereum Qubicle tokens to the Telos chain of EOS.IO using the EOS21 protocol,” Jan. 2019. https://medium.com/@Qubicles/migrating-ethereum-qubicle-tokens-to-the-telos-chain-of-eos-io-using-the-eos21-protocol-e79c14fcf112.• BitGuild, “Bitizens is moving to TRON,” Dec. 2018. https://medium.com/the-notice-board/bitizens-is-moving-to-tron-71e5c9a39ef.• KARMA, “KARMA is moving from EOS to WAX,” Nov. 2019. https://medium.com/ @karmaapp/karma-is-moving-from-eos-to-wax-b081100c2702.• B. Wiki, “Proof of burn,” Jan. 2018. https://en.bitcoin.it/wiki/Proof of burn.-Storj, “Token migration plan pt.1,” Apr. 2017. https://storj.io/blog/2017/04/token-migration-plan-pt.1/",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Benefits from": "79",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "82",
            "Name": "Node Sync",
            "Paper": "15",
            "Context & Problem": "The nonprofit wants to add new nodes or swap nodes to change the physical location, improve performance, or create multiple instances of the source blockchain. A snapshot of the source blockchain is available. How to clone a blockchain node?",
            "Solution": "First, install the source blockchain platform’s client software (or an updated version that is backward compatible) on the new node. Also, configure the new node to connect to other members of the source blockchain. Second, enable the sync tool on the node to copy various data structures representing the global state, smart contracts, transactions, and blocks from other blockchain nodes. Next, the node should rebuild and validate all the transactions from the genesis to verify the global state. Any errors, such as failed data transfer, need to be resolved by requesting further data. Finally, reconfigure the node to accept new transactions.",
            "Application examples": "• B. Network, “Bithereum’s hard spoon snapshot is complete!,” Dec. 2018. https: //medium.com/bithereum-network/bithereums-hard-spoon-snapshot-is-complete-c1814024ea9a.• V. Buterin, “A next-generation smart contract and decentralized application platform,” 2014. https://github.com/ethereum/wiki/wiki/White-Paper.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Benefits from": "79, 80",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "83",
            "Name": "Establish Genesis",
            "Paper": "15",
            "Context & Problem": "Concert application has a large number of states, and all of them need to be recreated on the target blockchain. The nonprofit has decided to spin up a new blockchain instance as the target and use ConcertCoin as the native asset. The list of accounts and states to be migrated is given in the snapshot. After the snapshot, states are marked as unusable using token burning. Relevant smart contracts are also redeployed. How to load states to the target blockchain?",
            "Solution": "Use the snapshot of states from the source blockchain to set states on the target blockchain’s genesis block during its initialization. If a user cannot use an existing private key to prove its ownership of a state migrated to the target blockchain, a new key pair needs to be created. Thus, the first step is to get each user to create a new key pair and a corresponding account ID (accID) using the account creation algorithm of the target blockchain. Second, update the account ID in the snapshot file with accID. Next, create the genesis block configuration file (aka., genesis file) while including the accounts and states from the updated snapshot file. Then use the genesis file to initialize the target blockchain. Update the ID database on the BAL to reflect the new set of accIDs. Also, add a PoE entry that tracks the mapping between old and new account IDs to record how the new accounts came into existence.",
            "Application examples": "• B. Network, “Bithereum’s hard spoon snapshot is complete!,” Dec. 2018. https: //medium.com/bithereum-network/bithereums-hard-spoon-snapshot-is-complete-c1814024ea9a.• Aeternity-team, “Frequently asked questions (FAQ): Token migration phases 1, 2, 3,” Sep. 2019. https://forum.aeternity.com/t/frequently-asked-questions-faq-token-migration-phases-1-2-3/1411.• T. Foundation, “Telos token distribution - Use of the EOS genesis snapshot & why,” Aug. 2018. https://medium.com/telos-foundation/telos-token-distribution-use-of-the-eos-genesis-snapshot-why-2d849a2b0055.• Zeepin, “Announcement: Launch of ZEEPIN mainnet and mapping of ZPT and Gala,” Aug. 2018. https://medium.com/zeeblog/announcement-launch-of-zeepin-mainnet-and-mapping-of-zpt-and-gala-e34735c65418.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Benefits from": "79, 80",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "84",
            "Name": "Hard Fork",
            "Paper": "15",
            "Context & Problem": "Concert application has a large number of states, and all of them need to be recreated on the target blockchain. The nonprofit has chosen an existing private or consortium blockchain as the target. The list of accounts and states to be migrated is given in the snapshot. After the snapshot, states are marked as unusable using token burning. How to load states to the target blockchain?",
            "Solution": "Use the states from the snapshot to change the global state on the target blockchain. If a user cannot use an existing private key to access the state migrated to the target blockchain, follow the first two steps to create a new account and update the snapshot file similar to the establish genesis pattern. Next, update the blockchain client software on all nodes of the target blockchain to include the snapshot file at a set block number (blockNo). Once the blockNo is reached, all blockchain nodes should append the states from the snapshot file into the ledger to update the global state. Due to the arbitrary addition of new states, blocks produced before and after the software update will be incompatible. Such a change in blockchain state transition rules is referred to as a hard fork [59]. Similar to the establish genesis pattern, update the ID database and add a PoE entry to reflect new account IDs.",
            "Application examples": "• Aeternity-team, “Frequently asked questions (FAQ): Token migration phases 1, 2, 3,” Sep. 2019. https://forum.aeternity.com/t/frequently-asked-questions-faq-token-migration-phases-1-2-3/1411.• Hive.IO, “Announcing the launch of Hive blockchain,” Mar. 2020. https://steempeak.com/ communityfork/@hiveio/announcing-the-launch-of-hive-blockchain.• J. Wilcke, “To fork or not to fork,” July 2016. https://blog.ethereum.org/2016/07/15/ to-fork-or-not-to-fork/.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Benefits from": "79, 80",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "85",
            "Name": "State Initialization",
            "Paper": "15",
            "Context & Problem": "Concert application has a large number of states and smart contracts, and all of them need to be recreated on the target blockchain. The nonprofit has chosen an existing public blockchain as the target. The list of accounts, smart contracts, and states to be migrated is given in the snapshot or ID database. After the snapshot, states are marked as unusable using token burning. How to load states to the target blockchain?",
            "Solution": "Create one state at a time on the target blockchain. If a user cannot use an existing private key to access the state migrated to the target blockchain, follow the first step to create a new account similar to the establish genesis pattern. Then get the user to sign a transaction with the state listed in the snapshot as the payload and new address (i.e., accID) on the target blockchain as the recipient. Then submit the signed transaction to the target blockchain to recreate the state. Similar to the establish genesis pattern, update the ID database, and add a PoE entry to reflect new account IDs. It is also desirable to include the snapshot file as a PoE entry, as it is not included in the target blockchain’s history compared to establish genesis and hard fork patterns.",
            "Application examples": "• B. C. Assistant, “Binance chain mainnet swap,” May 2019. https://community.binance.org/topic/44/binance-chain-mainnet-swap. • VeChain, “VeChainThor wallet manual including token swap and X node migration,” July 2018. https://cdn.vechain.com/vechainthor wallet manual en v1.0.pdf.• A. Milano, “$3 billion blockchain Tron kicks off token migration,” June 2018. https: //coindesk.com/3-billion-blockchain-tron-kicks-off-token-migration-today.• B. Network, “Bithereum’s hard spoon snapshot is complete!,” Dec. 2018. https: //medium.com/bithereum-network/bithereums-hard-spoon-snapshot-is-complete-c1814024ea9a.• Qubicles, “Migrating ethereum Qubicle tokens to the Telos chain of EOS.IO using the EOS21 protocol,” Jan. 2019. https://medium.com/@Qubicles/migrating-ethereum-qubicle-tokens-to-the-telos-chain-of-eos-io-using-the-eos21-protocol-e79c14fcf112• BitGuild, “Bitizens is moving to TRON,” Dec. 2018. https://medium.com/the-notice-board/bitizens-is-moving-to-tron-71e5c9a39ef.• Effect.AI, “Effect.AI brings artificial intelligence to EOS main net,” Feb. 2019. https://medium.com/effect-ai/effect-ai-brings-artificial-intelligence-to-eos-main-net-ead7e68e09fa.• Gifto Official, “Mass adoption token meets mass adoption chain: Gifto migrates to Binance chain,” Apr. 2019. https://medium.com/@gifto/mass-adoption-token-meets• mass-adoption-chain-gifto-migrates-to-binance-chain-af8cf906e13a.• K. Ecosystem, “Kin blockchain migration - iOS,” Apr. 2018. https://kinecosystem.github.io/kin-ecosystem-sdk-docs/docs/migration ios.• Storj, “Token migration plan pt.1,” Apr. 2017. https://storj.io/blog/2017/04/token-migration-plan-pt.1/.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Benefits from": "79, 80",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "86",
            "Name": "Exchange Transfer",
            "Paper": "15",
            "Context & Problem": "Concert application has a large number of states, and all of them need to be recreated on the target blockchain. The nonprofit has chosen an existing public blockchain as the target and ConcertCoins are to be converted to its native assets. The list of states to be migrated can be found from the ID database. How to load states to the target blockchain?",
            "Solution": "Use a cryptocurrency/token exchange to transfer the states. If a user cannot use an existing private key to access the state migrated to the target blockchain, follow the first step to create a new account similar to the establish genesis pattern. Then get the user to sign a transaction with both the state and new account ID (i.e., accID) on the target blockchain as the payload. Set the address of the exchange (excAddress) as the recipient. Then submit the signed transaction to transfer the state to exchange’s account on the source blockchain. This is similar to a sell order in financial markets. Once the exchange confirms that the state is transferred to its account, it will look for a matching buy order. Once a match is made, the exchange will transfer the state to the accID using its account in the target blockchain. Similar to the establish genesis pattern, finally update the ID database to reflect new account IDs.",
            "Application examples": "• B. C. Assistant, “Binance chain mainnet swap,” May 2019.community.binance.org/topic/44/binance-chain-mainnet-swap. https://• VeChain, “VeChainThor wallet manual including token swap and X node migration,” July 2018. https://cdn.vechain.com/vechainthor wallet manual en v1.0.pdf.• A. Milano, “$3 billion blockchain Tron kicks off token migration,” June 2018. https: //coindesk.com/3-billion-blockchain-tron-kicks-off-token-migration-today.• B. Sigman and A. Siniscalchi, “Teleport your ERC20 tokens to EOS.” https://github.com/ sheos-org/eos21.• K. Network, “Istanbul upgrade: Kyber smart contract migration,” Nov. 2019. https://blog.kyber.network/istanbul-upgrade-kyber-smart-contract-migration-c8a6bcd84a1b.• Gifto Official, “Mass adoption token meets mass adoption chain: Gifto migrates to Binance chain,” Apr. 2019. https://medium.com/@gifto/mass-adoption-token-meets-mass-adoption-chain-gifto-migrates-to-binance-chain-af8cf906e13a.• S. Thomas and E. Schwartz, “A protocol for interledger payments,” 2015. https: //interledger.org/interledger.pdf.• T. Publisher, “TomoChain’s mainnet launch, and token swapping schedule,” Nov. 2018. https://medium.com/tomochain/tomochains-mainnet-launch-and-token-swapping-schedule-6f556e2f772.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Benefits from": "79, 80",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "87",
            "Name": "Transaction Replay",
            "Paper": "15",
            "Context & Problem": "Concert application has a large number of accounts, states, transactions, and smart contracts. All of which need to be recreated on the target blockchain while preserving the history of state changes. The initial state is already recreated on the target blockchain. List of transactions to be replayed can be found from the snapshot. How to recreate both the states and history on the target blockchain?",
            "Solution": "Replay transactions from the source blockchain. When replaying transactions on the target blockchain, their causal relationships must be preserved, e.g., the order of transactions send/received by an account may need to be preserved to maintain consistency of a state. Therefore, first group related transactions in the snapshot file. If abstraction is acceptable, also aggregate the transactions in a group such that the final state is consistent. Third, concurrently replay each independent group of transactions on the target blockchain, while sequentially replaying all transactions within a group to preserve causal relationships. When the private keys or signature format of the source and target blockchains are different, transactions need to be signed again before replaying on the target blockchain. Address of the recipient also needs to be updated when the same addresses cannot be used across the blockchains. Then submit the signed transaction to the target blockchain. The transaction ID (txID) is likely to vary across blockchain instances, and also depends on nonce, sender and receiver addresses, and transaction fees. Hence, use the second last step to update the mapping between old and new txIDs on the ID database on the BAL. Finally, add a PoE entry to reflect new transactions IDs. If translations are aggregated, also include the snapshot file as a PoE entry, as it is not included in the target blockchain’s history.",
            "Application examples": "• SFOX, “Life after hard forks: What you need to know about replay protection,” Feb. 2019. https://blog.sfox.com/life-after-hard-forks-what-you-need-to-know-about-replay-protection-ab8adaf6ddf6gi=9b4099fe431.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Benefits from": "79, 80",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "88",
            "Name": "Virtual Machine Emulation",
            "Paper": "15",
            "Context & Problem": "Concert application uses a set of smart contracts and embedded states which need to be usable on the target blockchain. The target blockchain platform could run/emulate the Virtual Machine (VM) used to execute smart contracts. The list of smart contracts and their states to be migrated is given in the snapshot. After the snapshot, smart contracts are marked as unusable using token burning. How to run smart contracts written for one blockchain platform on another?",
            "Solution": "Use the process outlined in Fig. 12 to reuse the smart contract execution environment (aka., VM, sandbox, or container) on the target blockchain. First, copy the VM from the source blockchain. Second, integrate the VM into the target blockchain. Third, if the VM does not hold the smart contract code, redeploy the smart contracts on the target blockchain using the state initialization pattern. Fourth, use the same pattern to set the states of the deployed smart contracts. Smart contract code and their states can be found from the snapshot. Sixth, update the mapping between old and new smart contract addresses on the ID database, as smart contract addresses vary across blockchain instances, and could also depend on the address that deployed the smart contract, transaction sequence number, among others. Finally, it is also desirable to include the snapshot file and mapping between old and new smart contract addresses as a PoE entry, as they are not included in the target blockchain’s history.",
            "Application examples": "• G. G. G. et al., “Sbft: A scalable and decentralized trust infrastructure,” in 49th Annual IEEE/IFIP Intl. Conf. on Dependable Systems and Networks (DSN ’20), pp. 568 – 580, June 2019.• Hyperledger, “Hyperledger Fabric now supports Ethereum,” Oct. 2018. https:// hyperledger.org/blog/2018/10/26.• P. H. Madore, “Deloitte ditches Ethereum for VeChain, brags about overtaking Bitcoin transactions,” May 2019. https://finance.yahoo.com/news/deloitte-ditches-ethereum-vechain-brags-065730503.html.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Benefits from": "79",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "89",
            "Name": "Smart Contract Translation",
            "Paper": "15",
            "Context & Problem": "Concert application uses a set of smart contracts and associated states which need to be usable on the target blockchain. The smart contract language of the target blockchain is not interoperable. The list of smart contracts and their states to be migrated is given in the snapshot. How to run smart contracts written for one blockchain platform on another?",
            "Solution": "Translate and deploy a smart contract on the target blockchain. First, verify that the respective source code produces the exact smart contract deployed on the source blockchain. Second, translate the smart contract to the new language. Then, test the functional correctness and security of the translated contract. Fourth, deploy the new smart contract to the target blockchain using the state initialization pattern. Fifth, use the same pattern to set the states of the deployed contract, as per the state recorded on the snapshot. Next, update the mapping between old and new smart contract addresses on the ID database, as smart contract addresses vary across different blockchain instances and could also depend on the address that deployed the smart contract, transaction sequence number, among others. Finally, it is also desirable to include the original and translated code, snapshot file, and mapping between old and new smart contract addresses as a PoE entry, as they are not included in the target blockchain’s history.",
            "Application examples": "• A. Milano, “$3 billion blockchain Tron kicks off token migration,” June 2018. https: //coindesk.com/3-billion-blockchain-tron-kicks-off-token-migration-today.• K. Network, “Istanbul upgrade: Kyber smart contract migration,” Nov. 2019. https://blog.kyber.network/istanbul-upgrade-kyber-smart-contract-migration-c8a6bcd84a1b.• Augur, “Serpent compiler vulnerability, REP & Solidity,” July 2017. https://medium.com/@AugurProject/serpent-compiler-vulnerability-rep-solidity-migration-5d91e4ae90dd.• Counterparty, “Smart contracts/EVM FAQ.” https://counterparty.io/docs/faq-smartcontracts/.• TRONbet, “ANTE/WIN: Prepare for take-off,” July 2019. https://medium.com/@tronbethelp/ante-win-prepare-for-take-off-353d41b43401.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Migration pattern",
            "Benefits from": "79",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "90",
            "Name": "Blockchain Security Pattern for Big Data Ecosystems",
            "Paper": "17",
            "Context & Problem": "Usually Data lakes are chaotic; they are a store where all the data of a company is accumulated without any kind of structure or rules to use it. For that reason, some people have started to call it Data swamps [12]. This problem can lead to a decrease of the value of the data. The Blockchain security pattern for Big Data Ecosystem tries to improve the traceability and integrity of the data stored in this kind of systems. In a nutshell, this security pattern will help in the implementation of a security solution to tackle a vulnerability of a Big Data ecosystem: huge amount of data can lead to a loss of control of the data and the operations that are performed on them, which can cause a loss of confidence in them.",
            "Solution": "The solution is based on the incorporation of a Blockchain layer that uses the same nodes utilized by the Big Data ecosystems. This layer will act as distributed ledger system that registers all the operations performed over the data stored. In the following subsection, our solution is explained in more detail. The Blockchain security pattern for Big Data ecosystems uses the elements of the SRA as a way to facilitate its implementation in a real scenario. More specifically, this pattern tries to improve the security of the Collector (in the BDAP component) which is implemented by the elements of the BDFP component.",
            "Application examples": "• Omnilytics (https://platform.omnilytics.co)",
            "Benefits": "Analytics quality, Analytics value, Data integrity, Data traceability",
            "Drawbacks/Liabilities": "Storage size increase, Performance",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Big data pattern",
            "Variant of": "Security Logger/Auditor Pattern [11]",
            "Requires": "Role-Based Access Control Pattern [11]",
            "Benefits from": "Authorization for Key-Value NoSQL Databases [21].",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Big Data"
        },
        {
            "ID": "91",
            "Name": "Proxy",
            "Paper": "20",
            "Context & Problem": "SCs are immutable. If a SC must be changed due to a bug or a needed extension, you must deploy a new contract, and also update all SCs making direct calls to the old SC, thus deploying also new versions of these. This can be very expensive.",
            "Solution": "Use Proxy delegate pattern. Proxy patterns are a set of SCs working together to facilitate upgrading of SCs, despite their intrinsic immutability. A Proxy holds the addresses of referred SCs, in its state variables, which can be changed. In this way, only the references to the new SC must be updated.",
            "Benefits": "Cost saving",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Benefits from": "92",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "92",
            "Name": "Data contract",
            "Paper": "20",
            "Context & Problem": "When a SC holding a significant amount of data must be updated, also all its data must be copied to the newly deployed SC, consuming a lot of gas.",
            "Solution": "Keep the data in a separate SC, accessed by one or more SC, using the data and holding the processing logic. If this logic must be updated, the data remain in the Data Contract. This pattern usually is included also in the implementations of the Proxy pattern.",
            "Benefits": "Cost saving",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "93",
            "Name": "Event log",
            "Paper": "20",
            "Context & Problem": "Often events maintain important information about the system, which must be later used by the external system interacting with the blockchain. Storing this information in the blockchain can be very expensive, if the number of events is high.",
            "Solution": "If past events data are needed by the external system, but not by SCs, let the external system directly access the Event Log in the blockchain. Note that this Log is not accessible by SCs, and that if the event happened far in time, the time to retrieve it may be long.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Storage pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "94",
            "Name": "Limit storage",
            "Paper": "20",
            "Context & Problem": "Storage is by far the most expensive kind of memory, so its usage should be minimized.",
            "Solution": "Limit data stored in the blockchain, always use memory for non-permanent data. Also, limit changes in storage: when executing functions, save the intermediate results in memory or stack and update the storage only at the end of all computations.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "95",
            "Name": "Packing variables",
            "Paper": "20",
            "Context & Problem": "In Ethereum, the minimum unit of memory is a slot of 256 bits. You pay for an integer number of slots even if they are not full.",
            "Solution": "Pack the variables. When declaring storage variables, the packable ones, with the same data type, should be declared consecutively. In this way, the packing is done automatically by the Solidity compiler. (Note that this pattern does not work for Memory and Calldata memories, whose variables cannot be packed.)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "96",
            "Name": "Packing booleans",
            "Paper": "20",
            "Context & Problem": "In Solidity, Boolean variables are stored as uint8 (unsigned integer of 8 bits). However, only 1 bit would be enough to store them. If you need up to 32 Booleans together, you can just follow the Packing Variables pattern. If you need more, you will use more slots than actually needed.",
            "Solution": "Pack Booleans in a single uint256 variable. To this purpose, create functions that pack and unpack the Booleans into and from a single variable. The cost of running these functions is cheaper than the cost of extra Storage.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "97",
            "Name": "Uint* vs Uint256",
            "Paper": "20",
            "Context & Problem": "The EVM run on 256 bits at a time, thus using an uint* (unsigned integers smaller than 256 bits), it will first be converted to uint256 and it costs extra gas.",
            "Solution": "Use unsigned integers smaller or equal than 128 bits when packing more variables in one slot (see Variables Packing pattern). If not, it is better to use uint256 variables.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Related to": "97",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "98",
            "Name": "Mapping vs Array",
            "Paper": "20",
            "Context & Problem": "Solidity provides only two data types to represents list of data: arrays and maps. Mappings are cheaper, while arrays are packable and iterable.",
            "Solution": "In order to save gas, it is recommended to use mappings to manage lists of data, unless there is a need to iterate or it is possible to pack data types. This is useful both for Storage and Memory. You can manage an ordered list with a mapping using an integer index as a key.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "99",
            "Name": "Fixed size",
            "Paper": "20",
            "Context & Problem": "In Solidity, any fixed size variable is cheaper than variable size.",
            "Solution": "Whenever it is possible to set an upper bound on the size of an array, use a fixed size array instead of a dynamic one.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "100",
            "Name": "Default value",
            "Paper": "20",
            "Context & Problem": "It is good software engineering practice to initialize all variables when they are created. However, this costs gas in Ethereum.",
            "Solution": "In Solidity, all variables are set to zeroes by default. So, do not explicitly initialize a variable with its default value if it is zero.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "101",
            "Name": "Minimize on-chain data",
            "Paper": "20",
            "Context & Problem": "The gas costs of Storage are very high, and much higher than the cost of Memory.",
            "Solution": "Minimize on-chain data. The less data you put on-chain in Storage variables, the less your gas costs. Store on-chain only critical data for the SC and keep all possible data off-chain.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "102",
            "Name": "Explicitely mark external function",
            "Paper": "20",
            "Context & Problem": "The input parameters of public functions are copied to memory automatically, and this costs gas.",
            "Solution": "The input parameters of external functions are read right from Calldata memory. Therefore, explicitly mark as external functions called only externally.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "103",
            "Name": "Limit external calls",
            "Paper": "20",
            "Context & Problem": "Every call to an external SC is rather expensive, and even potentially unsafe.",
            "Solution": "Limit external calls. In Solidity, differently from other programming languages, it is better to call a single, multi-purpose function with many parameters and get back the requested results, rather than making different calls for each data.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "104",
            "Name": "Internal function calls",
            "Paper": "20",
            "Context & Problem": "Calling public functions is more expensive than calling internal functions, because in the former case all the parameters are copied into Memory.",
            "Solution": "Whenever possible, prefer internal function calls, where the parameters are passed as references.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "105",
            "Name": "Fewer functions",
            "Paper": "20",
            "Context & Problem": "Implementing a function in an Ethereum SC costs gas.",
            "Solution": "In general, keep in mind that implementing a SC with many small functions is expensive. However, having too big functions complicates the testing and potentially compromises the security. So, try to have fewer functions, but not too few, balancing the function number with their complexity.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "106",
            "Name": "Use libraries",
            "Paper": "20",
            "Context & Problem": "If a SC tends to perform all its tasks by its own code, it will grow and be very expensive.",
            "Solution": "Use libraries. The bytecode of external libraries is not part of your SC, thus saving gas. However, calling them is costly and has security issues. Use libraries in a balanced way, for complex tasks.",
            "Drawbacks/Liabilities": "Lack of security, Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "107",
            "Name": "Short circuit",
            "Paper": "20",
            "Context & Problem": "Every single operation costs gas.",
            "Solution": "When using the logical operators, order the expressions to reduce the probability of evaluating the second expression. Remember that in the logical disjunction (OR, ||), if the first expression resolves to true, the second one will not be executed; or that in the logical disjunction (AND, &&), if the first expression is evaluated as false, the next one will not be evaluated.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "108",
            "Name": "Short constant strings",
            "Paper": "20",
            "Context & Problem": "Storing strings is costly.",
            "Solution": "Keep constant strings short. Be sure that constant strings fit 32 bytes. For example, it is possible to clarify an error using a string; these messages, however, are included in the bytecode, so they must be kept short to avoid wasting memory.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "109",
            "Name": "Limit modifiers",
            "Paper": "20",
            "Context & Problem": "The code of modifiers is inlined inside the modified function, thus adding up size and costing gas.",
            "Solution": "Limit the modifiers. Internal functions are not inlined, but called as separate functions. They are slightly more expensive at run time, but save a lot of redundant bytecode in deployment, if used more than once.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "110",
            "Name": "Avoid redundant operations",
            "Paper": "20",
            "Context & Problem": "Every single operation costs gas.",
            "Solution": "Avoid redundant operations. For instance, avoid double checks; the use of SafeMath library prevents underflow and overflow, so there is no need to check for them.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "111",
            "Name": "Single-line swap",
            "Paper": "20",
            "Context & Problem": "Each assignment and defining variables costs gas.",
            "Solution": "Solidity allows to swap the values of two variables in one instruction. So, instead of the classical swap using an auxiliary variable, use: (a, b) = (b, a)",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "112",
            "Name": "Write values",
            "Paper": "20",
            "Context & Problem": "Every single operation costs gas.",
            "Solution": "Write values instead of computing them. If you already know the value of some data at compile time, write directly these values. Do not use Solidity functions to derive the value of the data during their initialization. Doing so, might lead to a less clear code, but it saves gas.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "113",
            "Name": "Freeing storage",
            "Paper": "20",
            "Context & Problem": "Sometimes, Storage variables are not longer used. Is there a way to take advantage of this?",
            "Solution": "To help keeping the size of the blockchain smaller, you get a gas refund every time you free the Storage. Therefore, it is convenient to delete the variables on the Storage, using the keyword delete, as soon as they are no longer necessary.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "114",
            "Name": "Optimizer",
            "Paper": "20",
            "Context & Problem": "Optimizing Solidity code to save gas in exhaustive way is difficult.",
            "Solution": "Always turn on the Solidity Optimizer. It is an option of all Solidity compilers, which performs all the optimizations that can be made by the compiler. However, it does not substitute the usage of the presented patterns, most of which need information that is not available to the compiler.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "115",
            "Name": "Confidential and pseudo-anonymous contract enforcement",
            "Paper": "23",
            "Context & Problem": "During past years, the different industries have been impacted by new and disruptive technologies. One of such technologies is smart contracts. One objective of the smart contracts is to translate legal contracts as code or help the legal contract by augmenting some of its clauses into machine-readable functions. The emergence of blockchain technologies has led to the creation of blockchain-based smart contracts, that has benefited from blockchain characteristics. When stored on-chain, data becomes tamper-resistant. Additionally, the utilization of smart contracts isn’t always possible for stakeholders due to concerns about the irreversibility of smart contracts in certain blockchain technologies. For example, creating GDPR compliant blockchains for storing personal data systems is still an open topic. Although not all smart contracts might deal with personal data, there are concerns over the leakage of organizations’ confidential data or their identities, even if data are encrypted. ",
            "Solution": "This pattern allows the execution of automatable legal contract clauses, where its execution states are stored in an on-chain smart-contract and the logic needed to enforce it wraps it off-chain. An engine completes this pattern by running a business process that corresponds to the legal contract.",
            "Benefits": "Pseudonymity, Traceability, Confidentiality",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "BPM pattern",
            "Variant of": "54",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "BPM"
        },
        {
            "ID": "116",
            "Name": "Self-Generated Transactions",
            "Paper": "24",
            "Solution": "For directly interacting with an EDCC (Executable Distributed Code Contract) it is necessarythat the interface description (Application Binary Interface, ABI) of the EDCC is publicly available. Furthermore, for understanding the specific actions carried out by a contract, the source code should be published as well. DApps structured with this pattern have the security advantage that the users keep their private keys on their device and are able to generate, sign and send transactions on their own.",
            "Application examples": "• EtherDelta. Etherdelta. (Accessed 2018-03-15). [Online]. Available: https://etherdelta.com• Aurora Labs S.A. Idex – decentralized ethereum asset exchange. (Accessed 2018-03-15). [Online]. Available: https://idex.market• Ethorse. (Accessed 2018-03-15). [Online]. Available: https://ethorse.com",
            "Benefits": "Security",
            "Drawbacks/Liabilities": "Low user experience, Technical knowledge required",
            "Type (from paper)": "Architectural pattern",
            "Type (determined)": "Architectural pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "117",
            "Name": "Self-Confirmed Transactions",
            "Paper": "24",
            "Context & Problem": "Manually generating transactions can be hard or is not always feasible, especially when it is necessary to query the current state of the blockchain or to gather additional data, e.g., like the marketplace of CryptoKitties. This requires a certain trust in the DApp provider as transactions are generated but the implication of their execution is not always completely transparent (e.g., the geneScience contract of CryptoKitties without published source code or ABI).",
            "Solution": "Transactions are not generated by the user but are triggered by the DApp website, presented to the user for further verification and then manually sent to the blockchain node. Thus, this pattern offers a trade-off between convenience and trust that is required in the DApp website providing the transaction details.",
            "Application examples": "• AxiomZen. Cryptokitties. (Accessed 2018-03-15). [Online]. Available: https://www.cryptokitties.co",
            "Benefits": "Ease of use, Convenience",
            "Drawbacks/Liabilities": "Technical knowledge required",
            "Type (from paper)": "Architectural pattern",
            "Type (determined)": "Architectural pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "118",
            "Name": "Delegated Transactions",
            "Paper": "24",
            "Solution": "DApp provider offers a website the users can interact with, not requiring a cryptobrowser or MetaMask plugin. The website communicates with the DApp backend logic via REST calls and encapsulates all blockchain-specific actions. This means the backend is responsible for interacting with the blockchain and is sending transactions on behalf of the user, who is not able to validate them.",
            "Benefits": "Ease of use, Convenience",
            "Drawbacks/Liabilities": "No control on keys",
            "Type (from paper)": "Architectural pattern",
            "Type (determined)": "Architectural pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "119",
            "Name": "Mirror",
            "Paper": "25",
            "Context & Problem": "Many current and proposed applications of blockchain technology aim to address recordkeeping challenges, such as more efficient and secure processing of land title transfers, greater patient control over their sensitive health information, and more efficient recording of financial payments and settlements. All of the blockchain systems offer a new form of records generation use, storage and/or control.",
            "Solution": "The “mirror” system, the blockchain serves as a repository of “digital fingerprints”, or hashes, of the records. The original records, which may be born paper or digital, but now exist in digital form, are hashed. This produces a sort of digital fingerprint of the record. These hashes are anchored into the blockchain, with the blockchain being used as a mirror of the records, reflecting back their hashes.",
            "Application examples": "• Government of Estonia e-health solution",
            "Benefits": "Data integrity",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "120",
            "Name": "Digital Record",
            "Paper": "25",
            "Context & Problem": "Many current and proposed applications of blockchain technology aim to address recordkeeping challenges, such as more efficient and secure processing of land title transfers, greater patient control over their sensitive health information, and more efficient recording of financial payments and settlements. All of the blockchain systems offer a new form of records generation use, storage and/or control.",
            "Solution": "Records are no longer just mirrored on chain, they are actively created on chain in the form of “smart contracts”. This marks a more fundamental departure from the traditional form of digital records creation and storage in centralized databases or cloud-based platforms. Typically, these smart contracts encode procedures that execute among a multi-stakeholder network as part of a work process flow. In these “digital records” systems, execution of the smart code results in an update to the distributed database of records, or ledger, implementing state change once the smart contract has completed.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "121",
            "Name": "Tokenized",
            "Paper": "25",
            "Context & Problem": "Many current and proposed applications of blockchain technology aim to address recordkeeping challenges, such as more efficient and secure processing of land title transfers, greater patient control over their sensitive health information, and more efficient recording of financial payments and settlements. All of the blockchain systems offer a new form of records generation use, storage and/or control.",
            "Solution": "With this type of system, not only are records captured on chain, but assets are represented and captured on chain. These assets can represent anything of value – currency, as in the original use case for the blockchain – Bitcoin land, fine wine, food, diamonds, artworks, etc. Readers may ask whether these assets are records. ",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Tokenization patterns",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "122",
            "Name": "Pull payment",
            "Paper": "27",
            "Context & Problem": "A common task when coding smart contracts is to transfer funds. Unfortunately, there are several circumstances under which a transfer can fail. This is due to the fact that the implementation to send funds involves an external call, which basically hands over control to the called contract. Therefore, security considerations regarding external calls and re-entrancy attacks have to be considered. A re-entrancy attack describes the scenario where the called contract calls back the current contract, before the first invocation of the function containing the call, was finished. This can lead to an unwanted execution behaviour of functions.",
            "Solution": "Due to the possibility of deliberately sabotaging the transferof funds by executing expensive operations in the fallback method, causing an “out of gas” (OOG) error, or manipulations involving re-entrancy attacks, a more favourable approach is to reverse the payment process (let users withdraw their funds themselves).",
            "Application examples": "• Cryptopunks",
            "Benefits": "Re-entrancy protection",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "123",
            "Name": "State machine",
            "Paper": "27",
            "Context & Problem": "A state machine models the behaviour of a system based on its history and current inputs. Developers use this construct to break complex problems into simple states and state transitions. These are then used to represent and control the execution flow of a program.",
            "Solution": "State machines can also be applied in smart contracts. Many usage scenarios require a contract to have different behavioural stages, in which different functions can be called. When interacting with such a contract, a function call might end the current stage and initiate a change into a consecutive stage.",
            "Application examples": "• DutchAuction",
            "Benefits": "Easier to code",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "124",
            "Name": "Commit and reveal",
            "Paper": "27",
            "Context & Problem": "A characteristic of blockchains is, that it is not possible to restrict anyone from reading contents of a transaction or transaction’s state. This transparency leads to problems, especially when contract participants compete with each other. All data and every transaction is publicly visible on the blockchain, but an application scenario requires that contract interactions, specifically submitted parameter values, are treated confidentially.",
            "Solution": "Apply a commitment scheme to ensure that a value submission is binding and concealed until a consolidation phase runs out, after which the value is revealed, and it is publicly verifiable that the value remained unchanged.",
            "Application examples": "• ENS Registrar",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Encryption pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "125",
            "Name": "Oracle (Data Provider)",
            "Paper": "27",
            "Context & Problem": "Ethereum contracts run within their own ecosystem, where they communicate with each other, but external data can only enter the system through outside interaction via a transaction (by passing data to a method). This is a drawback, because many contract use cases depend on external knowledge outside the blockchain (e.g. price feeds). ",
            "Solution": "A solution to this problem is to utilize oracles with a connection to the outside world. The oracle service acts as a data carrier, where the interaction between an oracle service and a smart contract is asynchronous. First, a transaction invokes a function of a smart contract that contains an instruction to send a request to an oracle. Then, according to the parameters of such a request, the oracle will fetch a result and return it by executing a callback function placed in the primary contract.",
            "Application examples": "• Etheroll",
            "Drawbacks/Liabilities": "Centralization",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "126",
            "Name": "Ownership",
            "Paper": "27",
            "Context & Problem": "By default any party can call a contract method, but it must be ensured that sensitive contract methods can only be executed by the owner of a contract.",
            "Solution": "Store the contract creator’s address as owner of a contract and restrict method execution dependent on the callers address.",
            "Application examples": "• Ethereum Lottery",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "127",
            "Name": "Access Restriction",
            "Paper": "27",
            "Context & Problem": "By default a contract method is executed without any preconditions being checked, but it is desired that the execution is only allowed if certain requirements are met.",
            "Solution": "Since there is no built in mechanism to control executionprivileges, a common pattern is to restrict function execution. It is often required that functions should only be executed based on the presence of certain prerequisites. These can refer to different categories, such as temporal conditions, caller and transaction info, or other requirements that need to be checked prior a function execution. Listing",
            "Application examples": "• Etheroll",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "128",
            "Name": "Mortal",
            "Paper": "27",
            "Context & Problem": "A contract is defined by its creator, but the execution, and subsequently the services it offers are provided by the Ethereum network itself. Thus, a contract will exist and be executable as long as the whole network exists, and will only disappear if it was programmed to self destruct.",
            "Solution": "Use a selfdestruct call within a method that does a preliminary authorization check of the invoking party.",
            "Application examples": "• GTA Token",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "129",
            "Name": "Automatic Deprecation",
            "Paper": "27",
            "Context & Problem": "A usage scenario requires a temporal constraint defining a point in time when functions become deprecated.",
            "Solution": "Define an expiration time and apply modifiers in function definitions to disable function execution if the expiration date has been reached.",
            "Application examples": "• Polkadot",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "130",
            "Name": "Data Segregation",
            "Paper": "27",
            "Context & Problem": "Contract data and its logic are usually kept in the same contract, leading to a closely entangled coupling. Once a contract is replaced by a newer version, the former contract data must be migrated to the new contract version.",
            "Solution": "The data segregation pattern separates contract logic from its underlying data. Segregation promotes the separation of concerns and mimics a layered design (e.g. logic layer, data layer). Following this principle avoids costly data migrations when code functionality changes. Meaning a new contract version would not have to recreate all of the existing data contained in the previous contract.",
            "Application examples": "• SAN Token",
            "Benefits": "Cost saving when upgrading",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Based on non-blockchain pattern": "Layered design",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "131",
            "Name": "Satellite",
            "Paper": "27",
            "Context & Problem": "Contracts are immutable. Changing contract functionality requires the deployment of a new contract.",
            "Solution": "The satellite pattern allows to modify and replace contract functionality. This is achieved through the creation of separate satellite contracts that encapsulate certain contract functionality. The addresses of these satellite contracts are stored in a base contract. This contract can then can call out to the satellite contracts when it needs to reference certain functionalities, by using the stored address pointers. If this pattern is properly implemented, modifying functionality is as simple as creating new satellite contracts and changing the corresponding satellite addresses.",
            "Application examples": "• LATP Token",
            "Benefits": "Modifiability of contracts",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "132",
            "Name": "Contract register",
            "Paper": "27",
            "Context & Problem": "Contract participants must be referred to the latest contract version.",
            "Solution": "The register pattern is an approach to handle the update process of a contract. The pattern keeps track of different versions (addresses) of a contract and points on request to the latest one. In conclusion, before interacting with a contract, a user would always have to query the register for the contract’s latest address. When following this update approach, it is also important to determine how to handle existing contract data, when an old contract version is replaced. An alternative solution to point to the latest contract address would be to utilize the Ethereum Name Service (ENS). It is a register that enables a secure and decentralised way to resolve human-readable names, like ’mycontract.eth’, into machine-readable identifiers, including Ethereum addresses.",
            "Application examples": "• Tether Token",
            "Benefits": "Upgradeability of contracts",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "133",
            "Name": "Contract Relay",
            "Paper": "27",
            "Context & Problem": "Contract participants must be referred to the latest contract version.",
            "Solution": "A relay is another approach to handle the update process of a contract. The relay pattern provides a method to update a contract to a newer version while keeping the old contract address. This is achieved by using a kind of proxy contract that forwards calls and data to the latest version of the contract.",
            "Application examples": "• Numeraire",
            "Benefits": "Upgradeability of contracts",
            "Drawbacks/Liabilities": "Consistency of data at risk, No result returned",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "134",
            "Name": "Multiple Blockchains",
            "Paper": "31",
            "Solution": "For each product a separate Blockchain is set up between the respective supply chain organizations. All product data is stored in the Blockchain and shared between the participating organizations. No competitor can access any data by himself. This architecture comes with the properties of a standard permissioned Blockchain system with the additional effort of setting up separate Blockchain systems per product.",
            "Application examples": "• Proposed approach (from the same paper)",
            "Benefits": "Data confidentiality",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Architectural pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "135",
            "Name": "On-chain encryption",
            "Paper": "31",
            "Solution": "All data in the Blockchain-based system is symmetrically encrypted on-chain on a single permissioned Blockchain to preserve data privacy. Every event or asset is encrypted with a separate cryptographic key, which is stored off-chain in a distributed and decentralized database with all organizations that are part of the supply chain of a product. Only these organizations have access to the keys and therefore can decrypt or encrypt the corresponding data. ",
            "Application examples": "• PoC (from the same paper)• Proposed approach (from the same paper)",
            "Benefits": "Data confidentiality",
            "Drawbacks/Liabilities": "Compromized key vulnerable, Impossibility to revoke access",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Encryption pattern",
            "From pattern": "55",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "136",
            "Name": "Hash timestamping",
            "Paper": "31",
            "Solution": "A Blockchain connects all members of different supply chains. For each product a distributed and decentralized off-chain database is created which contains all relevant product information. Each data point is linked in the Blockchain with it’s hash value. This ensures that the organizations in possession of the data can confirm that it is not tampered. ",
            "Application examples": "• Proposed approach (from the same paper)",
            "Benefits": "Data integrity",
            "Drawbacks/Liabilities": "Worthless if data deleted/changed",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "137",
            "Name": "Pull payment",
            "Paper": "32",
            "Solution": "As a send operation can fail, let the receiver withdraw the payment.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "From pattern": "122",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "138",
            "Name": "State machine",
            "Paper": "32",
            "Solution": "When different contract stages are needed, these are modeled and represented by a state machine.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory (optional)": "Multi-domain feature pattern",
            "From pattern": "123",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "139",
            "Name": "Commit and reveal",
            "Paper": "32",
            "Solution": "As blockchain data is public, a commitment scheme ensures confidentiality of contract interactions.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Encryption pattern",
            "From pattern": "124",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "140",
            "Name": "Oracle (Data Provider)",
            "Paper": "32",
            "Solution": "When knowledge outside the blockchain is required, an oracle pushes information into the network.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "From pattern": "125",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "141",
            "Name": "Ownership",
            "Paper": "32",
            "Solution": "As anyone can call a contract method, restrict the execution to the contract owner’s address.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "126",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "142",
            "Name": "Access Restriction",
            "Paper": "32",
            "Solution": "When function execution checkups are needed, these are handled by generally applicable modifiers",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "127",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "143",
            "Name": "Mortal",
            "Paper": "32",
            "Solution": "Since deployed contracts do not expire, self-destruction with a preliminary authorization check is used.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "From pattern": "128",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "144",
            "Name": "Automatic Deprecation",
            "Paper": "32",
            "Solution": "When functions shall become deprecated, apply function modifiers to disable their future execution.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "129",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "145",
            "Name": "Data Segregation",
            "Paper": "32",
            "Solution": "As data and logic usually reside in the same contract, avoid data migration on updates by decoupling.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "130",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "146",
            "Name": "Satellite",
            "Paper": "32",
            "Solution": "As contracts are immutable, functions that are likely to change are outsourced into separate contracts.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "131",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "147",
            "Name": "Contract register",
            "Paper": "32",
            "Solution": "When the latest contract version is unknown, participants pro-actively query a register.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "132",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "148",
            "Name": "Contract Relay",
            "Paper": "32",
            "Solution": "When the latest contract version is unknown, participants interact with a proxy contract.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "133",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "149",
            "Name": "Checks-Effects-Interaction",
            "Paper": "32",
            "Solution": "As calls to other contracts hand over control, avoid security issues by a functional code order.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "187",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "150",
            "Name": "Emergency Stop",
            "Paper": "32",
            "Solution": "Since contracts are executed autonomously, sensitive functions include a halt in the case of bugs.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "188",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "151",
            "Name": "Speed Bump",
            "Paper": "32",
            "Solution": "When task execution by a huge number of users is unwanted, prolong completion for counter measures.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "189",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "152",
            "Name": "Rate Limit",
            "Paper": "32",
            "Solution": "When a request rush on a task is not desired, regulate how often a task can be executed within a period.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "190",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "153",
            "Name": "Mutex",
            "Paper": "32",
            "Solution": "As re-entrancy attacks can manipulate contract state, a mutex hinders external calls from re-entering.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "191",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "154",
            "Name": "Balance Limit",
            "Paper": "32",
            "Solution": "There is always a risk that a contract gets compromised, thus limit the maximum amount of funds held.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "192",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "155",
            "Name": "On-chain and off-chain",
            "Paper": "28",
            "Solution": "To address the issues of blockchain storage capability limitation and data privacy, an on-chain and off-chain service is proposed to store the critical data which is required to be immutable on-chain while keep all the data off-chain to enhance the data reading efficiency.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "156",
            "Name": "Data Encryption",
            "Paper": "28",
            "Solution": "To preserve the privacy of the involved participants, we provide a data encryption service that encrypts on-chain data to ensure confidentiality of the data stored on blockchain. Users first encrypt the data item using the secret key and then store it on blockchain. The blockchain participants who have the secret key are allowed to access the transaction and decrypt the information.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Encryption pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "157",
            "Name": "Hash integrity",
            "Paper": "28",
            "Solution": "The hash integrity service focuses on how to use blockchain to ensure the integrity of large amounts of data. Hashing is applied to guarantee the integrity of arbitrarily large datasets which may not fit directly on the blockchain. The servicestores the hash of the raw data on blockchain to achieve data integrity of the raw data for the participants of the blockchain network that lack trust for each other. The integrity of the raw data can be checked using the on-chain hash value.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "158",
            "Name": "Multiple Authorities",
            "Paper": "28",
            "Solution": "The multiple authorities service focuses on activities in blockchain-based applications (i.e. transactions) that need to be authorised by multiple blockchain addresses. Users can predefine a group of blockchain addresses which can authorise a transaction (i.e. calling a function in the smart contract) and set the minimal number of authorisations for transaction approval.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "159",
            "Name": "Dynamic Binding",
            "Paper": "28",
            "Context & Problem": "In blockchain applications, some activities need to be approved by one or more participants who are unknown when a first transaction is submitted to blockchain. The authority who can authorise to a given activity is unknown when the corresponding smart contract is deployed, or the corresponding transaction is submitted to the blockchain.",
            "Solution": "The dynamic binding service supports dynamic association with an address of a participant which is not defined in the respective transaction or smart contract. An off-chain secret is used to enable a dynamic authorisa-tion when the participant approving a transaction is unknown beforehand. Users need to provide an off-chain secret and select the corresponding function in the smart contract. The service modifies the function code by adding hash secret code and generates the updated smart contract. There is no need for a special protocol to exchange the secret. The secret can be exchanged in any ways off-chain.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "160",
            "Name": "Embedded permission",
            "Paper": "28",
            "Context & Problem": "All the smart contracts running on blockchain can be accessed and called by all the participants and other smart contracts by default. A smart contract by default has no owner, which means that the author of the smart contract has no special privilege on the smart contract once the smart contract is deployed.",
            "Solution": "The embedded permission service restricts access to the invocation of the functions defined in the smart contracts. Users can identify the authorities for the selected function in the smart contract by providing the authority addresses. The service adds permission control code to the smart contract function to check permission for every caller based on the blockchain address of the caller, which is done before executing the function logic.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "161",
            "Name": "Check Effect Interaction",
            "Paper": "33",
            "Solution": "When performing a function in a SC: first, check all the preconditions, then apply the effects to the contract's state, and finally interact with other contracts. Never alter this sequence.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "From pattern": "187",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "162",
            "Name": "Proxy Delegate / Decorator",
            "Paper": "33",
            "Solution": "Proxy patterns are a set of SCs working together to facilitate upgrading of SCs, despite their intrinsic immutability. A Proxy is used to refer to another SC, whose address can be changed. This approach also ensures that blockchain resources are used sparingly, thus saving GAS.",
            "Benefits": "Cost saving",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "[36], [13], 185, 209, 91",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "163",
            "Name": "Authorization",
            "Paper": "33",
            "Context & Problem": "Since SCs are publicly accessible to all blockchain participants, it is critical to restrict authorizations to perform specific tasks. Specifically, for each contract method, developers must specify the subset of participants who can call it. Contracts usually define at least one contract owner, which is the only entity authorised to call critical methods.",
            "Solution": "Restrict the execution of critical methods to specific users. This is accomplished using mappings of addresses, and is typically checked using modifiers.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "25",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "164",
            "Name": "Ownership",
            "Paper": "33",
            "Solution": "Specify the contract owner, which is responsible for contract management and has special permissions, e.g. it is the only address authorized to call critical methods. This patter can be seen as a special instance of the authorization pattern.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Variant of": "25",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "165",
            "Name": "Oracle",
            "Paper": "33",
            "Context & Problem": "A smart contract is by nature isolated, and cannot acquire information directly. This is due to the fact that network nodes must agree on the state of transactions. To accomplish this, nodes should evaluate only static data. On the contrary, the outside world, for instance a website API, could provide different responses to the same query performed by different network nodes, breaking blockchain consensus.",
            "Solution": "An oracle is a SC providing data from outside the blockchain, which are in turn fed to the oracle by a trusted source. Here the security risk lies in how actually the source can be trusted.",
            "Drawbacks/Liabilities": "Lack of trustability",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "From pattern": "26, 52",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "166",
            "Name": "Reverse Oracle",
            "Paper": "33",
            "Solution": "A reverse oracle is a SC providing data to be read by off-chain components for checking specific conditions.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "From pattern": "53",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "167",
            "Name": "Rate Limit",
            "Paper": "33",
            "Solution": "Regulate how often a task can be executed within a period of time, to limit the number of messages sent to a SC, and thus its computational load.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "190",
            "Benefits from": "170",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "168",
            "Name": "Balance Limit",
            "Paper": "33",
            "Solution": "Limit the maximum amount of funds held within a SC.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "192",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "169",
            "Name": "Guard Check",
            "Paper": "33",
            "Solution": "Ensure that all requirements on a SC state and on function inputs are met.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "[13]",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "170",
            "Name": "Time Constraint",
            "Paper": "33",
            "Context & Problem": "Different blockchain nodes could process transactions at different timestamps, due to network latency or further causes. Consequently, part of the network could consider an action as executed beyond the time constraint, and the corresponding transaction could be rejected by the whole network.",
            "Solution": "A time constraint specifies when an action is permitted, depending on the time registered in the block holding the transaction. It could be also used in Speed Bump and Rate Limit patterns.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "29",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "171",
            "Name": "Termination",
            "Paper": "33",
            "Solution": "Used when the life of a SC has come to an end. This can be done by inserting ad-hoc code in the contract, or calling the selfdestruct function. Usually, only the contract owner is authorized to terminate a contract.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "30",
            "Benefits from": "164",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "172",
            "Name": "Math",
            "Paper": "33",
            "Solution": "A logic which computes some critical operations, protecting from overflows, underflows or other undesired characteristics of finite arithmetic.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "31",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "173",
            "Name": "Privacy",
            "Paper": "33",
            "Solution": "Encrypt on-chain critical data improving confidentiality and meeting legal requirements, such as the European GDPR.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "55",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "174",
            "Name": "Reusability",
            "Paper": "33",
            "Solution": "Use contract libraries and templates as a factory for creating multiple instances.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "65",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "175",
            "Name": "Mutex",
            "Paper": "33",
            "Solution": "A mutex is a mechanism to restrict concurrent access to a resource. Utilize it to hinder an external call from re-entering its caller function again.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "191",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "176",
            "Name": "Speed Bump",
            "Paper": "33",
            "Solution": "Slow down contract sensitive tasks, so when malicious actions occur, the damage is limited and more time to counteract is available. For instance, limit the amount of money a user can withdraw per day, or impose a delay before withdrawals.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "From pattern": "189",
            "Benefits from": "170",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "177",
            "Name": "Publisher-Subscriber",
            "Paper": "33",
            "Context & Problem": "When a module needs to receive some messages from other software modules (e.g. a smart contract), developers should implement a messaging infrastructure that allows each module to be easily notified when a new message is generated.",
            "Solution": "When a state change must trigger a computation in a different object, implement a messaging infrastructure where the contracts that produce messages (called publishers) can generate messages and the other contracts (called subscribers) receive them. The pattern, also known as Observer, reduces the overhead of constant information filtering.",
            "Benefits": "Overhead reduction",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "From pattern": "186",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "178",
            "Name": "Tokenisation",
            "Paper": "33",
            "Context & Problem": "The Ethereum ecosystem provides standards to handle several types of tokens, such as the ERC20 and ERC721.",
            "Solution": "Use tokens for transferring digital or physical services. Use standards, such as ERC20 and ERC721.",
            "Benefits": "Standardization",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory (optional)": "Tokenization patterns",
            "From pattern": "56",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "179",
            "Name": "X-confirmation",
            "Paper": "33",
            "Solution": "In order to ensure that a transaction is confirmed (i.e. there is a low probability that a fork happens), wait for new blocks to be added to the blockchain. The amount of blocks depends on the adopted blockchain.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Transactions pattern",
            "From pattern": "61",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "180",
            "Name": "Contract Registry",
            "Paper": "33",
            "Solution": "Often a smart contract needs to interact with other contracts which can be updated over time. A contract registry maps each smart contract to the address of its latest version. Accordingly, when invoking a smart contract, the correct address should be retrieved from the registry.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "62",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "181",
            "Name": "Eternal storage / Data Contract",
            "Paper": "33",
            "Solution": "Contract data and logic should be stored into separate contracts. In this way, when the logic need to be updated (by using a new smart contract), there is no need to migrate old data.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "64",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "182",
            "Name": "Abstract factory",
            "Paper": "33",
            "Solution": "Sometimes, systems need to work with groups of related contracts, for instance with contracts which represent various level user account. In order to keep the system independent from the different contracts, define an abstract contract for creating all the related contracts.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "From pattern": "183, 206, 65",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "183",
            "Name": "Abstract factory",
            "Paper": "34",
            "Context & Problem": "Smart contracts allow code to be executed on the blockchain by the EVM. The incorruptibility property of blockchain ensures that interfaces (e.g. methods and properties) of already instantiated contracts cannot be modified or upgraded. Each new version of a smart contract has to be created as a new contract object on the blockchain and distributed among all the network nodes to be executed on demand. Therefore, it is important to design a contract class to modularize code and minimize changes to its interface over time.",
            "Solution": "The Abstract Factory pattern can facilitate this scenario because its \"factory\" object (the factory itself is a contract instance) is then responsible for providing creation services of concrete departmental contracts for the entire health organization. Each factory object can create contracts for a group of departments or subdivisions that are related or always interact, and it is easy to instantiate another factory object when new interactions take place.",
            "Application examples": "• PoC (from the same paper)• Proposed approach (from the same paper)",
            "Benefits": "Interoperability between contracts",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Based on non-blockchain pattern": "Abstract factory",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Healthcare"
        },
        {
            "ID": "184",
            "Name": "Flyweight",
            "Paper": "34",
            "Context & Problem": "In order to achieve blockchain’s transparency and immutability properties, all of the data and transaction records are maintained in the blockchain by replicating and distributing to every node in the network. It is important to limit the amount of data stored in the blockchain to avoid high cost of data storage and unattended data when it is no longer needed.",
            "Solution": "In order to achieve blockchain’s transparency and immutability properties, all of the data andtransaction records are maintained in the blockchain by replicating and distributing to every node in the network. It is important to limit the amount of data stored in the blockchain to avoid high cost of data storage and unattended data when it is no longer needed.",
            "Application examples": "• DASH (from the same paper)",
            "Benefits": "Code and contract reuse, Easier contract management",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Based on non-blockchain pattern": "Flyweight",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Healthcare"
        },
        {
            "ID": "185",
            "Name": "Proxy",
            "Paper": "34",
            "Context & Problem": "A fundamental aspect of a blockchain is that all data stored in the blockchain is public, immutable, and verifiable. For financial transactions that are focused on proving that transfer of an asset occurred, these properties are critical. However, when the goal is to store data in the blockchain, it is important to understand how these properties will impact the use case.",
            "Solution": "The Proxy pattern is a well-known software pattern that can be applied to blockchain-based data storage toresolve the tension created by the public and immutable aspects of the blockchain. Using the proxy pattern with a blockchain, a proxy contract is created to provide some lightweight representation or placeholder for the data with more intensive computation (such as acquiring data from off-blockchain storage via an Oracle. The proxy contract can expose some simpler metadata of a patient and later refer to the heavyweight implementation on demand to obtain the real data object. Each read request and modification operation of the data store can be logged in an audit trail that is transparent to the entire blockchain network for verification against data corruption. When the proxified contract (with heavyweight implementation) is updated with new storage option, for instance, interface to the proxy contract can remain the same, encapsulating detailed implementation variations.",
            "Application examples": "• DASH (from the same paper)",
            "Benefits": "Less code complexity, Data privacy",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Benefits from": "Audit Trail",
            "Based on non-blockchain pattern": "Proxy",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Healthcare"
        },
        {
            "ID": "186",
            "Name": "Publisher-Subscriber",
            "Paper": "34",
            "Context & Problem": "The Ethereum blockchain maintains a public record of contract creations and operation executions along with regular cryptocurrency transactions. The availability of information makes blockchain a more autonomous approach to improve the coordination of patient care across different teams (e.g. physicians, pharmacists, insurance agents, etc) who would normally communicate through various channels with a lot of manual effort, such as through telephoning or faxing. Although, from a continually growing list of records, directly capturing any specific health-related topic of occurred events would require a lot of transaction receipt lookups and topic filtering, which requires non-trivial computation and may result in delayed responses.",
            "Solution": "The Publisher-Subscriber pattern can assist in broadcasting the information only to care providers that subscribe to events relating to this patient. It solves the issue of constant information filtering by actively monitoring patient activities and sending notifications to the patient’s care team as the activities take place. To avoid computation overhead on the blockchain, the actual processing of patient activities data can be done off-chain by a back-end server. When receiving the events of interest, the subscribers can then pass the heavy computation tasks to the server.",
            "Application examples": "• DASH (from the same paper)",
            "Drawbacks/Liabilities": "Notification latency, Cost expensive at computation",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Based on non-blockchain pattern": "Publisher-Subscriber",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Healthcare"
        },
        {
            "ID": "187",
            "Name": "Checks-Effects-Interaction",
            "Paper": "35",
            "Solution": "Follow a recommended functional code order, in which calls to external contracts are always the last step, to reduce the attack surface of a contract being manipulated by its own externally called contracts.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "188",
            "Name": "Emergency Stop",
            "Paper": "35",
            "Solution": "Incorporate an emergency stop functionality into the contract that can be triggered by an authenticated party to disable sensitive functions.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "189",
            "Name": "Speed Bump",
            "Paper": "35",
            "Solution": "Prolong the completion of sensitive tasks to take steps against fraudulent activities. ",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "190",
            "Name": "Rate Limit",
            "Paper": "35",
            "Solution": "Regulate how often a task can be executed within a period of time.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "191",
            "Name": "Mutex",
            "Paper": "35",
            "Solution": "Utilize a mutex to hinder an external call from re-entering its caller function again. ",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "192",
            "Name": "Balance Limit",
            "Paper": "35",
            "Solution": "Limit the maximum amount of funds at risk held within a contract.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract security pattern",
            "Target": "Ethereum",
            "Language": "Solidity",
            "Applicability domain": "General"
        },
        {
            "ID": "193",
            "Name": "Challenge Response",
            "Paper": "36",
            "Solution": "Instead of checking whether a state is final or not in a smart contract on a blockchain, the same check is performed off-chain on the client side. A client can notify a smart contract when a final state has been reached. Other clients can prove claims wrong by providing a valid state transition. Using this pattern, the computation never has to be performed on-chain",
            "Benefits": "Cost saving at computation",
            "Drawbacks/Liabilities": "More transactions needed, Require availability of parties",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "194",
            "Name": "Off-chain Signatures",
            "Paper": "36",
            "Solution": "Together, the two participants specify a smart contract including a function, which applies an external state given as argument to the contract state. This function includes a signature check to ensure both participants agree with the state change. Only if valid signatures of both participants are supplied with a requested new state, the new state is applied. This contract is deployed to the blockchain and both participants optionally make a deposit. Then, the participants perform transactions purely off-chain and peer-topeer, without involving the blockchain: One participant computes a new state, wraps it in a transaction, signs it and sends it to his counterpart. The recipient then checks the new state, signs the transaction as well in case he agrees and sends it back to the sender. This transaction, signed by both parties, can now be sent to the smart contract by a participant at any point in time. After validating both signatures, the contract updates its state accordingly.",
            "Benefits": "Cost saving, Data privacy, Scalability",
            "Drawbacks/Liabilities": "Risk of freeze funds, Locked funds",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "195",
            "Name": "Content-Addressable Storage",
            "Paper": "36",
            "Solution": "Store the data off-chain in a content-addressable storage system and store the reference in the smart contract. Clients using the smart contract can retrieve the reference and based on that retrieve the data. Then, they can verify the data’s correctness by recomputing its address from itself and comparing it to the reference stored in the smart contract.",
            "Benefits": "Cost saving, Data privacy",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "196",
            "Name": "Delegated Computation",
            "Paper": "36",
            "Solution": "Outsource computation to an untrusted third party and, besides the result, generate a proof of correct execution. Instead of executing the computation itself, verify the proof of correct execution on-chain.",
            "Benefits": "Cost saving, Data privacy",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "197",
            "Name": "Low Contract Footprint",
            "Paper": "36",
            "Solution": "To optimize fees, contracts should be designed in a way that minimizes the number and size of on-chain transactions. The following two techniques can be used to reduce the footprint. – Do not check conditions on-chain after a state change. Let nodes perform the condition check locally and trigger an on-chain check in case of success. – Optimize for writes, not reads. Reading from a smart contracts is a local off-chain operation and does not require an on-chain transaction. Minimize writes and store information free of redundancy. Compute derived data locally during reads.",
            "Benefits": "Cost saving, Data privacy",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract efficiency pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "198",
            "Name": "Abstract factory",
            "Paper": "38",
            "Solution": "This pattern allows DApps like DASH to delegate the responsibility for providing account creation services to an abstract \"factory\" object (which is a contract instance itself). A concrete factory object can then inherit methods from the abstract factory and customize them to create accounts for a specific set of related or interacting sub-entities.",
            "Benefits": "Evolvability",
            "Drawbacks/Liabilities": "Cost expensive at storage",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Based on non-blockchain pattern": "Abstract factory",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Healthcare"
        },
        {
            "ID": "199",
            "Name": "Flyweight",
            "Paper": "38",
            "Solution": "Combining the FLYWEIGHT pattern with a factory object can help minimize data storage in the Blockchain. In particular, the factory can establish a registry model that stores shared data between a set of entities in a common contract, i.e., the registry, while externalizing varying data to be stored in entity-specific contracts. The registry can also maintain references (i.e., addresses) to entity-specific contracts and return a combined extrinsic and intrinsic (common) data set upon request. ",
            "Benefits": "Minimize on-chain data and redundancy, Cost saving",
            "Drawbacks/Liabilities": "Complexity",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Requires": "198",
            "Based on non-blockchain pattern": "Flyweight",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Healthcare"
        },
        {
            "ID": "200",
            "Name": "Proxy",
            "Paper": "38",
            "Solution": "Combining the PROXY pattern with a secure data retrieving service, such as an oracle, can enable secure and private data exchange services. The oracle network is a third-party service that allows a smart contract to query or retrieve data sources outside the Blockchain address space and ensures that retrieved data is genuine and uncompromised. To reduce computation overhead on-chain, a proxy can be created as a lightweight representation or placeholder for the real data until its retrieval is required.",
            "Benefits": "Data privacy",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Requires": "Oracle",
            "Based on non-blockchain pattern": "Proxy",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Healthcare"
        },
        {
            "ID": "201",
            "Name": "Publisher-Subscriber",
            "Paper": "38",
            "Solution": "Incorporating a notification service using the PUBLISHER-SUBSCRIBER pattern can facilitate scalable information filtering. In this design, health activities are only broadcast to providers who subscribe to events relating to their patients. It alleviates the tedious filtering process of determining which care provider should be notified about what patient activities as large volumes of transactions take place.",
            "Benefits": "Scalability, Interoperability, Flexibility",
            "Drawbacks/Liabilities": "Latency, Cost expensive at storage",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Based on non-blockchain pattern": "Publisher-Subscriber",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "Healthcare"
        },
        {
            "ID": "202",
            "Name": "Pull-based inbound oracle",
            "Paper": "39",
            "Solution": "A pull-based inbound oracle allows blockchain applications to request states from off-chain components. When a blockchain application requests an off-chain state, the pull-based inbound oracle receives this request, gathers the state from off-chain components, and sends the result back to the blockchain (via a transaction).",
            "Benefits": "Transparency, Traceability",
            "Drawbacks/Liabilities": "Latency",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "203",
            "Name": "Push-based inbound oracle",
            "Paper": "39",
            "Solution": "A push-based inbound oracle allows off-chain information to be propagated to the blockchain by monitoring off-chain state changes and forwarding them to the blockchain.",
            "Benefits": "Enhanced data verification",
            "Drawbacks/Liabilities": "Lack of trustability of components",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "204",
            "Name": "Pull-based outbound oracle",
            "Paper": "39",
            "Solution": "A pull-based outbound oracle allows blockchain data to be queried and filtered to make it available to the outside world. It can be called from (off-chain) components to pull (all) blockchain data and query relevant information",
            "Drawbacks/Liabilities": "Latency of data retrieval",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "205",
            "Name": "Push-based outbound oracle",
            "Paper": "39",
            "Solution": "A push-based outbound oracle monitors the blockchain for relevant changes to subsequently trigger or perform activities outside the blockchain.",
            "Drawbacks/Liabilities": "Needs to run continuously, Lack of resiliency",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target": "All blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "206",
            "Name": "Contract Factory",
            "Paper": "37",
            "Solution": "As the compiled code of a smart contract deployed on blockchain is not readable, it is tedious to deploy and manage smart contracts that have same properties but aim to diverse clients. With the help of this pattern, developers do not need to deploy the smart contracts one after another, but deploy a contract factory once, through which the required multiple instances can be instantiated.",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Related to": "207",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "207",
            "Name": "Contract Composer",
            "Paper": "37",
            "Solution": "In a blockchain-based application, the combination of services or objects is inevitable. Consequently, how to effectively control such a combination becomes a challenge to developers, especially under the condition that each service or object is represented in the form of smart contract. Compared with Contract Factory, Contract Composer focuses on the complex structure of a contract instance, as it can construct a complicated target through multiple small pieces.",
            "Benefits": "Flexibility",
            "Drawbacks/Liabilities": "Complex permission management, Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Related to": "206",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "208",
            "Name": "Contract Decorator",
            "Paper": "37",
            "Solution": "Once a smart contract is deployed on blockchain, it is not allowed to modify or update the source code of that contract. Contract Decorator pattern can avoid rewriting the whole contract when there are new requirements, developers just need to encapsulate the old contracts and append the required features into a new version of the contract through this pattern, to achieve updatability and modifiability.",
            "Benefits": "Updateability, Modifiability",
            "Drawbacks/Liabilities": "Complex permission management, Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Benefits from": "207, 208",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "209",
            "Name": "Contract Facade",
            "Paper": "37",
            "Solution": "Managing smart contracts may be a burdensome work as there are massive contracts having similar features in a blockchain-based system. Contract Facade pattern can relieve such pressure via providing a simple interface by coping with contract addresses. Such an interface is also in the form of smart contract, for developers to call the functions of similar contracts.",
            "Benefits": "Connectivity between contracts",
            "Drawbacks/Liabilities": "Complex permission management, Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Benefits from": "207, 208, 210, 211",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "210",
            "Name": "Contract Mediator",
            "Paper": "37",
            "Solution": "In a business process, smart contracts need to interact with each other to finish a certain activity, which may result in tight coupling of the contracts. Contract Mediator pattern aims to reduce the communication complexity of smart contracts, an instance of this pattern is in the form of smart contract, which collects and encapsulates the interactions and invocations from one contract to the others, to decoupling the smart contracts.",
            "Benefits": "Reduced complexity",
            "Drawbacks/Liabilities": "Complex permission management, Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "211",
            "Name": "Contract Observer",
            "Paper": "37",
            "Solution": "When a smart contract is modified due to the changing requirements in industry, all the related contracts need to be informed and updated automatically. Contract Observer pattern can deal with such problem to achieve interoperability and updatability among the contracts via an observer instance. An instance of Contract Observer needs to define the objects and information involved, once there are any changes, it should notify all the objects to update information.",
            "Drawbacks/Liabilities": "Complex permission management, Cost expensive",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract management pattern",
            "Benefits from": "208",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "212",
            "Name": "Hash Secret",
            "Paper": "37",
            "Solution": "This pattern can help a user to achieve authorisation of a particular activity to unknown authorities, by generating a digital secret key known as the hash secret. When the authority is decided, it will then receive the hash secret and thus have the ability to finish further task.",
            "Benefits": "Adaptability",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        },
        {
            "ID": "213",
            "Name": "Multi-signature",
            "Paper": "37",
            "Solution": "As there are multiple authorities in a blockchain network, this pattern can provide a flexible way to achieve better cooperation. A transaction is valid only when there are enough signatures from the authorities. In addition, this pattern can also be considered as an individual safeguard mechanism as the current blockchain technology does not provide a way to recover the lost private key.",
            "Benefits": "Adaptability",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory (optional)": "Contract access control pattern",
            "Target": "Smart-contract enabled blockchains",
            "Language": "Unspecified",
            "Applicability domain": "General"
        }
    ],
    "Canonical patterns": [
        {
            "ID": "2",
            "Name": "Transparent Event Log",
            "Paper": "2",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Storage pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "BPM"
        },
        {
            "ID": "3",
            "Name": "Blockchain BP Engine",
            "Paper": "2",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "BPM pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "BPM"
        },
        {
            "ID": "4",
            "Name": "Smart Contract Activities",
            "Paper": "2",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "BPM pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "BPM"
        },
        {
            "ID": "5",
            "Name": "Blockchain-based reputation system",
            "Paper": "2",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "BPM"
        },
        {
            "ID": "6",
            "Name": "Decentralize business process",
            "Paper": "2",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "BPM pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "BPM"
        },
        {
            "ID": "7",
            "Name": "Key-value store",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Storage pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "8",
            "Name": "Address mapping",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Storage pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "9",
            "Name": "Authorization",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract access control pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "10",
            "Name": "Judge",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract access control pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "11",
            "Name": "Ticker Tape",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "12",
            "Name": "Vote",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "14",
            "Name": "Blocklist",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "15",
            "Name": "Announcement",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "16",
            "Name": "Bulletin Board",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "18",
            "Name": "Migration",
            "Paper": "5",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "19",
            "Name": "Inter-family communication",
            "Paper": "6",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Target (generalized)": "Hyperledger Sawtooth",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "20",
            "Name": "Locking",
            "Paper": "7",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "21",
            "Name": "Transition Counter",
            "Paper": "7",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "22",
            "Name": "Automatic Timed Transitions",
            "Paper": "7",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "27",
            "Name": "Randomness",
            "Paper": "9",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "28",
            "Name": "Poll",
            "Paper": "9",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "32",
            "Name": "Fork check",
            "Paper": "9",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "34",
            "Name": "Secure Ether Transfer",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "35",
            "Name": "Oracle",
            "Alternative names": "Oracle (Data Provider)",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Introduced in (paper ID)": "11, 13, 27, 32, 33, 9",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "37",
            "Name": "State Channel",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Introduced in (paper ID)": "11, 13",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "38",
            "Name": "(Off-chain) Contract Registry",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "39",
            "Name": "Data Contract",
            "Alternative names": "Data Segregation, Eternal Storage / Data Contract",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Introduced in (paper ID)": "11, 13, 27, 32, 33",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "40",
            "Name": "Embedded Permission",
            "Alternative names": "Access Control, Authorization",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract access control pattern",
            "Introduced in (paper ID)": "7, 11, 13, 28, 33, 9",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "41",
            "Name": "Factory Contract",
            "Alternative names": "Reusability, Contract Factory, Abstract factory",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Introduced in (paper ID)": "11, 13, 38, 33, 34, 37",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "42",
            "Name": "Emergency Stop",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "11, 35, 32",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "43",
            "Name": "Mutex",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "11, 35, 32, 33",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "44",
            "Name": "Contract Balance Limit",
            "Alternative names": "Balance limit",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "11, 35, 32, 33",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "45",
            "Name": "Reverse Oracle",
            "Alternative names": "Reverse Verifier, Anti-Oracle",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Introduced in (paper ID)": "11, 13, 33, 5",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "46",
            "Name": "Incentive Execution",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Introduced in (paper ID)": "11, 13",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "47",
            "Name": "Commit and Reveal",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Encryption pattern",
            "Introduced in (paper ID)": "11, 27, 32",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "48",
            "Name": "Proxy Contract",
            "Alternative names": "Proxy, Proxy Delegate / Decorator, Contract Relay, Contract facade",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Introduced in (paper ID)": "11, 27, 32, 33, 34, 37, 20, 38",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "49",
            "Name": "Dynamic Binding",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract access control pattern",
            "Introduced in (paper ID)": "11, 28",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "50",
            "Name": "Flyweight",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Introduced in (paper ID)": "11, 38, 34",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "51",
            "Name": "Tight Variable Packing",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "54",
            "Name": "Legal and smart-contract pair",
            "Paper": "11",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "57",
            "Name": "Off-chain data storage",
            "Alternative names": "Hash storage, Off-chain Datastore, Hash integrity, Mirror, Content-Addressable Storage, Anchoring to Blockchain, On-chain and off-chain",
            "Paper": "13",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Introduced in (paper ID)": "2, 11, 13, 14, 25, 28, 36",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "59",
            "Name": "Multiple authorization",
            "Alternative names": "Multiple Authorities, Multi-signature",
            "Paper": "13",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract access control pattern",
            "Introduced in (paper ID)": "13, 28, 37",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "60",
            "Name": "Off-chain secret enabled dynamic authentication",
            "Paper": "13",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract access control pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "67",
            "Name": "Master & Sub Key",
            "Paper": "13",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Wallet and keys pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "68",
            "Name": "Hot & Cold Wallet Storage",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Wallet and keys pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "69",
            "Name": "Key Sharding",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Wallet and keys pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "70",
            "Name": "Identifier Registry",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Decentralized identity pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "71",
            "Name": "Multiple Registration",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Decentralized identity pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "72",
            "Name": "Bound with Social Media",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Decentralized identity pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "73",
            "Name": "Dual Resolution",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Decentralized identity pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "74",
            "Name": "Delegate List",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Decentralized identity pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "75",
            "Name": "Selective Content Generation",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "76",
            "Name": "Time-Constrained Access",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "77",
            "Name": "One-Off Access",
            "Paper": "14",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Identity management"
        },
        {
            "ID": "79",
            "Name": "Snapshotting",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "80",
            "Name": "State Aggregation",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "81",
            "Name": "Token burning",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "82",
            "Name": "Node Sync",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "83",
            "Name": "Establish Genesis",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "84",
            "Name": "Hard Fork",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "85",
            "Name": "State Initialization",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "86",
            "Name": "Exchange Transfer",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "87",
            "Name": "Transaction Replay",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "88",
            "Name": "Virtual Machine Emulation",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "89",
            "Name": "Smart Contract Translation",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Migration pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "90",
            "Name": "Blockchain Security Pattern for Big Data Ecosystems",
            "Paper": "15",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Big data pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "Big Data"
        },
        {
            "ID": "93",
            "Name": "Event log",
            "Paper": "17",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Storage pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "94",
            "Name": "Limit storage",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "95",
            "Name": "Packing variables",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "96",
            "Name": "Packing booleans",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "97",
            "Name": "Uint* vs Uint256",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "98",
            "Name": "Mapping vs Array",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "99",
            "Name": "Fixed size",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "100",
            "Name": "Default value",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "101",
            "Name": "Minimize on-chain data",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "102",
            "Name": "Explicitely mark external function",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "103",
            "Name": "Limit external calls",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "104",
            "Name": "Internal function calls",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "105",
            "Name": "Fewer functions",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "106",
            "Name": "Use libraries",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "107",
            "Name": "Short circuit",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "108",
            "Name": "Short constant strings",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "109",
            "Name": "Limit modifiers",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "110",
            "Name": "Avoid redundant operations",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "111",
            "Name": "Single-line swap",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "112",
            "Name": "Write values",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "113",
            "Name": "Freeing storage",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "114",
            "Name": "Optimizer",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "115",
            "Name": "Confidential and pseudo-anonymous contract enforcement",
            "Paper": "20",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "BPM"
        },
        {
            "ID": "116",
            "Name": "Self-Generated Transactions",
            "Paper": "24",
            "Type (from paper)": "Architectural pattern",
            "Type (determined)": "Architectural pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "117",
            "Name": "Self-Confirmed Transactions",
            "Paper": "24",
            "Type (from paper)": "Architectural pattern",
            "Type (determined)": "Architectural pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "118",
            "Name": "Delegated Transactions",
            "Paper": "24",
            "Type (from paper)": "Architectural pattern",
            "Type (determined)": "Architectural pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "120",
            "Name": "Digital Record",
            "Paper": "24",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "134",
            "Name": "Multiple Blockchains",
            "Paper": "25",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Architectural pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "135",
            "Name": "On-chain encryption",
            "Alternative names": "Privacy, Data Encryption, Encrypting on-chain data",
            "Paper": "31",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Encryption pattern",
            "Introduced in (paper ID)": "31, 13, 33, 28",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "136",
            "Name": "Hash timestamping",
            "Paper": "31",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "137",
            "Name": "Pull payment",
            "Paper": "32",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Introduced in (paper ID)": "32, 27",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "138",
            "Name": "State machine",
            "Paper": "32",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Domain-based pattern",
            "Subsubcategory": "Multi-domain feature pattern",
            "Introduced in (paper ID)": "32, 27",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "141",
            "Name": "Ownership",
            "Paper": "32",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract access control pattern",
            "Introduced in (paper ID)": "32, 27, 33",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "142",
            "Name": "Access Restriction",
            "Paper": "32",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract access control pattern",
            "Introduced in (paper ID)": "32, 27",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "143",
            "Name": "Mortal",
            "Paper": "32",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Idiom",
            "Introduced in (paper ID)": "32, 27",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "144",
            "Name": "Automatic Deprecation",
            "Paper": "32",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "32, 27",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "146",
            "Name": "Satellite",
            "Paper": "32",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Introduced in (paper ID)": "32, 27",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "151",
            "Name": "Speed Bump",
            "Paper": "32",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "32, 35, 33",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "152",
            "Name": "Rate Limit",
            "Paper": "32",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "32, 35, 33",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "161",
            "Name": "Check Effect Interaction",
            "Alternative names": "Checks-Effects-Interaction, Checks-Effect-Interactions",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "33, 35",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "169",
            "Name": "Guard Check",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "170",
            "Name": "Time Constraint",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "33, 9",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "171",
            "Name": "Termination",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "33, 9",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "172",
            "Name": "Math",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract security pattern",
            "Introduced in (paper ID)": "33, 9",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "177",
            "Name": "Publisher-Subscriber",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Introduced in (paper ID)": "33, 34, 38",
            "Target (generalized)": "Ethereum",
            "Language (generalized)": "Solidity",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "178",
            "Name": "Tokenisation",
            "Alternative names": "Tokenized, Token",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Data management pattern",
            "Subsubcategory": "Storage pattern",
            "Introduced in (paper ID)": "13, 33, 25, 9, 5",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "179",
            "Name": "X-confirmation",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Transactions pattern",
            "Introduced in (paper ID)": "13, 33",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "180",
            "Name": "Contract Registry",
            "Alternative names": "Contract register",
            "Paper": "33",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Introduced in (paper ID)": "13, 20, 27, 32, 33",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "193",
            "Name": "Challenge Response",
            "Paper": "36",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "194",
            "Name": "Off-chain Signatures",
            "Paper": "36",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "196",
            "Name": "Delegated Computation",
            "Paper": "36",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Off-chain storage pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "197",
            "Name": "Low Contract Footprint",
            "Paper": "36",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract efficiency pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "202",
            "Name": "Pull-based inbound oracle",
            "Paper": "39",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "203",
            "Name": "Push-based inbound oracle",
            "Paper": "39",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "204",
            "Name": "Pull-based outbound oracle",
            "Paper": "39",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "205",
            "Name": "Push-based outbound oracle",
            "Paper": "39",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On/off-chain interaction pattern",
            "Subcategory": "Data exchange pattern",
            "Target (generalized)": "All blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "207",
            "Name": "Contract Composer",
            "Paper": "37",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "208",
            "Name": "Contract Decorator",
            "Paper": "37",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "210",
            "Name": "Contract Mediator",
            "Paper": "37",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "211",
            "Name": "Contract Observer",
            "Paper": "37",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract management pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        },
        {
            "ID": "212",
            "Name": "Hash Secret",
            "Paper": "37",
            "Type (from paper)": "Design pattern",
            "Type (determined)": "Design pattern",
            "Category": "On-chain pattern",
            "Subcategory": "Smart-contract pattern",
            "Subsubcategory": "Contract access control pattern",
            "Target (generalized)": "Smart-contract enabled blockchains",
            "Language (generalized)": "Unspecified",
            "Applicability domain (generalized)": "General"
        }
    ]
}