###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#HashStorageMüller2020
:HashStorageMüller2020 rdf:type owl:NamedIndividual ,
                   :OffChainDataStorage ,
                   :PaperBased ,
                   :BPM ,
                   :AllBlockchains ;

          :hasCanonical :OffChainDataStorageCanonical ;
          :ContextAndProblem "In collaborative processes where different organizations use shared data, the integrity of this common piece of data is a crucial trust concern. When data can be altered and manipulated, this might lead to anomalies and malicious behavior. For collaborators, it is hard to verify the integrity of the data and trace its provenance. Data integrity is an uncertainty where collaborators have to rely on the organization providing data."^^rdfs:Literal ;
          :Solution "In the tamper-proof hashed data storage pattern, the collaborator who acts as the data origin hashes the file. The hash is submitted through a transaction to the blockchain. A message with the hash is sent to data consumers. At any point in time, data consumers can verify the file’s integrity by comparing the hash of the received file with the hash on the blockchain. If the hashes do not match up, data has been changed."^^rdfs:Literal ;
          rdfs:label "Hash Storage" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TransparentEventLogMüller2020
:TransparentEventLogMüller2020 rdf:type owl:NamedIndividual ,
                   :TransparentEventLog ,
                   :PaperBased ,
                   :BPM ,
                   :AllBlockchains ;

          :hasCanonical :TransparentEventLogCanonical ;
          :ContextAndProblem "Non-repudiation of event occurrences is a trust concern in collaborative business processes. During the inter-organizational collaboration, incidents like failures during an activity execution might imply following different workflows. One instance of this is the error event. Therefore, it is essential that organizations cannot deny the occurrence of an event afterward to avoid compensation claims from other stakeholders. In terms of trust-aware business processes, the organization causes a trust concern regarding the non-repudiation of event occurrences."^^rdfs:Literal ;
          :Solution "Using the blockchain as a decentralized event log means to save the occurrence of events and data related to them immutably on a shared distributed ledger, as described in [21]. Technically, this can be implemented similar to the blockchain hashed data storage trust pattern. "^^rdfs:Literal ;
          rdfs:label "Transparent Event Log" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#BlockchainBpEngineMüller2020
:BlockchainBpEngineMüller2020 rdf:type owl:NamedIndividual ,
                   :BlockchainBpEngine ,
                   :PaperBased ,
                   :BPM ,
                   :AllBlockchains ;
          :requires :OracleCanonical ;

          :hasCanonical :BlockchainBpEngineCanonical ;
          :ContextAndProblem "For the successful execution of an instance of a business process, it is inevitable to ensure the correct control flow between subprocesses and activities of different organizations and within the same organization. To ensure the execution of a business process according to its defining model, business process engines [22] are commonly utilized. Traditionally, such engines are centrally managed. This implies that all other collaborators have to trust that the business process engine managed by one collaborator acts as intended. From a trust-aware BPM view, this means that there is uncertainty regarding the correctness (integrity) of the process flow present."^^rdfs:Literal ;
          :Solution "Blockchain-based business processes engines, as proposed by Lopez-Pintado et al. [23], store business process models in smart contracts on a blockchain. All collaborators have access to the smart contract and can, at any point, verify the model’s correctness."^^rdfs:Literal ;
          rdfs:label "Blockchain BP Engine" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SmartContractActivitiesMüller2020
:SmartContractActivitiesMüller2020 rdf:type owl:NamedIndividual ,
                   :SmartContractActivities ,
                   :PaperBased ,
                   :BPM ,
                   :SmartContractEnabledBlockchains ;
          :requires :OracleCanonical ;

          :hasCanonical :SmartContractActivitiesCanonical ;
          :ContextAndProblem "In an inter-organizational process, different collaborators are responsible for certain activities. The execution of activities carried out by one organization can be seen as a “black box” for other organizations. Without any modifications, collaborators cannot verify the correct execution of the activities of other collaborators. Further, it is also not traceable to them if even the resources to execute the activity at a certain point in time are available."^^rdfs:Literal ;
          :Solution "In this trust pattern, the business logic of an activity is encoded in a smart contract and deployed on the blockchain. The execution of the smart contract is either triggered by the responsible collaborator or by another smart contract, such as a decentralized business process engine."^^rdfs:Literal ;
          rdfs:label "Smart Contract Activities" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#BlockchainBasedReputationSystemMüller2020
:BlockchainBasedReputationSystemMüller2020 rdf:type owl:NamedIndividual ,
                   :BlockchainBasedReputationSystem ,
                   :PaperBased ,
                   :BPM ,
                   :AllBlockchains ;

          :hasCanonical :BlockchainBasedReputationSystemCanonical ;
          :ContextAndProblem "Reputation systems are a well-established method that has been used from the early ages of e-commerce to symbolize the trustworthiness of online business partners. Hence, they are an approach to build confidence in a process. From a technical perspective, reputation systems store the reputation claim that a source makes regarding a specific reputation target [26]. This requires the user to trust the centralized authority not to manipulate the saved reputation data. "^^rdfs:Literal ;
          :Solution "The blockchain technology can be leveraged to implement fully decentralized reputation systems. In such decentralized systems, there is no need to trust a centralized party for the integrity of reputation statements and their aggregation since all blockchain participants have access to the data"^^rdfs:Literal ;
          rdfs:label "Blockchain-based reputation system" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DecentralizeBusinessProcessMüller2020
:DecentralizeBusinessProcessMüller2020 rdf:type owl:NamedIndividual ,
                   :DecentralizeBusinessProcess ,
                   :PaperBased ,
                   :BPM ,
                   :AllBlockchains ;

          :hasCanonical :DecentralizeBusinessProcessCanonical ;
          :ContextAndProblem "In collaborative business processes, activities executed by one organization are usually outside of the domain of influence of other organizations. If one organization is in charge of particularly many tasks in a process, this can lead to a significant dependency on the organization. "^^rdfs:Literal ;
          :Solution "Blockchain can be used as a tool to connect subprocesses in a decentralized process and as a tool for incentivization of correct behavior. As a software connector, the blockchain technology can be used as an interface for message flows between different organizations."^^rdfs:Literal ;
          rdfs:label "Decentralize business process" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#KeyValueStoreWorley2019
:KeyValueStoreWorley2019 rdf:type owl:NamedIndividual ,
                   :KeyValueStore ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :KeyValueStoreCanonical ;
          :ContextAndProblem "Many smart contracts store nontrivial amounts of data. A common use case is a contract that serves a registry, storing data in a manner that takes advantage of the blockchain’s censorship-resistant and DDoS-resistant nature.  How can this data be stored and retrieved effectively?"^^rdfs:Literal ;
          :Solution "A key-value store is well-suited to blockchain data management, where the store is dynamically resizable and provides a value given a specific key."^^rdfs:Literal ;
          rdfs:label "Key-value store" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AddressMappingWorley2019
:AddressMappingWorley2019 rdf:type owl:NamedIndividual ,
                   :AddressMapping ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :AddressMappingCanonical ;
          :ContextAndProblem "Smart contracts often interact with various users, all of whom must be tracked independently. How can relationships between the smart contract and user accounts be managed correctly?"^^rdfs:Literal ;
          :Solution "Establish a mapping from addresses to contract-relevant data, defined for all possible Ethereum addresses. In the case of accounts that the contract has never interacted with, the mapping is from the address to a default value of the codomain (the set being mapped to). This mapping may be changed by the contract to other values of the type."^^rdfs:Literal ;
          rdfs:label "Address mapping" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AuthorizationWorley2019
:AuthorizationWorley2019 rdf:type owl:NamedIndividual ,
                   :EmbeddedPermission ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :EmbeddedPermissionCanonical ;
          :ContextAndProblem "A smart contract may need to transition to a new state that isn’t defined by its internal logic because of some external event or internal flaw. Since smart contracts are immutable, how can this transition be performed?"^^rdfs:Literal ;
          :Solution "Establish a permissioning system where the contract is hard-coded to perform special actions in response to specific users. This permission may come from a single user or a vote of many, and privileges may range from setting state variables to completely destroying the contract. The exact details of the permissions and privileges must be specified at creation."^^rdfs:Literal ;
          rdfs:label "Authorization" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#JudgeWorley2019
:JudgeWorley2019 rdf:type owl:NamedIndividual ,
                   :Judge ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :requires :AuthorizationWorley2019 ;

          :hasCanonical :JudgeCanonical ;
          :ContextAndProblem "Multiple parties are participating in a contract that is dependent on real-world data."^^rdfs:Literal ;
          :Solution "All parties identify a third-party actor that they all trust. This entity is given Authorization to update the contract with real-world state."^^rdfs:Literal ;
          rdfs:label "Judge" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TickerTapeWorley2019
:TickerTapeWorley2019 rdf:type owl:NamedIndividual ,
                   :TickerTape ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :requires :AuthorizationWorley2019 ;

          :hasCanonical :TickerTapeCanonical ;
          :ContextAndProblem "A contract must constantly supply up-to-date information about some real-world data."^^rdfs:Literal ;
          :Solution "Create a contract whose only purpose is to store regularly updated data about the external world. Use the Authorization pattern to allow a trusted source to update the state periodically/regularly. This contract is a service to other contracts that use the data."^^rdfs:Literal ;
          rdfs:label "Ticker Tape" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#VoteWorley2019
:VoteWorley2019 rdf:type owl:NamedIndividual ,
                   :Vote ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :BlockchainBasedReputationSystemMüller2020 ;

          :hasCanonical :VoteCanonical ;
          :ContextAndProblem "A contract must supply data that cannot rely on a single source. A large number of data sources are present and must be decided between."^^rdfs:Literal ;
          :Solution "Allow the input sources to vote on the correct answer. And, provide disincentives for voting incorrectly, as determined by the eventual consensus."^^rdfs:Literal ;
          rdfs:label "Vote" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AntiOracleWorley2019
:AntiOracleWorley2019 rdf:type owl:NamedIndividual ,
                   :ReverseOracle ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :ReverseOracleCanonical ;
          :ContextAndProblem "Information from different sources on the blockchain must be accessed off-chain."^^rdfs:Literal ;
          :Solution "Create an off-chain daemon that periodically examines the blockchain for specific events and collates the records of those events into a single off-chain source. Off-chain entities can then read a well-formatted digest of the relevant information."^^rdfs:Literal ;
          rdfs:label "Anti-Oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#BlocklistWorley2019
:BlocklistWorley2019 rdf:type owl:NamedIndividual ,
                   :Blocklist ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :BlocklistCanonical ;
          :ContextAndProblem "A contract needs to record a set of entities that will be disallowed access to some asset off-chain"^^rdfs:Literal ;
          :Solution "Define a contract that stores a Bloom filter coefficient set. Off-chain clients may download the coefficients to calculate with the Bloom filter"^^rdfs:Literal ;
          rdfs:label "Blocklist" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AnnouncementWorley2019
:AnnouncementWorley2019 rdf:type owl:NamedIndividual ,
                   :Announcement ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :requires :AuthorizationWorley2019 ;

          :hasCanonical :AnnouncementCanonical ;
          :ContextAndProblem "Information from different sources on the blockchain must be accessed by entities on-chain."^^rdfs:Literal ;
          :Solution "Create a contract that serves as a space where Authorized contracts can post announcements. These announcements can then be viewed by any other contract."^^rdfs:Literal ;
          rdfs:label "Announcement" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#BulletinBoardWorley2019
:BulletinBoardWorley2019 rdf:type owl:NamedIndividual ,
                   :BulletinBoard ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :JudgeWorley2019 ;
          :benefitsFrom :VoteWorley2019 ;

          :hasCanonical :BulletinBoardCanonical ;
          :ContextAndProblem "A contract must supply irregular updates on real-world data, from multiple sources."^^rdfs:Literal ;
          :Solution "Create a Bulletin Board contract, where requests for data can be posted and answered by users. Define a decision process for acceptance of the answers, perhaps using the Vote or Judge patterns, and expose the answer data."^^rdfs:Literal ;
          rdfs:label "Bulletin Board" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TokenWorley2019
:TokenWorley2019 rdf:type owl:NamedIndividual ,
                   :Tokenisation ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :requires :AddressMappingWorley2019 ;

          :hasCanonical :TokenisationCanonical ;
          :ContextAndProblem "A contract needs a flexible unit of accounting for access to a certain resource."^^rdfs:Literal ;
          :Solution "Define a token, or contract-based cryptocurrency. Use the Address Mapping pattern to associate each Ethereum address with a balance and provide functions for transfer of balance between users."^^rdfs:Literal ;
          rdfs:label "Token" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MigrationWorley2019
:MigrationWorley2019 rdf:type owl:NamedIndividual ,
                   :Migration ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :MigrationCanonical ;
          :ContextAndProblem "A contract has a defined lifespan, passing through multiple stages related to its development or obsolescence."^^rdfs:Literal ;
          :Solution "Create a special Migration contract that serves as a pointer to the current version of the contract. When the contract is upgraded, the Migration contract is updated with a pointer to the latest version."^^rdfs:Literal ;
          rdfs:label "Migration" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#InterFamilyCommunicationOwens2019
:InterFamilyCommunicationOwens2019 rdf:type owl:NamedIndividual ,
                   :InterFamilyCommunication ,
                   :PaperBased ,
                   :General ,
                   :HyperledgerSawtooth ;

          :hasCanonical :InterFamilyCommunicationCanonical ;
          :ContextAndProblem "In a smart contract environment, a desirable property is to have the capability for smart contracts to call other smart contracts. Ideally, this functionality should be as easy as having the ability to do a function call within another function in any programming language. Nevertheless, in a blockchain, the execution environment involves some form of cryptography, and it is challenging to pass along these cryptographic guarantees along smart contract calls without passing along more context. In Sawtooth, there is an additional challenge because the platform is language agnostic and transaction families can be written in different programming languages on the same blockchain deployment."^^rdfs:Literal ;
          :Solution "In this article, we have introduced a design pattern – called Inter-Family Communication – that provides a design solution to enable smart contracts to communicate with one another, even in the case where the smart contracts are written in different programming languages. "^^rdfs:Literal ;
          rdfs:label "Inter-family communication" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#LockingMavridou2018
:LockingMavridou2018 rdf:type owl:NamedIndividual ,
                   :Locking ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :LockingCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "To prevent reentrancy vulnerabilities, we provide a security plugin (ie. design pattern) for locking the smart contract. The locking feature eliminates reentrancy vulnerabilities in a “foolproof” manner: functions within the contract cannot be nested within each other in any way."^^rdfs:Literal ;
          rdfs:label "Locking" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TransitionCounterMavridou2018
:TransitionCounterMavridou2018 rdf:type owl:NamedIndividual ,
                   :TransitionCounter ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :TransitionCounterCanonical ;
          :ContextAndProblem "The state and the values of the variables stored in an Ethereum contract may be unpredictable. When a user invokes a function (i.e. transition in an FSM), she cannot be sure that the contract does not change in some way before the function is actually executed. This issue has been referred to as “transaction-ordering dependence” [6] and “unpredictable state” [13], and it can lead to various security issues. Furthermore, it is rather difficult to prevent since multiple users may invoke functions at the same time, and these function invocations might be executed in any order."^^rdfs:Literal ;
          :Solution "We provide a plugin that can prevent unpredictable-state vulnerabilities by enforcing a strict ordering on function executions. The plugin expects a transition number in every function as a parameter (i.e., as a transition input variable) and ensures that the number is incremented by one for each function execution. As a result, when a user invokes a function with the next transition number in sequence, she can be sure that the function is executed before any other state changes can take place (or that the function is not executed)."^^rdfs:Literal ;
          rdfs:label "Transition Counter" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AutomaticTimedTransitionsMavridou2018
:AutomaticTimedTransitionsMavridou2018 rdf:type owl:NamedIndividual ,
                   :AutomaticTimedTransitions ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :AutomaticTimedTransitionsCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "We implement timed transitions as a modifier that is applied to every function. When a transition is invoked, the modifier checks whether any timed transitions must be executed before the invoked transition is executed. If so, the modifier executes the timed transitions before the invoked transition. "^^rdfs:Literal ;
          rdfs:label "Automatic Timed Transitions" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AccessControlMavridou2018
:AccessControlMavridou2018 rdf:type owl:NamedIndividual ,
                   :EmbeddedPermission ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :EmbeddedPermissionCanonical ;
          :ContextAndProblem "In many contracts, access to certain transitions (i.e., functions) needs to be controlled and restricted."^^rdfs:Literal ;
          :Solution "For example, any user can participate in a typical blind auction by submitting a bid, but only the creator should be able to cancel the auction. To facilitate the enforcement of such constraints, we provide a plugin that 1) manages a list of administrators at runtime (identified by their addresses) and 2) enables developers to forbid non-administrators from accessing certain functions. "^^rdfs:Literal ;
          rdfs:label "Access Control" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TokenBartoletti2017
:TokenBartoletti2017 rdf:type owl:NamedIndividual ,
                   :Tokenisation ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :TokenisationCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "This pattern is used to distribute some fungible goods (represented by tokens) to users. Tokens can represent a wide variety of goods, like e.g. coins, shares, outcomes or tickets, or everything else which is transferable and countable."^^rdfs:Literal ;
          rdfs:label "Token" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AuthorizationBartoletti2017
:AuthorizationBartoletti2017 rdf:type owl:NamedIndividual ,
                   :EmbeddedPermission ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :EmbeddedPermissionCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "This pattern is used to restrict the execution of code according to the caller address. The majority of the analysed contracts check if the caller address is that of the contract owner, before performing critical operations (e.g., sending ether, invoking suicide or selfdestruct)."^^rdfs:Literal ;
          rdfs:label "Authorization" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OracleBartoletti2017
:OracleBartoletti2017 rdf:type owl:NamedIndividual ,
                   :Oracle ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :OracleCanonical ;
          :ContextAndProblem "Some contracts may need to acquire data from outside the blockchain, e.g. from a website, to determine the winner of a bet. The Ethereum language does not allow contracts to query external sites: otherwise, the determinism of computations would be broken, as different nodes could receive different results for the same query"^^rdfs:Literal ;
          :Solution "Oracles are the interface between contracts and the outside.Technically, they are just contracts, and as such their state can be updated by sending them transactions. In practice, instead of querying an external service, a contract queries an oracle; and when the external service needs to update its data, it sends a suitable transaction to the oracle."^^rdfs:Literal ;
          rdfs:label "Oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#RandomnessBartoletti2017
:RandomnessBartoletti2017 rdf:type owl:NamedIndividual ,
                   :Randomness ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :requires :OracleCanonical ;

          :hasCanonical :RandomnessCanonical ;
          :ContextAndProblem "Dealing with randomness is not a trivial task in Ethereum. Since contract execution must be deterministic, all the nodes must obtain the same value when asking for a random number: this struggles with the randomness requirements wished."^^rdfs:Literal ;
          :Solution "To address this issue, several contracts (e.g., Slot) query oracles that generate these values off-chain."^^rdfs:Literal ;
          rdfs:label "Randomness" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PollBartoletti2017
:PollBartoletti2017 rdf:type owl:NamedIndividual ,
                   :Poll ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :benefitsFrom :TokenisationCanonical ;
          :benefitsFrom :AddressMappingCanonical ;

          :hasCanonical :PollCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Polls allows users to vote on some question. Often this is a side feature in a more complex scenario. For instance, in the Dice game, when a certain state is reached, the owner issues a poll to decide whether an emergency withdrawal is needed. To determine who can vote and to keep track of the votes, polls can use tokens, or they can check the voters’ addresses."^^rdfs:Literal ;
          rdfs:label "Poll" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TimeConstraintBartoletti2017
:TimeConstraintBartoletti2017 rdf:type owl:NamedIndividual ,
                   :TimeConstraint ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :TimeConstraintCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Many contracts implement time constraints, e.g. to specify when an action is permitted. For instance, BirthdayGift allows users to collect funds, which will be redeemable only after their birthday. In notary contracts, time constraints are used to prove that a document is owned from a certain date."^^rdfs:Literal ;
          rdfs:label "Time Constraint" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TerminationBartoletti2017
:TerminationBartoletti2017 rdf:type owl:NamedIndividual ,
                   :Termination ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :TerminationCanonical ;
          :ContextAndProblem "Since the blockchain is immutable, a contract cannot be deleted when its use has come to an end. Hence, developers must forethink a way to disable it, so that it is still present but unresponsive."^^rdfs:Literal ;
          :Solution "This can be done manually, by inserting ad-hoc code in the contract, or automatically, calling selfdestruct or suicide."^^rdfs:Literal ;
          rdfs:label "Termination" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MathBartoletti2017
:MathBartoletti2017 rdf:type owl:NamedIndividual ,
                   :Math ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :MathCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Contracts using this pattern encode the logic which guards the execution of some critical operations. For instance, Badge implements a method named subtractSafely to avoid subtracting a value from a balance when there are not enough funds in an account"^^rdfs:Literal ;
          rdfs:label "Math" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ForkCheckBartoletti2017
:ForkCheckBartoletti2017 rdf:type owl:NamedIndividual ,
                   :ForkCheck ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :ForkCheckCanonical ;
          :ContextAndProblem "The Ethereum blockchain has been forked four times, starting from July 20th, 2016, when a fork was performed to contrast the effect of the DAO attack [4]."^^rdfs:Literal ;
          :Solution "To know whether or not the fork took place, some contracts inspect the final balance of the DAO. Other contracts use this check to detect whether they are running on the main chain or on the fork, performing different actions in the two cases."^^rdfs:Literal ;
          rdfs:label "Fork check" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ChecksEffectInteractionsRajasekar2020
:ChecksEffectInteractionsRajasekar2020 rdf:type owl:NamedIndividual ,
                   :CheckEffectInteraction ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :ChecksEffectsInteractionWohrer2018 ;

          :hasCanonical :CheckEffectInteractionCanonical ;
          :ContextAndProblem "If the ”interactions” occur before the ”effects” are recorded and the invoked contract makes a callback to the original one, the system state can be exploited."^^rdfs:Literal ;
          :Solution "The contract first checks whether the necessary conditions are met, then makes necessary changes to the contract state (effects) and finally passes control to another contract (interactions)"^^rdfs:Literal ;
          rdfs:label "Checks-Effect-Interactions" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SecureEtherTransferRajasekar2020
:SecureEtherTransferRajasekar2020 rdf:type owl:NamedIndividual ,
                   :SecureEtherTransfer ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :ChecksEffectsInteractionWohrer2018 ;

          :hasCanonical :SecureEtherTransferCanonical ;
          :ContextAndProblem "Since the low-level function will forward all remaining gas to the invoked contract, using it allows further invocations to be made, provided the gas sent in the original call is sufficiently larger than the required minimum."^^rdfs:Literal ;
          :Solution "This is infact an anti-pattern. The low-level Solidity function, address.call() should not be used to invoke a contract. Instead, the high-level address.send() or address.transfer() should be preferred because they set a limit on the amount of gas1 the contract can forward to any invoked contract."^^rdfs:Literal ;
          rdfs:label "Secure Ether Transfer" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OracleRajasekar2020
:OracleRajasekar2020 rdf:type owl:NamedIndividual ,
                   :Oracle ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :OracleXu2018 ;
          :fromPattern :OracleDataProviderWohrer2018 ;
          :fromPattern :PublisherSubscriberRaj2018 ;
          :relatedTo :ReverseVerifierRajasekar2020 ;

          :hasCanonical :OracleCanonical ;
          :ContextAndProblem "A contract or blockchain-based application may sometimes need to access information from the external world."^^rdfs:Literal ;
          :Solution "The oracle pattern uses a third-party verifier to verify that information stored off-chain is valid, before it can be relayed to the blockchain."^^rdfs:Literal ;
          rdfs:label "Oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OffChainDatastoreRajasekar2020
:OffChainDatastoreRajasekar2020 rdf:type owl:NamedIndividual ,
                   :OffChainDataStorage ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :fromPattern :OnChainAndOffChainLu2019 ;

          :hasCanonical :OffChainDataStorageCanonical ;
          :ContextAndProblem "Since the blockchain is a distributed store of data, many nodes in the network must store the entire blockchain, which becomes infeasible if too much data is stored in every block."^^rdfs:Literal ;
          :Solution "If the raw data to be stored on the blockchain takes too much memory, calculate a hash for the entire raw data and store this on the blockchain instead."^^rdfs:Literal ;
          rdfs:label "Off-chain Datastore" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#StateChannelRajasekar2020
:StateChannelRajasekar2020 rdf:type owl:NamedIndividual ,
                   :StateChannel ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :fromPattern :StateChannelXu2018 ;

          :hasCanonical :StateChannelCanonical ;
          :ContextAndProblem "As mentioned, storing large amounts of data on the blockchain is not sustainable for scalability and sometimes cost issues. In the case of micro-transactions, the amount being transacted is significantly lesser than the processing fees and will take up as much space as any other transaction on the chain."^^rdfs:Literal ;
          :Solution "Micro-transactions should not be stored on the blockchain; they should be stored off-chain and only the final settled amounts should be stored on-chain. There are some use-cases of this pattern, the most common being the Lightning Network in Bitcoin and Plasma in Ethereum."^^rdfs:Literal ;
          rdfs:label "State Channel" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OffChainContractRegistryRajasekar2020
:OffChainContractRegistryRajasekar2020 rdf:type owl:NamedIndividual ,
                   :OffChainContractRegistry ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :ContractRegistryXu2018 ;
          :fromPattern :ContractRegisterWohrer2018 ;
          :relatedTo :ProxyContractRajasekar2020 ;

          :hasCanonical :OffChainContractRegistryCanonical ;
          :ContextAndProblem "Code on a smart contract may need to be modified or updated to deal with bugs and changing requirements."^^rdfs:Literal ;
          :Solution "Every contract and its address are stored off-chain as key-value pairs. This mapping is mutable since it is off-chain, which means that the address of a contract can be updated in the registry. Since calls to any contract will now go through the registry, this leaves all dependencies intact. "^^rdfs:Literal ;
          rdfs:label "(Off-chain) Contract Registry" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DataContractRajasekar2020
:DataContractRajasekar2020 rdf:type owl:NamedIndividual ,
                   :DataContract ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :DataContractXu2018 ;
          :fromPattern :DataSegregationWohrer2018 ;

          :hasCanonical :DataContractCanonical ;
          :ContextAndProblem "If a contract stores its data within itself, modifying the contract using the registry or proxy pattern will mean rewriting all of the data to the updated version as well. Since the outdated contracts still remain on the blockchain, and are only indirectly replaced by the updated versions, the data will be stored redundantly with every new version of the contract (Volland, 2018). Conversely, storing the data on a data contract would reduce redundant data storage."^^rdfs:Literal ;
          :Solution "Store data and code on separate contracts to decouple them."^^rdfs:Literal ;
          rdfs:label "Data Contract" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EmbeddedPermissionRajasekar2020
:EmbeddedPermissionRajasekar2020 rdf:type owl:NamedIndividual ,
                   :EmbeddedPermission ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :EmbeddedPermissionXu2018 ;
          :fromPattern :EmbeddedPermissionLu2019 ;

          :hasCanonical :EmbeddedPermissionCanonical ;
          :ContextAndProblem "A good example of a critical or sensitive function is self destruct() in Solidity2. The absence of embedded permission to execute this particular function was leveraged in the Parity Wallet hack."^^rdfs:Literal ;
          :Solution "Contracts must have an embedded permission field for certain critical functions, which allows only authorized users to run them. This is comparable to an end-user not having access to all the back-end code."^^rdfs:Literal ;
          rdfs:label "Embedded Permission" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#FactoryContractRajasekar2020
:FactoryContractRajasekar2020 rdf:type owl:NamedIndividual ,
                   :FactoryContract ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :FactoryContractXu2018 ;
          :fromPattern :AbstractFactoryRaj2018 ;

          :hasCanonical :FactoryContractCanonical ;
          :ContextAndProblem "Using a factory contract helps make a DApp’s code modular and reduces the amount of updates required when new functionality is added to the DApp. It also ensures that certain design principles are consistent throughout the application."^^rdfs:Literal ;
          :Solution "This pattern is similar to the idea of a class in programming languages. It entails storing a template contract on the blockchain to instantiate other contracts having a similar structure and flow"^^rdfs:Literal ;
          rdfs:label "Factory Contract" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EmergencyStopRajasekar2020
:EmergencyStopRajasekar2020 rdf:type owl:NamedIndividual ,
                   :EmergencyStop ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :EmergencyStopWohrer2018 ;

          :hasCanonical :EmergencyStopCanonical ;
          :ContextAndProblem "If a contract is executing malicious functions recursively or for several iterations, without the ability to interrupt, the malicious function can run indefinitely and the nodes can do nothing till execution completes."^^rdfs:Literal ;
          :Solution "Include the ability for an authorized party to stop the execution of a contract."^^rdfs:Literal ;
          rdfs:label "Emergency Stop" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MutexRajasekar2020
:MutexRajasekar2020 rdf:type owl:NamedIndividual ,
                   :Mutex ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :MutexWohrer2018 ;

          :hasCanonical :MutexCanonical ;
          :ContextAndProblem "Having a recursive call (or a callback) that modifies the state of the parent, before it has finished its execution, can cause serious issues as described several times above."^^rdfs:Literal ;
          :Solution "This patern is similar to mutexes in traditional programming. It prevents a contract from executing code in its parent contract, until the parent has executed completely. "^^rdfs:Literal ;
          rdfs:label "Mutex" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractBalanceLimitRajasekar2020
:ContractBalanceLimitRajasekar2020 rdf:type owl:NamedIndividual ,
                   :ContractBalanceLimit ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :BalanceLimitWohrer2018 ;

          :hasCanonical :ContractBalanceLimitCanonical ;
          :ContextAndProblem "Having a contract with too much capital reduces the target area for a potential attack to take place."^^rdfs:Literal ;
          :Solution "This pattern states that a contract should not hold any more funds than a predefined balance-limit. It must reject any further transactions made to it except for forced payments."^^rdfs:Literal ;
          rdfs:label "Contract Balance Limit" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ReverseVerifierRajasekar2020
:ReverseVerifierRajasekar2020 rdf:type owl:NamedIndividual ,
                   :ReverseOracle ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :ReverseOracleXu2018 ;
          :relatedTo :OracleRajasekar2020 ;

          :hasCanonical :ReverseOracleCanonical ;
          :ContextAndProblem "It is common to have application data in a traditional database and store only a hash on the blockchain. One shortcoming of this is that we cannot prevent tampering of data in the database."^^rdfs:Literal ;
          :Solution "Sometimes an application may need to access data from the blockchain. Like the oracle pattern, reverse verifier is used to verify data being sent to an external source from the blockchain."^^rdfs:Literal ;
          rdfs:label "Reverse Verifier" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#IncentiveExecutionRajasekar2020
:IncentiveExecutionRajasekar2020 rdf:type owl:NamedIndividual ,
                   :IncentiveExecution ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :IncentiveExecutionXu2018 ;

          :hasCanonical :IncentiveExecutionCanonical ;
          :ContextAndProblem "Some functions perform tasks like cleaning up expired records, making dividend payouts and destroying deprecated contracts. These utility functions also require gas to be executed, and the payout is usually not enough to offset the execution cost. "^^rdfs:Literal ;
          :Solution "Make seldom-run utility functions piggyback onto contracts that execute more often."^^rdfs:Literal ;
          rdfs:label "Incentive Execution" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#CommitAndRevealRajasekar2020
:CommitAndRevealRajasekar2020 rdf:type owl:NamedIndividual ,
                   :CommitAndReveal ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :CommitAndRevealWohrer2018 ;

          :hasCanonical :CommitAndRevealCanonical ;
          :ContextAndProblem "If a contract’s internal state is visible to the network, it is possible for a malicious user to take advantage, and invoke the contract with deliberately selected variables that change the state to one they desire."^^rdfs:Literal ;
          :Solution "This pattern works by hiding certain secret variables in a contract’s function, and only displaying the final values. Authorized users may have access to the secret."^^rdfs:Literal ;
          rdfs:label "Commit and Reveal" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ProxyContractRajasekar2020
:ProxyContractRajasekar2020 rdf:type owl:NamedIndividual ,
                   :ProxyContract ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :ContractRelayWohrer2018 ;
          :relatedTo :OffChainContractRegistryRajasekar2020 ;

          :hasCanonical :ProxyContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Create a proxy for each contract, which will accept, and then forward the parameters to the current version of the contract."^^rdfs:Literal ;
          rdfs:label "Proxy Contract" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DynamicBindingRajasekar2020
:DynamicBindingRajasekar2020 rdf:type owl:NamedIndividual ,
                   :DynamicBinding ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :DynamicBindingLu2019 ;

          :hasCanonical :DynamicBindingCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Create a dynamic association between a contract and its authorized users’ addresses, in such a way that the addresses are not defined in the contract. Instead, the users send a secret key to another, designated contract, which forwards the request to the the main one if the key is valid."^^rdfs:Literal ;
          rdfs:label "Dynamic Binding" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#FlyweightRajasekar2020
:FlyweightRajasekar2020 rdf:type owl:NamedIndividual ,
                   :Flyweight ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :FlyweightRaj2018 ;
          :relatedTo :DataContractRajasekar2020 ;

          :hasCanonical :FlyweightCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Inspired in part by the data contract design pattern, the flyweight contract stores data that is shared by a group of clients in one common place."^^rdfs:Literal ;
          rdfs:label "Flyweight" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TightVariablePackingRajasekar2020
:TightVariablePackingRajasekar2020 rdf:type owl:NamedIndividual ,
                   :TightVariablePacking ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :Unknown ;

          :hasCanonical :TightVariablePackingCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Store static variables in smart contracts as the smallest possible data type that they can fit in. For example don’t store a value as an int if it could be stored as a byte."^^rdfs:Literal ;
          rdfs:label "Tight Variable Packing" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OracleXu2018
:OracleXu2018 rdf:type owl:NamedIndividual ,
                   :Oracle ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :relatedTo :ReverseOracleXu2018 ;
          :requires :Unknown ;

          :hasCanonical :OracleCanonical ;
          :ContextAndProblem "From the software architecture perspective, blockchain can be viewed as a component or connector within a large software system [19]. In the case the blockchain is used as a distributed database for more general purposes other than financial services, the applications built on blockchain might need to interact with other external systems. Thus, the validation of transactions on blockchain might depend on states of external systems. The execution environment of a blockchain is self-contained. It can only access information present in the data and transactions on the blockchain. Smart contracts running on blockchain are pure functions by design. The state of external systems are not directly accessible to smart contracts. Yet, function calls in smart contracts sometimes need to access state of the external world. How can function calls in smart contracts be enabled to access the state of the external world from within smart contracts?"^^rdfs:Literal ;
          :Solution "To connect the closed execution environment of blockchain with the external world, a oracle is introduced to evaluate conditions that cannot be expressed in a smart contract running within the blockchain environment. A oracle is a trusted third party that provides the smart contracts with information about the external world. When validation of a transaction depends on external state, the oracle is requested to check the external state and to provide the result to the validator (miner), which then takes the result provided by the oracle into account when validating the transaction. The oracle can be implemented inside a blockchain network as a smart contract with external state being injected into the oracle periodically by an off-chain injector. Later, other smart contracts can access the data from the oracle smart contract. "^^rdfs:Literal ;
          rdfs:label "Oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ReverseOracleXu2018
:ReverseOracleXu2018 rdf:type owl:NamedIndividual ,
                   :ReverseOracle ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :relatedTo :OracleXu2018 ;

          :hasCanonical :ReverseOracleCanonical ;
          :ContextAndProblem "In a software system, where blockchain is one of the components, the off-chain components might need to use the data stored on the blockchain and the smart contracts running on the blockchain to check certain conditions. Some domains use very large and mature (or even legacy) systems, which comply with existing standards. For such domains, an non-intrusive approach is desired to leverage the existing complex systems with blockchain without changing the core of the existing systems."^^rdfs:Literal ;
          :Solution "The unique ID ofthe transactions or blocks on blockchain is a piece of data that can be easily integrated into the existing systems. Validation of the data can be implemented by smart contracts running on blockchain. An off-chain component is required to query the blockchain through using the ID of the data."^^rdfs:Literal ;
          rdfs:label "Reverse oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#LegalAndSmartContractPairXu2018
:LegalAndSmartContractPairXu2018 rdf:type owl:NamedIndividual ,
                   :LegalAndSmartContractPair ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :LegalAndSmartContractPairCanonical ;
          :ContextAndProblem "The legal industry is becoming digitized, for example, using digital signatures has become a valid way to sign legal agreements. The Ricardian contract [8] was developed in the mid 1990s to interpret legal contracts digitally without losing the value of the legal prose. Digital legal agreements need to be executed and enforced. An independent trustworthy execution platform trusted by all the involved participants is needed to execute the digital legal agreement. How to bind a legal agreement to the corresponding smart contract on a trusted execution environment to ensure a 1-to-1 mapping?"^^rdfs:Literal ;
          :Solution "Blockchain can be an ideal trusted platform to run digital legal agreements, which are bound with corresponding on-chain smart contracts. The smart contract implements conditions defined in the legal agreement. When deployed, there is a variable to store the hash value of the legal agreement, but is initially a blank value. The address of the smart contract is included in the legal agreement, and then the hash of the legal agreement is calculated and added to the contract variable. By binding a physical agreement with a smart contract, the bridge between the off-chain physical agreement and the on-chain smart contract is established. The two directional binding makes sure that the legal agreement and smart contract have"^^rdfs:Literal ;
          rdfs:label "Legal and smart-contract pair" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EncryptingOnChainDataXu2018
:EncryptingOnChainDataXu2018 rdf:type owl:NamedIndividual ,
                   :OnChainEncryption ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :relatedTo :OffChainDataStorageXu2018 ;

          :hasCanonical :OnChainEncryptionCanonical ;
          :ContextAndProblem "For some applications on blockchain, there might be commercially critical data that should be only accessible to the involved participants. An example would be a special discount price offered by a service provider to a subset of its users. Such information should not be accessible to the other users who do not get the discount. The lack of data privacy is one of the main limitations of blockchain. All the information on blockchain is publicly available to the participants of the blockchain. There is no privileged user within the blockchain network, no matter the blockchain is public, consortium or private. On a public blockchain, new participants can join the blockchain network freely and access all the information recorded on blockchain. Any confidential data on public blockchain is exposed to the public."^^rdfs:Literal ;
          :Solution "To preserve the privacy ofthe involved participants, symmetric or asymmetric encryption can be used to encrypt data before inserting the data into blockchain. One possible design for sharing encrypted data among multiple participants is as follows. First, one of the involved participants creates a secret key for encrypting data and distributes it during an initial key exchange. When one of the participants needs to add a new data item to the blockchain, they first symmetrically encrypt it using the secret key. Only the participants allowed to access the transaction have the secret key and can decrypt the information."^^rdfs:Literal ;
          rdfs:label "Encrypting on-chain data" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TokenisationXu2018
:TokenisationXu2018 rdf:type owl:NamedIndividual ,
                   :Tokenisation ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :TokenisationCanonical ;
          :ContextAndProblem "The concept of tokenisation has emerged centuries ago with the first currency systems. Tokenisation is a means to reduce risk in handling high value financial instruments by replacing them with equivalents, for example, the tokens used in casino. Tokens can represent a wide range of goods which are transferable and fungible, like shares, or tickets. Tokens representing assets should be the authoritative source of the corresponding assets."^^rdfs:Literal ;
          :Solution "Tokenisation is a process starting from an asset (e.g., money) is locked under a custody (e.g., a bank), and gets represented in the cryptographic world through a token. The ownership of the digital token matches the ownership of the corresponding asset. The reverse process can take place by which the user redeems the token to recover the value which is sitting within the bank. A token on blockchain is the authoritative source of the physical asset. By using smart contracts, some conditions can be implemented and associated with the ownership transfer."^^rdfs:Literal ;
          rdfs:label "Tokenisation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OffChainDataStorageXu2018
:OffChainDataStorageXu2018 rdf:type owl:NamedIndividual ,
                   :OffChainDataStorage ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :relatedTo :ProxyZhang2017 ;

          :hasCanonical :OffChainDataStorageCanonical ;
          :ContextAndProblem "Some applications consider using the blockchain to guarantee the integrity of large amounts of data. The blockchain, due to its full replication across all participants of the blockchain network, has limited storage capacity. Storing large amounts of data within a transaction may be impossible due to the limited size of the blocks of the blockchain (for example, Ethereum has a block gas limit to determine the number, computational complexity, and data size ofthe transactions included in the block). Data cannot take advantage of the immutability or integrity guarantees without being stored on the blockchain. How to store data of arbitrary size and take advantage of the immutability and integrity guarantees provided by the blockchain?"^^rdfs:Literal ;
          :Solution "The blockchain can be used as a general-purpose replicated database, as transactions logged in the blockchain can include arbitrary data on some blockchain platforms. For data of big size (essentially data that is bigger than its hash value), rather than storing the raw data directly on blockchain, a representation of the data with smaller size can be stored on blockchain with other small sized metadata about the data (e.g., a URI pointing to it). The solution is to store a hash value (also called digest) of the raw data on chain. The value is generated by a hash function which maps data of arbitrary size to data of fixed size. Hash function is a one-way function which is easy to compute, but hard to invert given the output of a random input. If even one bit of the data changes, its corresponding hash value would change as well. The hash value is used for ensuring the integrity of the raw data stored off-chain, and the transaction on blockchain that includes the hash value guarantees the integrity of the hash value as well as the original raw data from which the hash was derived."^^rdfs:Literal ;
          rdfs:label "Off-chain data storage" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#StateChannelXu2018
:StateChannelXu2018 rdf:type owl:NamedIndividual ,
                   :StateChannel ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :relatedTo :OffChainSignaturesEberhardt2017 ;

          :hasCanonical :StateChannelCanonical ;
          :ContextAndProblem "Micro-payments are payments that can be as small as a few cents, e.g., payment of a very small amount of money to a WiFi hot-spot for every 10 kilobytes of data usage. Blockchain has potential to be used for such financial transactions with tiny monetary value. The question is if it is necessary and cost effective to store all the micro-payment transactions on blockchain. The decentralized design of blockchain has limited performance. Transactions can take several minutes or even one hour (for Bitcoin blockchain) to be committed on the blockchain [17]. Due to the long commit time and high transaction fees on a public blockchain (where fees are largely independent of the transacted amount), it is often infeasible to store every micro-payment transaction on the blockchain network. "^^rdfs:Literal ;
          :Solution "A solution is to establish a payment channel between two participants, with a deposit from one or both sides of the participants locked up as security in a smart contract for the lifetime of the payment channel. The payment channel keeps the intermediate states of the micro-payment off-chain, and only stores the finalized payment on chain. The frequency of transaction settlement depends on the use case, and agreement between the two sides. A network of micro-payment channels can be built where the transactions transferring small values occur off-chain. The individual transactions take place entirely off the blockchain and exclusively between the participants, across multiple hops where needed. Only the final transaction that settles the payment for a given channel or set of channels is submitted to the blockchain. "^^rdfs:Literal ;
          rdfs:label "State channel" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MultipleAuthorizationXu2018
:MultipleAuthorizationXu2018 rdf:type owl:NamedIndividual ,
                   :MultipleAuthorization ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :OffChainSecretEnabledDynamicAuthenticationXu2018 ;

          :hasCanonical :MultipleAuthorizationCanonical ;
          :ContextAndProblem "In blockchain-based applications, activities might need to be authorized by multiple blockchain addresses. For example, a monetary transaction may require authorization from multiple blockchain addresses. The actual addresses that authorize an activity might not be able to be decided due to the availability of the authorities."^^rdfs:Literal ;
          :Solution "It would enable more dynamism if the set of blockchain addresses for authorization are not decided before the corresponding transaction being submited into the blockchain network, or the corresponding smart contract being deployed on blockchain. On the Bitcoin blockchain, a multi-signature mechanism can be used to require more than one private key to authorize a Bitcoin transaction. In Ethereum, smart contract can mimic multi-signature mechanism. More flexibly, an M-of-N multi-signature can be used to define that M out of N private keys are required to authorize the transaction. M is the threshold of authorization. This on-chain mechanism enables more flexible binding of authorities."^^rdfs:Literal ;
          rdfs:label "Multiple authorization" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OffChainSecretEnabledDynamicAuthenticationXu2018
:OffChainSecretEnabledDynamicAuthenticationXu2018 rdf:type owl:NamedIndividual ,
                   :OffChainSecretEnabledDynamicAuthentication ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :MultipleAuthorizationXu2018 ;

          :hasCanonical :OffChainSecretEnabledDynamicAuthenticationCanonical ;
          :ContextAndProblem "In blockchain-based applications, some activities need to be authorized by one or more participants that are unknown when a first transaction is submitted to blockchain. Sometimes, the authority who can authorize a given activity is unknown when the corresponding smart contract is deployed, or the corresponding transaction is submitted to the blockchain. Blockchain uses digital signature for authentication and transaction authorization. Blockchain does not support dynamic binding with an address of a participant which is not defined in the respective transaction or smart contract. All accounts that can authorize a second transaction have to be defined in the first transaction before that transaction is added to the blockchain."^^rdfs:Literal ;
          :Solution "An off-chain secret can be used to enable a dynamic authorization when the participant authorizing a transaction is unknown beforehand. In the context of payment, for example, a smart contract can be used as an escrow. When the sender deposits the money to an escrow smart contract, a hash of a secret (e.g. a random string, called pre-image) is submitted with the money as well. Whoever receives the secret off-chain can claim the money from the escrow smart contract by revealing the secret. With this solution, the receiver of the money does not need to be defined beforehand in the escrow contract. This can be generalized to any transaction that needs authorization from a dynamically bound participant. Note that since the secret is revealed, it cannot be reused. One variant is to lock multiple transactions with the same secret – by unlocking one, all of them are unlocked."^^rdfs:Literal ;
          rdfs:label "Off-chain secret enabled dynamic authentication" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#XConfirmationXu2018
:XConfirmationXu2018 rdf:type owl:NamedIndividual ,
                   :XConfirmation ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :XConfirmationCanonical ;
          :ContextAndProblem "Immutability of a blockchain using Proof-of-work (Nakamoto) consensus is probabilistic immutability. There is always a chance that the most recent few blocks are replaced by a competing chain fork. At the time a fork occurs, there is usually no certainty as to which branch will be permanently kept in the blockchain and which branches will be discarded. The transactions that were included in the branches being discarded eventually go back to the transaction pool and being added into a later block."^^rdfs:Literal ;
          :Solution "From the application perspective, one security strategy is to wait for a certain number (X) of blocks to be generated after the transaction is included into one block. After X blocks, the transaction is taken to be committed and thus perceived as immutable [17]. The value of X can be decided by the developers of the blockchain-based applications."^^rdfs:Literal ;
          rdfs:label "X-confirmation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractRegistryXu2018
:ContractRegistryXu2018 rdf:type owl:NamedIndividual ,
                   :ContractRegistry ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :EmbeddedPermissionXu2018 ;
          :benefitsFrom :DataContractXu2018 ;

          :hasCanonical :ContractRegistryCanonical ;
          :ContextAndProblem "As any software application, blockchain-based applications need to be upgraded to new versions. To do so, the on-chain functions defined in smart contracts need to be updated to fix bugs as well as to fulfil new requirements. Smart contracts deployed on blockchain cannot be upgraded because the code of the smart contracts as a type of data, stored on blockchain is immutable."^^rdfs:Literal ;
          :Solution "An on-chain registry contract is used to maintain a mapping between user-defined symbolic names and the blockchain addresses of the registered contracts. The address of the registry contract needs to be advertised off-chain. The creator of a contract can register the name and the address ofthe new contract to the registry contract after the new contract being deployed. The invoker of a registered contract retrieves the latest version of the new smart contract from the registry contract. The corresponding functions provided by the registered contract can be upgraded by replacing the address of the old version contract in the registry contract with the address of a new version without breaking the dependency between the upgraded smart contract and other smart contracts that depend on its functions. The address of a contract is stored as a variable in the registry contract. The value of contract variables can be updated. The registry contract can have a permission control module to maintain the writing permission. Note that all the previous values of the variable are still stored on the blockchain."^^rdfs:Literal ;
          rdfs:label "Contract registry" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EmbeddedPermissionXu2018
:EmbeddedPermissionXu2018 rdf:type owl:NamedIndividual ,
                   :EmbeddedPermission ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :AuthorizationWorley2019 ;
          :benefitsFrom :MultipleAuthorizationXu2018 ;
          :benefitsFrom :OffChainSecretEnabledDynamicAuthenticationXu2018 ;

          :hasCanonical :EmbeddedPermissionCanonical ;
          :ContextAndProblem "All the smart contracts running on blockchain can be accessed and called by all the blockchain participants and other smart contracts by default, because there are no privileged users and, in the case of public blockchain, every participant can join the network to access all the information and code stored and running on blockchain. A smart contract by default has no owner, meaning that once deployed the author of the smart contract has no special privilege on the smart contract. A permission-less function can be triggered by unauthorized users accidentally. Such a permissionless function becomes vulnerability ofblockchain-based application."^^rdfs:Literal ;
          :Solution "Adding permission control to every smart contract function to check permissions for every caller that triggers the functions defined in the smart contract based on the blockchain addresses of the caller. This can be done by checking the authorization of the caller before executing the logic of the function: unauthorized calls are rejected and the execution of the function terminated before reaching the core logic of the function."^^rdfs:Literal ;
          rdfs:label "Embedded permission" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DataContractXu2018
:DataContractXu2018 rdf:type owl:NamedIndividual ,
                   :DataContract ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :ContractRegistryXu2018 ;

          :hasCanonical :DataContractCanonical ;
          :ContextAndProblem "The need to upgrade a blockchain-based application over time is ultimately necessary, so as the smart contracts used by the application. In general, logic and data change at different times and with different frequencies. There are different ways to store a data on blockchain, as discussed in Hash Integrity pattern (Section 5.3).&#10;Problem: Storing data on blockchain is expensive and there is a limitation on the amount ofdata and amount ofcomputation a transaction can contain. In the context of upgrading smart contracts, the upgrading transactions might contain a large data storage for copying the data from the old version of the smart contract to the new version of the smart contract. Porting data to a new version might even require multiple transactions, e.g. when the block gas limit on Ethereum prevents an overly complex data migration transaction. "^^rdfs:Literal ;
          :Solution "To avoid moving data during upgrades ofsmart contracts, the data store is isolated from the rest of the code. In the context of blockchain, data could be separately stored in different smart contracts to enable isolation. Depending on the circumstances of the application, how large of a data store it needs and whether the data structure is expected to change often, the data store could use a strict definition or a loosely typed flat store. The more generic and flexible data structure can be used by all the other logic smart contracts and is unlikely to require changes. One example of a generic data structure is a mapping to store SHA3 key and value pairs."^^rdfs:Literal ;
          rdfs:label "Data contract" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#FactoryContractXu2018
:FactoryContractXu2018 rdf:type owl:NamedIndividual ,
                   :FactoryContract ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :ContractRegistryXu2018 ;

          :hasCanonical :FactoryContractCanonical ;
          :ContextAndProblem "Applications based on blockchain might need to use multiple instances of a standard contract with customization. Each contract instance is created by instantiating a contract template. For example, in a business process management system, each of the business process instances might be represented by a smart contract being generated from a contract template representing the business process model [18]. The template can be stored off-chain in a code repository, or on-chain, within its own smart contract. Keeping the contract template off-chain cannot guarantee consistency between different smart contract instances created from the same template because the source code of the template can be independently modified."^^rdfs:Literal ;
          :Solution "Smart contracts are created from a contract factory deployed on blockchain. The factory contract is deployed once from the off-chain source code. The factory may contain the definition of multiple smart contracts. Smart contract instances are generated by passing parameters to the contract factory to instantiate customized smart contract instances. Factory contract is analogous to a Class in an object-oriented programming language. Every transaction that generates a smart contract instance essentially instantiates an object of the factory contract class. This contract instance (the object) will maintain its own properties independently of the other instances but with a structure consistent with its original template."^^rdfs:Literal ;
          rdfs:label "Factory contract" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#IncentiveExecutionXu2018
:IncentiveExecutionXu2018 rdf:type owl:NamedIndividual ,
                   :IncentiveExecution ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :IncentiveExecutionCanonical ;
          :ContextAndProblem "Smart contracts are event-driven programs, which cannot execute autonomously. All the functions defined in a smart contract need to be triggered either by a transaction from external account or another smart contract to execute. Other than the functions that provide regular services to users, some functions need to run asynchronously from regular user interaction, for example, to clean up the expired records, or make dividend payouts etc. Such functions usually involve a time, after which the function should start. Users of a smart contract have no direct benefit from calling the accessorial functions. If a public blockchain is used, executing these functions causes extra monetary cost. Some accessorial functions are expensive to execute."^^rdfs:Literal ;
          :Solution "Reward the caller of a function defined in a smart contract for invoking the execution, for example, sending back a percentage of payout to the caller to reimburse the (gas) execution cost."^^rdfs:Literal ;
          rdfs:label "Incentive execution" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MasterSubKeyLiu2020
:MasterSubKeyLiu2020 rdf:type owl:NamedIndividual ,
                   :MasterSubKey ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :AllBlockchains ;
          :requires :HotColdWalletStorageLiu2020 ;
          :benefitsFrom :KeyShardingLiu2020 ;

          :hasCanonical :MasterSubKeyCanonical ;
          :ContextAndProblem "Public key cryptography and digital signatures are used to identify accounts and authorise transactions submitted to a blockchain. Using a single key for all transactions has serious privacy implication for an identity owner since transactions can be correlated to expose all the identities an entity holds."^^rdfs:Literal ;
          :Solution "Each entity can have a master-key to manage subkeys which are used for signing messages under different identities. For example, a person can have a sub-key for the student identity and another sub-key for the company intern identity. Each sub-key is linked to a unique identifier and stored as part of the identifier’s data in the identifier registry, which can be updated using the master-key. The use of masterkey must be minimised (i.e., only used for controlling subkeys) due to its importance."^^rdfs:Literal ;
          rdfs:label "Master & Sub Key" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#HotColdWalletStorageLiu2020
:HotColdWalletStorageLiu2020 rdf:type owl:NamedIndividual ,
                   :HotColdWalletStorage ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :AllBlockchains ;
          :benefitsFrom :DelegateListLiu2020 ;

          :hasCanonical :HotColdWalletStorageCanonical ;
          :ContextAndProblem "As a blockchain network participant, one entity can rely on so-called “wallets” to manage its accounts and interact with blockchain. An entity’s wallet may suffer malicious attacks, leading to key theft. The attacker can send transactions under that entity’s name to blockchain using a compromised key."^^rdfs:Literal ;
          :Solution "Users can choose to store keys in two types of wallets, namely hot wallet and cold wallet. Hot wallet refers to the blockchain gateways that are connected to Internet. Through a hot wallet, a user is able to directly conduct specific operations (e.g. generation) to its accounts and related decentralised identifiers stored on-chain. Cold wallet refers to key storage that is off-line, keeping the accounts from being hacked. A cold wallet can be any device disconnected from the internet or even a paper recording an entity’s keys. When the keys stored in a cold wallet are required for signing transactions, the user needs to connect the cold wallet device to a computer and copy-paste the key in the relevant field. A user can combine these two wallets: storing accounts that are frequently used in a hot wallet while using a cold wallet to keep those that are not used often."^^rdfs:Literal ;
          rdfs:label "Hot & Cold Wallet Storage" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#KeyShardingLiu2020
:KeyShardingLiu2020 rdf:type owl:NamedIndividual ,
                   :KeySharding ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :AllBlockchains ;
          :relatedTo :DelegateListLiu2020 ;
          :requires :HotColdWalletStorageLiu2020 ;

          :hasCanonical :KeyShardingCanonical ;
          :ContextAndProblem "In self-sovereign identity, a participant may have multiple keys, for instance, signing key for transaction authorisation, public/private key pair for encryption/decryption, etc. Consequently, key management is significant to the users, especially credential issuers and holders. A user may lose or forget his/her secret keys under some circumstances, e.g. the device containing the keys is lost or broken. Losing the keys denotes that the owner could lose control over its blockchain accounts in self-sovereign identity and the related identities."^^rdfs:Literal ;
          :Solution "To protect the security of a secret key, one can spilt that key into several pieces as its requirement, and define a regrouping threshold. The key pieces can be kept in any way the user prefers, e.g., wrote on a paper and locked in a safe box, given to family and friends, etc. When a key is lost, the user needs to regain enough key pieces (more than the preset regrouping threshold), and these pieces can help rebuild the complete key. "^^rdfs:Literal ;
          rdfs:label "Key Sharding" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#IdentifierRegistryLiu2020
:IdentifierRegistryLiu2020 rdf:type owl:NamedIndividual ,
                   :IdentifierRegistry ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :SmartContractEnabledBlockchains ;
          :relatedTo :ContentAddressableStorageEberhardt2017 ;
          :relatedTo :FlyweightZhang2017 ;
          :requires :MasterSubKeyLiu2020 ;
          :benefitsFrom :DelegateListLiu2020 ;

          :hasCanonical :IdentifierRegistryCanonical ;
          :ContextAndProblem "Identity is defined as sets of attributes related to an entity. In software applications, identity attribute data needs to be accessed for a specific purpose. An identifier is a globally unique persistent series of digits and/or characters that is used to uniquely identify an entity (e.g. human, organisation, device) within one domain and can be used to retrieve the storage location of the identity attribute data. A Decentralised Identifier (DID) is a new type of identifier which is designed for cryptographically verifiable self-sovereign identity. In traditional centralised software systems, mappings between an identifier and the identity data storage location is maintained by a centralised single authority which may become a potential single point of failure. "^^rdfs:Literal ;
          :Solution "Implementing an identifier registry designed as a smart contract to maintain bindings between an identifier and the location of associated off-chain identity data attributes. This identifier registry smart contract is the main entry point for accessing the attributes of an identity, which can map each identifier to a storage (e.g. IPFS, Dropbox, etc.) location for the respective identity attributes (e.g. an IPFS hash linking to the IPFS storage location containing the user’s identity attributes). Only the identifier owner is allowed to update the storage location of identity attributes. Each identifier points to an identifier document which describes how to use that specific identifier, e.g. public keys used for digital signatures, service endpoints for interaction."^^rdfs:Literal ;
          rdfs:label "Identifier Registry" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MultipleRegistrationLiu2020
:MultipleRegistrationLiu2020 rdf:type owl:NamedIndividual ,
                   :MultipleRegistration ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :SmartContractEnabledBlockchains ;
          :requires :IdentifierRegistryLiu2020 ;
          :requires :MasterSubKeyLiu2020 ;

          :hasCanonical :MultipleRegistrationCanonical ;
          :ContextAndProblem "An identifier is used to uniquely identify an entity and to retrieve the identity attribute data. Sending all transactions using a single identifier has serious privacy implication for an entity since these transactions can be correlated to expose all the identities this entity holds."^^rdfs:Literal ;
          :Solution "Each entity can establish a unique identifier for every relationship (i.e. every identity) they have, which allows keeping interactions with one entity entirely separate from any other entity. For example, the relationship a person builds with a hospital is completely separate to the one that is established with a university. Neither the hospital nor the university could proactively use the identifiers to correlate this person’s activities."^^rdfs:Literal ;
          rdfs:label "Multiple Registration" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#BoundWithSocialMediaLiu2020
:BoundWithSocialMediaLiu2020 rdf:type owl:NamedIndividual ,
                   :BoundWithSocialMedia ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :SmartContractEnabledBlockchains ;
          :requires :IdentifierRegistryLiu2020 ;

          :hasCanonical :BoundWithSocialMediaCanonical ;
          :ContextAndProblem "Social media profiles can be considered as one of the most important assets, which are critical to achieve more exposure on the internet, attract more attention, or improve online reputation. The trustworthiness of a social media profile can be improved by verifying the account using traditional identity issued by some central authority. On the other hand, blockchain provides a decentralised infrastructure for self-sovereign identity, where entities are in control over their own identities. In addition to verification by some certain people or central authorities, a user can link his/her social media profile (e.g. Twitter) to his/her identity registered on blockchain to improve the trustworthiness of both social media profile and blockchain-based identity. The problem here is how to bind a social media profile with the corresponding blockchain-based identity to ensure mapping."^^rdfs:Literal ;
          :Solution "An entity can create an attribute of social media in the identifier document. Signing the attribute with the blockchain signing key creates a claim that the blockchainbased identity controls the social media account. The attribute also contains a URL which links to a social media post stating that the social media account also controls this particular blockchain identity. Thus, a two-way link is established for connecting the blockchain identity with the social media profile. The two directional binding makes sure that that the social media profile and blockchain-based identity have a 1-to-1 mapping."^^rdfs:Literal ;
          rdfs:label "Bound with Social Media" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DualResolutionLiu2020
:DualResolutionLiu2020 rdf:type owl:NamedIndividual ,
                   :DualResolution ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :SmartContractEnabledBlockchains ;
          :requires :IdentifierRegistryLiu2020 ;

          :hasCanonical :DualResolutionCanonical ;
          :ContextAndProblem "In self-sovereign identity, entities interact with each other. When two or more entities want to establish interactions (e.g., for business purposes), each entity first needs to determine the target entity’s basic information and ways of communicating before going further."^^rdfs:Literal ;
          :Solution "A DDO contains verification methods (i.e. public keys) and service endpoints (e.g., messaging service details) which can be utilised by an entity to establish interactions with the corresponding DID owner. Before any formal activity between two entities in a relationship, they should first mutually resolve each other’s DID and obtain the interaction information stored in DDO. Such a process is considered as “Dual Resolution” and it forms the first step for any entity to establish an interoperation with its target entity."^^rdfs:Literal ;
          rdfs:label "Dual Resolution" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DelegateListLiu2020
:DelegateListLiu2020 rdf:type owl:NamedIndividual ,
                   :DelegateList ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :SmartContractEnabledBlockchains ;
          :relatedTo :DelegateListLiu2020 ;
          :benefitsFrom :IdentifierRegistryLiu2020 ;
          :benefitsFrom :MutexWohrer2018 ;

          :hasCanonical :DelegateListCanonical ;
          :ContextAndProblem "Each identity has a key pair to authenticate the transactions initiated by the user by means of digital signatures. A master-key may be compromised/stolen by malicious hackers. A compromised master-key results in the loss of ownership over all sub-keys and corresponding identifiers. The hacker may utilise the identifiers to further steal the entity’s identity data."^^rdfs:Literal ;
          :Solution "Delegate List relies on a web of trust architecture. This requires an identity owner to designate its own set of trustees that the owner trusts to assist in identity ownership update when the owner asks for it. An identifier maintains a list of recovery delegates and an update threshold that can help the user recover identity. These delegates can be individuals or organisations. If key loss happens, the original identity owner needs to request for ownership update using a new key pair, and a minimum number of the trustees (e.g. 2 out of 3) must sign a new identity record transaction respectively. When there are enough confirmations (i.e. reaching the threshold) of the new key pair, the ownership of the identifier is updated and thus the identity is recovered. A timelock period can be specified to prevent an attacker who tries to compromise an identity owner’s key and immediately change the owner’s identity records, including his/her designated trustees to prevent identifier ownership recovery."^^rdfs:Literal ;
          rdfs:label "Delegate List" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SelectiveContentGenerationLiu2020
:SelectiveContentGenerationLiu2020 rdf:type owl:NamedIndividual ,
                   :SelectiveContentGeneration ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :SmartContractEnabledBlockchains ;
          :requires :AnchoringToBlockchainLiu2020 ;
          :benefitsFrom :TimeConstrainedAccessLiu2020 ;
          :benefitsFrom :OneOffAccessLiu2020 ;

          :hasCanonical :SelectiveContentGenerationCanonical ;
          :ContextAndProblem "A verifier requires certain information to prove a holder’s identity, thus, a holder only needs to share a credential with necessary data to the verifer. If issuers publish general credentials to holders, a verifier can learn all identity data involved when only some particular attributes are needed. For instance, if a person shows his/her ID to identify the age, his/her address is presented either. This may cause data leak as extra information is provided."^^rdfs:Literal ;
          :Solution "Selective Content Generation allows issuers to decide what identity attributes are contained in a credential. An issued credential needs to satisfy the target verifier’s specific requirements of holder’s identity, without revealing extra data."^^rdfs:Literal ;
          rdfs:label "Selective Content Generation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TimeConstrainedAccessLiu2020
:TimeConstrainedAccessLiu2020 rdf:type owl:NamedIndividual ,
                   :TimeConstrainedAccess ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :SelectiveContentGenerationLiu2020 ;

          :hasCanonical :TimeConstrainedAccessCanonical ;
          :ContextAndProblem "Usually an identification process lasts for a certain time period. After proving the identity of an entity, the presented credential has accomplished its mission and should not be accessed again. After receiving a credential, a verifier then has the ability to access, read, and verify certain identity data of the holder. If the credential is long-term or even permanently effective, the verifier then can verify the credential after current identification process, which means that it can still access and check the holder’s identity data when there is not a legitimate permission for proving the identity, resulting identity data leak."^^rdfs:Literal ;
          :Solution "A holder is able to generate an identifiable link, and define its accessible period (e.g. certain days). The link can redirect to a page presenting credential content. Afterwards, the holder can share the time-constrained link to verifiers instead of the original credential itself. Within the predefined accessible period, a verifier can visit and verify the credential for identification without limit. Nevertheless, when the link is expired, there is no approach for the verifier to obtain credential content again."^^rdfs:Literal ;
          rdfs:label "Time-Constrained Access" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OneOffAccessLiu2020
:OneOffAccessLiu2020 rdf:type owl:NamedIndividual ,
                   :OneOffAccess ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :SelectiveContentGenerationLiu2020 ;

          :hasCanonical :OneOffAccessCanonical ;
          :ContextAndProblem "A verifier does not require a long-term effective credential but only needs to check the identity of a holder once for a specific purpose. Sometimes an identification process does not require a strict verification procedure, but only needs to check the identity for once. For instance, travelling by train/airplane or going to a theme park only asks for checking credentials before entering. If a holder presents a long-term effective link redirecting to the credential content, a malicious verifier may access the holder’s data illegally after identification process. This can be considered as an extreme version of Time-Constrained Access."^^rdfs:Literal ;
          :Solution "A holder is able to generate an identifiable link, which redirects to a one-off page presenting the credential content. One-off links can be shared with verifiers on some special occasions. After being visited once, the link becomes invalid that no one can use it to access the credential content."^^rdfs:Literal ;
          rdfs:label "One-Off Access" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AnchoringToBlockchainLiu2020
:AnchoringToBlockchainLiu2020 rdf:type owl:NamedIndividual ,
                   :OffChainDataStorage ,
                   :PaperBased ,
                   :IdentityManagement ,
                   :AllBlockchains ;
          :relatedTo :LowContractFootprintEberhardt2017 ;
          :relatedTo :OffChainDataStorageXu2018 ;

          :hasCanonical :OffChainDataStorageCanonical ;
          :ContextAndProblem "Blockchain’s nature configurations may limit its performance when facing a large number of transactions. Blockchain can ensure data integrity via storing data on-chain, but it costs real money to process the transaction in many public blockchain networks. In addition, according to the nature consensus mechanism, blockchain generates a block in a fixed period (i.e. block interval), which only includes a restricted number of transactions due to the block size. Consequently, blockchain’s performance may be restricted when users frequently initiate transactions."^^rdfs:Literal ;
          :Solution "Blockchain Anchor relies on the hashing technology that one does not need to store everything on-chain, but periodically sends the unique hash value of off-chain data to blockchain."^^rdfs:Literal ;
          rdfs:label "Anchoring to Blockchain" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SnapshottingBandara2020
:SnapshottingBandara2020 rdf:type owl:NamedIndividual ,
                   :Snapshotting ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :requires :EstablishGenesisBandara2020 ;
          :requires :HardForkBandara2020 ;
          :requires :StateInitializationBandara2020 ;

          :hasCanonical :SnapshottingCanonical ;
          :ContextAndProblem "The latest states and transactions of all accounts and smart contracts of the concert application need to be migrated to the target blockchain. Source blockchain is currently active; hence, the global state continues to change as new transactions arrive. The state to be migrated is already aggregated on the source blockchain.&#10;How to get a complete account of states, smart contracts, and transactions on the source blockchain before migration?"^^rdfs:Literal ;
          :Solution "Get a snapshot of relevant states, smart contracts, and transactions on the source blockchain at a given time. First, select a block number to initiate the snapshotting process and number of blocks to wait for finality (aka., x-confirmation). Second, update all instances of the BAL (Blockchain Access/API Layer). Third, the BAL should wait until the chosen block number is reached. Once reached, it should freeze processing further transactions to prevent any state changes. BAL should further wait for x-confirmation to ensure the finality of already issued transactions. Once it is reached, the migration tool can extract all required states, smart contracts, and transactions by querying the source blockchain via the BAL. Finally, all extracted data are saved as a snapshot file"^^rdfs:Literal ;
          rdfs:label "Snapshotting" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#StateAggregationBandara2020
:StateAggregationBandara2020 rdf:type owl:NamedIndividual ,
                   :StateAggregation ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :requires :OffChainDataStorageXu2018 ;
          :benefitsFrom :SnapshottingBandara2020 ;

          :hasCanonical :StateAggregationCanonical ;
          :ContextAndProblem "Concert application has a large number of accounts and states. Extracting all states from the source blockchain and recreating them on the target blockchain is both costly and time-consuming. The list of states to be migrated is given in the snapshot or ID database. How to extract and recreate a large number of states while minimizing the time and cost?"^^rdfs:Literal ;
          :Solution "Transfer all ConcertCoins to a single account, such that only the closing balance needs to be migrated. Fig. 5 shows the sequence of activities required to perform such an aggregation of state. To aggregate blockchain native assets, first, create a new account on the source blockchain. To aggregate states embedded in smart contracts, deploy a new Smart Contract (SC). Both cases will produce a new address (aggregateAddress). Then get the users’ consent to transfer their states by signing a transaction with the current state as payload and aggregateAddress as the recipient. Next, submit the signed transaction to the source blockchain. Finally, trigger the aggregate function at the aggregateAddress."^^rdfs:Literal ;
          rdfs:label "State Aggregation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TokenBurningBandara2020
:TokenBurningBandara2020 rdf:type owl:NamedIndividual ,
                   :TokenBurning ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :SnapshottingBandara2020 ;

          :hasCanonical :TokenBurningCanonical ;
          :ContextAndProblem "Because the source blockchain used by the nonprofit is public, it is not decommis- sioned after the migration. Therefore, any state and smart contracts left in the source blockchain could be misused (e.g., double spending). The list of states and smart contracts to be migrated is given in the snapshot or ID database. How to prevent the misuse of states and smart contracts after migration?"^^rdfs:Literal ;
          :Solution "Use transactions to transfer states such as native assets and tokens to an unusable account. Delete tokens by calling respective functions on the smart contracts that created them. Similarly, smart contracts can call the self-destruct function. All such attempts to make states and smart contracts unusable are referred to as token burning."^^rdfs:Literal ;
          rdfs:label "Token Burning" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#NodeSyncBandara2020
:NodeSyncBandara2020 rdf:type owl:NamedIndividual ,
                   :NodeSync ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :benefitsFrom :SnapshottingBandara2020 ;
          :benefitsFrom :StateAggregationBandara2020 ;

          :hasCanonical :NodeSyncCanonical ;
          :ContextAndProblem "The nonprofit wants to add new nodes or swap nodes to change the physical location, improve performance, or create multiple instances of the source blockchain. A snapshot of the source blockchain is available. How to clone a blockchain node?"^^rdfs:Literal ;
          :Solution "First, install the source blockchain platform’s client software (or an updated version that is backward compatible) on the new node. Also, configure the new node to connect to other members of the source blockchain. Second, enable the sync tool on the node to copy various data structures representing the global state, smart contracts, transactions, and blocks from other blockchain nodes. Next, the node should rebuild and validate all the transactions from the genesis to verify the global state. Any errors, such as failed data transfer, need to be resolved by requesting further data. Finally, reconfigure the node to accept new transactions."^^rdfs:Literal ;
          rdfs:label "Node Sync" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EstablishGenesisBandara2020
:EstablishGenesisBandara2020 rdf:type owl:NamedIndividual ,
                   :EstablishGenesis ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :benefitsFrom :SnapshottingBandara2020 ;
          :benefitsFrom :StateAggregationBandara2020 ;

          :hasCanonical :EstablishGenesisCanonical ;
          :ContextAndProblem "Concert application has a large number of states, and all of them need to be recreated on the target blockchain. The nonprofit has decided to spin up a new blockchain instance as the target and use ConcertCoin as the native asset. The list of accounts and states to be migrated is given in the snapshot. After the snapshot, states are marked as unusable using token burning. Relevant smart contracts are also redeployed. How to load states to the target blockchain?"^^rdfs:Literal ;
          :Solution "Use the snapshot of states from the source blockchain to set states on the target blockchain’s genesis block during its initialization. If a user cannot use an existing private key to prove its ownership of a state migrated to the target blockchain, a new key pair needs to be created. Thus, the first step is to get each user to create a new key pair and a corresponding account ID (accID) using the account creation algorithm of the target blockchain. Second, update the account ID in the snapshot file with accID. Next, create the genesis block configuration file (aka., genesis file) while including the accounts and states from the updated snapshot file. Then use the genesis file to initialize the target blockchain. Update the ID database on the BAL to reflect the new set of accIDs. Also, add a PoE entry that tracks the mapping between old and new account IDs to record how the new accounts came into existence."^^rdfs:Literal ;
          rdfs:label "Establish Genesis" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#HardForkBandara2020
:HardForkBandara2020 rdf:type owl:NamedIndividual ,
                   :HardFork ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :benefitsFrom :SnapshottingBandara2020 ;
          :benefitsFrom :StateAggregationBandara2020 ;

          :hasCanonical :HardForkCanonical ;
          :ContextAndProblem "Concert application has a large number of states, and all of them need to be recreated on the target blockchain. The nonprofit has chosen an existing private or consortium blockchain as the target. The list of accounts and states to be migrated is given in the snapshot. After the snapshot, states are marked as unusable using token burning. How to load states to the target blockchain?"^^rdfs:Literal ;
          :Solution "Use the states from the snapshot to change the global state on the target blockchain. If a user cannot use an existing private key to access the state migrated to the target blockchain, follow the first two steps to create a new account and update the snapshot file similar to the establish genesis pattern. Next, update the blockchain client software on all nodes of the target blockchain to include the snapshot file at a set block number (blockNo). Once the blockNo is reached, all blockchain nodes should append the states from the snapshot file into the ledger to update the global state. Due to the arbitrary addition of new states, blocks produced before and after the software update will be incompatible. Such a change in blockchain state transition rules is referred to as a hard fork [59]. Similar to the establish genesis pattern, update the ID database and add a PoE entry to reflect new account IDs."^^rdfs:Literal ;
          rdfs:label "Hard Fork" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#StateInitializationBandara2020
:StateInitializationBandara2020 rdf:type owl:NamedIndividual ,
                   :StateInitialization ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :benefitsFrom :SnapshottingBandara2020 ;
          :benefitsFrom :StateAggregationBandara2020 ;

          :hasCanonical :StateInitializationCanonical ;
          :ContextAndProblem "Concert application has a large number of states and smart contracts, and all of them need to be recreated on the target blockchain. The nonprofit has chosen an existing public blockchain as the target. The list of accounts, smart contracts, and states to be migrated is given in the snapshot or ID database. After the snapshot, states are marked as unusable using token burning. How to load states to the target blockchain?"^^rdfs:Literal ;
          :Solution "Create one state at a time on the target blockchain. If a user cannot use an existing private key to access the state migrated to the target blockchain, follow the first step to create a new account similar to the establish genesis pattern. Then get the user to sign a transaction with the state listed in the snapshot as the payload and new address (i.e., accID) on the target blockchain as the recipient. Then submit the signed transaction to the target blockchain to recreate the state. Similar to the establish genesis pattern, update the ID database, and add a PoE entry to reflect new account IDs. It is also desirable to include the snapshot file as a PoE entry, as it is not included in the target blockchain’s history compared to establish genesis and hard fork patterns."^^rdfs:Literal ;
          rdfs:label "State Initialization" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ExchangeTransferBandara2020
:ExchangeTransferBandara2020 rdf:type owl:NamedIndividual ,
                   :ExchangeTransfer ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :benefitsFrom :SnapshottingBandara2020 ;
          :benefitsFrom :StateAggregationBandara2020 ;

          :hasCanonical :ExchangeTransferCanonical ;
          :ContextAndProblem "Concert application has a large number of states, and all of them need to be recreated on the target blockchain. The nonprofit has chosen an existing public blockchain as the target and ConcertCoins are to be converted to its native assets. The list of states to be migrated can be found from the ID database. How to load states to the target blockchain?"^^rdfs:Literal ;
          :Solution "Use a cryptocurrency/token exchange to transfer the states. If a user cannot use an existing private key to access the state migrated to the target blockchain, follow the first step to create a new account similar to the establish genesis pattern. Then get the user to sign a transaction with both the state and new account ID (i.e., accID) on the target blockchain as the payload. Set the address of the exchange (excAddress) as the recipient. Then submit the signed transaction to transfer the state to exchange’s account on the source blockchain. This is similar to a sell order in financial markets. Once the exchange confirms that the state is transferred to its account, it will look for a matching buy order. Once a match is made, the exchange will transfer the state to the accID using its account in the target blockchain. Similar to the establish genesis pattern, finally update the ID database to reflect new account IDs."^^rdfs:Literal ;
          rdfs:label "Exchange Transfer" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TransactionReplayBandara2020
:TransactionReplayBandara2020 rdf:type owl:NamedIndividual ,
                   :TransactionReplay ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :benefitsFrom :SnapshottingBandara2020 ;
          :benefitsFrom :StateAggregationBandara2020 ;

          :hasCanonical :TransactionReplayCanonical ;
          :ContextAndProblem "Concert application has a large number of accounts, states, transactions, and smart contracts. All of which need to be recreated on the target blockchain while preserving the history of state changes. The initial state is already recreated on the target blockchain. List of transactions to be replayed can be found from the snapshot. How to recreate both the states and history on the target blockchain?"^^rdfs:Literal ;
          :Solution "Replay transactions from the source blockchain. When replaying transactions on the target blockchain, their causal relationships must be preserved, e.g., the order of transactions send/received by an account may need to be preserved to maintain consistency of a state. Therefore, first group related transactions in the snapshot file. If abstraction is acceptable, also aggregate the transactions in a group such that the final state is consistent. Third, concurrently replay each independent group of transactions on the target blockchain, while sequentially replaying all transactions within a group to preserve causal relationships. When the private keys or signature format of the source and target blockchains are different, transactions need to be signed again before replaying on the target blockchain. Address of the recipient also needs to be updated when the same addresses cannot be used across the blockchains. Then submit the signed transaction to the target blockchain. The transaction ID (txID) is likely to vary across blockchain instances, and also depends on nonce, sender and receiver addresses, and transaction fees. Hence, use the second last step to update the mapping between old and new txIDs on the ID database on the BAL. Finally, add a PoE entry to reflect new transactions IDs. If translations are aggregated, also include the snapshot file as a PoE entry, as it is not included in the target blockchain’s history."^^rdfs:Literal ;
          rdfs:label "Transaction Replay" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#VirtualMachineEmulationBandara2020
:VirtualMachineEmulationBandara2020 rdf:type owl:NamedIndividual ,
                   :VirtualMachineEmulation ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :SnapshottingBandara2020 ;

          :hasCanonical :VirtualMachineEmulationCanonical ;
          :ContextAndProblem "Concert application uses a set of smart contracts and embedded states which need to be usable on the target blockchain. The target blockchain platform could run/emulate the Virtual Machine (VM) used to execute smart contracts. The list of smart contracts and their states to be migrated is given in the snapshot. After the snapshot, smart contracts are marked as unusable using token burning. How to run smart contracts written for one blockchain platform on another?"^^rdfs:Literal ;
          :Solution "Use the process outlined in Fig. 12 to reuse the smart contract execution environ- ment (aka., VM, sandbox, or container) on the target blockchain. First, copy the VM from the source blockchain. Second, integrate the VM into the target blockchain. Third, if the VM does not hold the smart contract code, redeploy the smart contracts on the target blockchain using the state initialization pattern. Fourth, use the same pattern to set the states of the deployed smart contracts. Smart contract code and their states can be found from the snapshot. Sixth, update the mapping between old and new smart contract addresses on the ID database, as smart contract addresses vary across blockchain instances, and could also depend on the address that deployed the smart contract, transaction sequence number, among others. Finally, it is also de- sirable to include the snapshot file and mapping between old and new smart contract addresses as a PoE entry, as they are not included in the target blockchain’s history."^^rdfs:Literal ;
          rdfs:label "Virtual Machine Emulation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SmartContractTranslationBandara2020
:SmartContractTranslationBandara2020 rdf:type owl:NamedIndividual ,
                   :SmartContractTranslation ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :SnapshottingBandara2020 ;

          :hasCanonical :SmartContractTranslationCanonical ;
          :ContextAndProblem "Concert application uses a set of smart contracts and associated states which need to be usable on the target blockchain. The smart contract language of the target blockchain is not interoperable. The list of smart contracts and their states to be migrated is given in the snapshot. How to run smart contracts written for one blockchain platform on another?"^^rdfs:Literal ;
          :Solution "Translate and deploy a smart contract on the target blockchain. First, verify that the respective source code produces the exact smart contract deployed on the source blockchain. Second, translate the smart contract to the new language. Then, test the functional correctness and security of the translated contract. Fourth, deploy the new smart contract to the target blockchain using the state initialization pattern. Fifth, use the same pattern to set the states of the deployed contract, as per the state recorded on the snapshot. Next, update the mapping between old and new smart contract addresses on the ID database, as smart contract addresses vary across different blockchain instances and could also depend on the address that deployed the smart contract, transaction sequence number, among others. Finally, it is also desirable to include the original and translated code, snapshot file, and mapping between old and new smart contract addresses as a PoE entry, as they are not included in the target blockchain’s history."^^rdfs:Literal ;
          rdfs:label "Smart Contract Translation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#BlockchainSecurityPatternForBigDataEcosystemsMoreno2019
:BlockchainSecurityPatternForBigDataEcosystemsMoreno2019 rdf:type owl:NamedIndividual ,
                   :BlockchainSecurityPatternForBigDataEcosystems ,
                   :PaperBased ,
                   :BigData ,
                   :SmartContractEnabledBlockchains ;
          :requires :Unknown ;
          :benefitsFrom :Unknown ;

          :hasCanonical :BlockchainSecurityPatternForBigDataEcosystemsCanonical ;
          :ContextAndProblem "Usually Data lakes are chaotic; they are a store where all the data of a company is accumulated without any kind of structure or rules to use it. For that reason, some people have started to call it Data swamps [12]. This problem can lead to a decrease of the value of the data. The Blockchain security pattern for Big Data Ecosystem tries to improve the traceability and integrity of the data stored in this kind of systems. In a nutshell, this security pattern will help in the implementation of a security solution to tackle a vulnerability of a Big Data ecosystem: huge amount of data can lead to a loss of control of the data and the operations that are performed on them, which can cause a loss of confidence in them."^^rdfs:Literal ;
          :Solution "The solution is based on the incorporation of a Blockchain layer that uses the same nodes utilized by the Big Data ecosystems. This layer will act as distributed ledger system that registers all the operations performed over the data stored. In the following subsection, our solution is explained in more detail. The Blockchain security pattern for Big Data ecosystems uses the elements of the SRA as a way to facilitate its implementation in a real scenario. More specifically, this pattern tries to improve the security of the Collector (in the BDAP component) which is implemented by the elements of the BDFP component."^^rdfs:Literal ;
          rdfs:label "Blockchain Security Pattern for Big Data Ecosystems" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ProxyMarchesi2020
:ProxyMarchesi2020 rdf:type owl:NamedIndividual ,
                   :ProxyContract ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :benefitsFrom :DataContractMarchesi2020 ;

          :hasCanonical :ProxyContractCanonical ;
          :ContextAndProblem "SCs are immutable. If a SC must be changed due to a bug or a needed extension, you must deploy a new contract, and also update all SCs making direct calls to the old SC, thus deploying also new versions of these. This can be very expensive."^^rdfs:Literal ;
          :Solution "Use Proxy delegate pattern. Proxy patterns are a set of SCs working together to facilitate upgrading of SCs, despite their intrinsic immutability. A Proxy holds the addresses of referred SCs, in its state variables, which can be changed. In this way, only the references to the new SC must be updated."^^rdfs:Literal ;
          rdfs:label "Proxy" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DataContractMarchesi2020
:DataContractMarchesi2020 rdf:type owl:NamedIndividual ,
                   :DataContract ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :DataContractCanonical ;
          :ContextAndProblem "When a SC holding a significant amount of data must be updated, also all its data must be copied to the newly deployed SC, consuming a lot of gas."^^rdfs:Literal ;
          :Solution "Keep the data in a separate SC, accessed by one or more SC, using the data and holding the processing logic. If this logic must be updated, the data remain in the Data Contract. This pattern usually is included also in the implementations of the Proxy pattern."^^rdfs:Literal ;
          rdfs:label "Data contract" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EventLogMarchesi2020
:EventLogMarchesi2020 rdf:type owl:NamedIndividual ,
                   :EventLog ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :EventLogCanonical ;
          :ContextAndProblem "Often events maintain important information about the system, which must be later used by the external system interacting with the blockchain. Storing this information in the blockchain can be very expensive, if the number of events is high."^^rdfs:Literal ;
          :Solution "If past events data are needed by the external system, but not by SCs, let the external system directly access the Event Log in the blockchain. Note that this Log is not accessible by SCs, and that if the event happened far in time, the time to retrieve it may be long."^^rdfs:Literal ;
          rdfs:label "Event log" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#LimitStorageMarchesi2020
:LimitStorageMarchesi2020 rdf:type owl:NamedIndividual ,
                   :LimitStorage ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :LimitStorageCanonical ;
          :ContextAndProblem "Storage is by far the most expensive kind of memory, so its usage should be minimized."^^rdfs:Literal ;
          :Solution "Limit data stored in the blockchain, always use memory for non-permanent data. Also, limit changes in storage: when executing functions, save the intermediate results in memory or stack and update the storage only at the end of all computations."^^rdfs:Literal ;
          rdfs:label "Limit storage" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PackingVariablesMarchesi2020
:PackingVariablesMarchesi2020 rdf:type owl:NamedIndividual ,
                   :PackingVariables ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :PackingVariablesCanonical ;
          :ContextAndProblem "In Ethereum, the minimum unit of memory is a slot of 256 bits. You pay for an integer number of slots even if they are not full."^^rdfs:Literal ;
          :Solution "Pack the variables. When declaring storage variables, the packable ones, with the same data type, should be declared consecutively. In this way, the packing is done automatically by the Solidity compiler. (Note that this pattern does not work for Memory and Calldata memories, whose variables cannot be packed.)"^^rdfs:Literal ;
          rdfs:label "Packing variables" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PackingBooleansMarchesi2020
:PackingBooleansMarchesi2020 rdf:type owl:NamedIndividual ,
                   :PackingBooleans ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :PackingBooleansCanonical ;
          :ContextAndProblem "In Solidity, Boolean variables are stored as uint8 (unsigned integer of 8 bits). However, only 1 bit would be enough to store them. If you need up to 32 Booleans together, you can just follow the Packing Variables pattern. If you need more, you will use more slots than actually needed."^^rdfs:Literal ;
          :Solution "Pack Booleans in a single uint256 variable. To this purpose, create functions that pack and unpack the Booleans into and from a single variable. The cost of running these functions is cheaper than the cost of extra Storage."^^rdfs:Literal ;
          rdfs:label "Packing booleans" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#UintVsUint256Marchesi2020
:UintVsUint256Marchesi2020 rdf:type owl:NamedIndividual ,
                   :UintVsUint256 ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :relatedTo :UintVsUint256Marchesi2020 ;

          :hasCanonical :UintVsUint256Canonical ;
          :ContextAndProblem "The EVM run on 256 bits at a time, thus using an uint* (unsigned integers smaller than 256 bits), it will first be converted to uint256 and it costs extra gas."^^rdfs:Literal ;
          :Solution "Use unsigned integers smaller or equal than 128 bits when packing more variables in one slot (see Variables Packing pattern). If not, it is better to use uint256 variables."^^rdfs:Literal ;
          rdfs:label "Uint* vs Uint256" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MappingVsArrayMarchesi2020
:MappingVsArrayMarchesi2020 rdf:type owl:NamedIndividual ,
                   :MappingVsArray ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :MappingVsArrayCanonical ;
          :ContextAndProblem "Solidity provides only two data types to represents list of data: arrays and maps. Mappings are cheaper, while arrays are packable and iterable."^^rdfs:Literal ;
          :Solution "In order to save gas, it is recommended to use mappings to manage lists of data, unless there is a need to iterate or it is possible to pack data types. This is useful both for Storage and Memory. You can manage an ordered list with a mapping using an integer index as a key."^^rdfs:Literal ;
          rdfs:label "Mapping vs Array" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#FixedSizeMarchesi2020
:FixedSizeMarchesi2020 rdf:type owl:NamedIndividual ,
                   :FixedSize ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :FixedSizeCanonical ;
          :ContextAndProblem "In Solidity, any fixed size variable is cheaper than variable size."^^rdfs:Literal ;
          :Solution "Whenever it is possible to set an upper bound on the size of an array, use a fixed size array instead of a dynamic one."^^rdfs:Literal ;
          rdfs:label "Fixed size" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DefaultValueMarchesi2020
:DefaultValueMarchesi2020 rdf:type owl:NamedIndividual ,
                   :DefaultValue ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :DefaultValueCanonical ;
          :ContextAndProblem "It is good software engineering practice to initialize all variables when they are created. However, this costs gas in Ethereum."^^rdfs:Literal ;
          :Solution "In Solidity, all variables are set to zeroes by default. So, do not explicitly initialize a variable with its default value if it is zero."^^rdfs:Literal ;
          rdfs:label "Default value" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MinimizeOnChainDataMarchesi2020
:MinimizeOnChainDataMarchesi2020 rdf:type owl:NamedIndividual ,
                   :MinimizeOnChainData ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :MinimizeOnChainDataCanonical ;
          :ContextAndProblem "The gas costs of Storage are very high, and much higher than the cost of Memory."^^rdfs:Literal ;
          :Solution "Minimize on-chain data. The less data you put on-chain in Storage variables, the less your gas costs. Store on-chain only critical data for the SC and keep all possible data off-chain."^^rdfs:Literal ;
          rdfs:label "Minimize on-chain data" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ExplicitelyMarkExternalFunctionMarchesi2020
:ExplicitelyMarkExternalFunctionMarchesi2020 rdf:type owl:NamedIndividual ,
                   :ExplicitelyMarkExternalFunction ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :ExplicitelyMarkExternalFunctionCanonical ;
          :ContextAndProblem "The input parameters of public functions are copied to memory automatically, and this costs gas."^^rdfs:Literal ;
          :Solution "The input parameters of external functions are read right from Calldata memory. Therefore, explicitly mark as external functions called only externally."^^rdfs:Literal ;
          rdfs:label "Explicitely mark external function" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#LimitExternalCallsMarchesi2020
:LimitExternalCallsMarchesi2020 rdf:type owl:NamedIndividual ,
                   :LimitExternalCalls ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :LimitExternalCallsCanonical ;
          :ContextAndProblem "Every call to an external SC is rather expensive, and even potentially unsafe."^^rdfs:Literal ;
          :Solution "Limit external calls. In Solidity, differently from other programming languages, it is better to call a single, multi-purpose function with many parameters and get back the requested results, rather than making different calls for each data."^^rdfs:Literal ;
          rdfs:label "Limit external calls" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#InternalFunctionCallsMarchesi2020
:InternalFunctionCallsMarchesi2020 rdf:type owl:NamedIndividual ,
                   :InternalFunctionCalls ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :InternalFunctionCallsCanonical ;
          :ContextAndProblem "Calling public functions is more expensive than calling internal functions, because in the former case all the parameters are copied into Memory."^^rdfs:Literal ;
          :Solution "Whenever possible, prefer internal function calls, where the parameters are passed as references."^^rdfs:Literal ;
          rdfs:label "Internal function calls" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#FewerFunctionsMarchesi2020
:FewerFunctionsMarchesi2020 rdf:type owl:NamedIndividual ,
                   :FewerFunctions ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :FewerFunctionsCanonical ;
          :ContextAndProblem "Implementing a function in an Ethereum SC costs gas."^^rdfs:Literal ;
          :Solution "In general, keep in mind that implementing a SC with many small functions is expensive. However, having too big functions complicates the testing and potentially compromises the security. So, try to have fewer functions, but not too few, balancing the function number with their complexity."^^rdfs:Literal ;
          rdfs:label "Fewer functions" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#UseLibrariesMarchesi2020
:UseLibrariesMarchesi2020 rdf:type owl:NamedIndividual ,
                   :UseLibraries ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :UseLibrariesCanonical ;
          :ContextAndProblem "If a SC tends to perform all its tasks by its own code, it will grow and be very expensive."^^rdfs:Literal ;
          :Solution "Use libraries. The bytecode of external libraries is not part of your SC, thus saving gas. However, calling them is costly and has security issues. Use libraries in a balanced way, for complex tasks."^^rdfs:Literal ;
          rdfs:label "Use libraries" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ShortCircuitMarchesi2020
:ShortCircuitMarchesi2020 rdf:type owl:NamedIndividual ,
                   :ShortCircuit ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :ShortCircuitCanonical ;
          :ContextAndProblem "Every single operation costs gas."^^rdfs:Literal ;
          :Solution "When using the logical operators, order the expressions to reduce the probability of evaluating the second expression. Remember that in the logical disjunction (OR, ||), if the first expression resolves to true, the second one will not be executed; or that in the logical disjunction (AND, &&), if the first expression is evaluated as false, the next one will not be evaluated."^^rdfs:Literal ;
          rdfs:label "Short circuit" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ShortConstantStringsMarchesi2020
:ShortConstantStringsMarchesi2020 rdf:type owl:NamedIndividual ,
                   :ShortConstantStrings ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :ShortConstantStringsCanonical ;
          :ContextAndProblem "Storing strings is costly."^^rdfs:Literal ;
          :Solution "Keep constant strings short. Be sure that constant strings fit 32 bytes. For example, it is possible to clarify an error using a string; these messages, however, are included in the bytecode, so they must be kept short to avoid wasting memory."^^rdfs:Literal ;
          rdfs:label "Short constant strings" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#LimitModifiersMarchesi2020
:LimitModifiersMarchesi2020 rdf:type owl:NamedIndividual ,
                   :LimitModifiers ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :LimitModifiersCanonical ;
          :ContextAndProblem "The code of modifiers is inlined inside the modified function, thus adding up size and costing gas."^^rdfs:Literal ;
          :Solution "Limit the modifiers. Internal functions are not inlined, but called as separate functions. They are slightly more expensive at run time, but save a lot of redundant bytecode in deployment, if used more than once."^^rdfs:Literal ;
          rdfs:label "Limit modifiers" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AvoidRedundantOperationsMarchesi2020
:AvoidRedundantOperationsMarchesi2020 rdf:type owl:NamedIndividual ,
                   :AvoidRedundantOperations ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :AvoidRedundantOperationsCanonical ;
          :ContextAndProblem "Every single operation costs gas."^^rdfs:Literal ;
          :Solution "Avoid redundant operations. For instance, avoid double checks; the use of SafeMath library prevents underflow and overflow, so there is no need to check for them."^^rdfs:Literal ;
          rdfs:label "Avoid redundant operations" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SingleLineSwapMarchesi2020
:SingleLineSwapMarchesi2020 rdf:type owl:NamedIndividual ,
                   :SingleLineSwap ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :SingleLineSwapCanonical ;
          :ContextAndProblem "Each assignment and defining variables costs gas."^^rdfs:Literal ;
          :Solution "Solidity allows to swap the values of two variables in one instruction. So, instead of the classical swap using an auxiliary variable, use: (a, b) = (b, a)"^^rdfs:Literal ;
          rdfs:label "Single-line swap" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#WriteValuesMarchesi2020
:WriteValuesMarchesi2020 rdf:type owl:NamedIndividual ,
                   :WriteValues ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :WriteValuesCanonical ;
          :ContextAndProblem "Every single operation costs gas."^^rdfs:Literal ;
          :Solution "Write values instead of computing them. If you already know the value of some data at compile time, write directly these values. Do not use Solidity functions to derive the value of the data during their initialization. Doing so, might lead to a less clear code, but it saves gas."^^rdfs:Literal ;
          rdfs:label "Write values" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#FreeingStorageMarchesi2020
:FreeingStorageMarchesi2020 rdf:type owl:NamedIndividual ,
                   :FreeingStorage ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :FreeingStorageCanonical ;
          :ContextAndProblem "Sometimes, Storage variables are not longer used. Is there a way to take advantage of this?"^^rdfs:Literal ;
          :Solution "To help keeping the size of the blockchain smaller, you get a gas refund every time you free the Storage. Therefore, it is convenient to delete the variables on the Storage, using the keyword delete, as soon as they are no longer necessary."^^rdfs:Literal ;
          rdfs:label "Freeing storage" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OptimizerMarchesi2020
:OptimizerMarchesi2020 rdf:type owl:NamedIndividual ,
                   :Optimizer ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :OptimizerCanonical ;
          :ContextAndProblem "Optimizing Solidity code to save gas in exhaustive way is difficult."^^rdfs:Literal ;
          :Solution "Always turn on the Solidity Optimizer. It is an option of all Solidity compilers, which performs all the optimizations that can be made by the compiler. However, it does not substitute the usage of the presented patterns, most of which need information that is not available to the compiler."^^rdfs:Literal ;
          rdfs:label "Optimizer" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ConfidentialAndPseudoAnonymousContractEnforcementSix2020
:ConfidentialAndPseudoAnonymousContractEnforcementSix2020 rdf:type owl:NamedIndividual ,
                   :ConfidentialAndPseudoAnonymousContractEnforcement ,
                   :PaperBased ,
                   :BPM ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :ConfidentialAndPseudoAnonymousContractEnforcementCanonical ;
          :ContextAndProblem "During past years, the different industries have been impacted by new and disruptive technologies. One of such technologies is smart contracts. One objective of the smart contracts is to translate legal contracts as code or help the legal contract by augmenting some of its clauses into machine-readable functions. The emergence of blockchain technologies has led to the creation of blockchain-based smart contracts, that has benefited from blockchain characteristics. When stored on-chain, data becomes tamper-resistant. Additionally, the utilization of smart contracts isn’t always possible for stakeholders due to concerns about the irreversibility of smart contracts in certain blockchain technologies. For example, creating GDPR compliant blockchains for storing personal data systems is still an open topic. Although not all smart contracts might deal with personal data, there are concerns over the leakage of organizations’ confidential data or their identities, even if data are encrypted. "^^rdfs:Literal ;
          :Solution "This pattern allows the execution of automatable legal contract clauses, where its execution states are stored in an on-chain smart-contract and the logic needed to enforce it wraps it off-chain. An engine completes this pattern by running a business process that corresponds to the legal contract."^^rdfs:Literal ;
          rdfs:label "Confidential and pseudo-anonymous contract enforcement" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SelfGeneratedTransactionsWessling2018
:SelfGeneratedTransactionsWessling2018 rdf:type owl:NamedIndividual ,
                   :SelfGeneratedTransactions ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :SelfGeneratedTransactionsCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "For directly interacting with an EDCC (Executable Distributed Code Contract) it is necessary&#10;that the interface description (Application Binary Interface, ABI) of the EDCC is publicly available. Furthermore, for understanding the specific actions carried out by a contract, the source code should be published as well. DApps structured with this pattern have the security advantage that the users keep their private keys on their device and are able to generate, sign and send transactions on their own."^^rdfs:Literal ;
          rdfs:label "Self-Generated Transactions" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SelfConfirmedTransactionsWessling2018
:SelfConfirmedTransactionsWessling2018 rdf:type owl:NamedIndividual ,
                   :SelfConfirmedTransactions ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :SelfConfirmedTransactionsCanonical ;
          :ContextAndProblem "Manually generating transactions can be hard or is not always feasible, especially when it is necessary to query the current state of the blockchain or to gather additional data, e.g., like the marketplace of CryptoKitties. This requires a certain trust in the DApp provider as transactions are generated but the implication of their execution is not always completely transparent (e.g., the geneScience contract of CryptoKitties without published source code or ABI)."^^rdfs:Literal ;
          :Solution "Transactions are not generated by the user but are triggered by the DApp website, presented to the user for further verification and then manually sent to the blockchain node. Thus, this pattern offers a trade-off between convenience and trust that is required in the DApp website providing the transaction details."^^rdfs:Literal ;
          rdfs:label "Self-Confirmed Transactions" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DelegatedTransactionsWessling2018
:DelegatedTransactionsWessling2018 rdf:type owl:NamedIndividual ,
                   :DelegatedTransactions ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :DelegatedTransactionsCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "DApp provider offers a website the users can interact with, not requiring a cryptobrowser or MetaMask plugin. The website communicates with the DApp backend logic via REST calls and encapsulates all blockchain-specific actions. This means the backend is responsible for interacting with the blockchain and is sending transactions on behalf of the user, who is not able to validate them."^^rdfs:Literal ;
          rdfs:label "Delegated Transactions" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MirrorLemieux2017
:MirrorLemieux2017 rdf:type owl:NamedIndividual ,
                   :OffChainDataStorage ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :OffChainDataStorageCanonical ;
          :ContextAndProblem "Many current and proposed applications of blockchain technology aim to address recordkeeping challenges, such as more efficient and secure processing of land title transfers, greater patient control over their sensitive health information, and more efficient recording of financial payments and settlements. All of the blockchain systems offer a new form of records generation use, storage and/or control."^^rdfs:Literal ;
          :Solution "The “mirror” system, the blockchain serves as a repository of “digital fingerprints”, or hashes, of the records. The original records, which may be born paper or digital, but now exist in digital form, are hashed. This produces a sort of digital fingerprint of the record. These hashes are anchored into the blockchain, with the blockchain being used as a mirror of the records, reflecting back their hashes."^^rdfs:Literal ;
          rdfs:label "Mirror" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DigitalRecordLemieux2017
:DigitalRecordLemieux2017 rdf:type owl:NamedIndividual ,
                   :DigitalRecord ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :DigitalRecordCanonical ;
          :ContextAndProblem "Many current and proposed applications of blockchain technology aim to address recordkeeping challenges, such as more efficient and secure processing of land title transfers, greater patient control over their sensitive health information, and more efficient recording of financial payments and settlements. All of the blockchain systems offer a new form of records generation use, storage and/or control."^^rdfs:Literal ;
          :Solution "Records are no longer just mirrored on chain, they are actively created on chain in the form of “smart contracts”. This marks a more fundamental departure from the traditional form of digital records creation and storage in centralized databases or cloud-based platforms. Typically, these smart contracts encode procedures that execute among a multi-stakeholder network as part of a work process flow. In these “digital records” systems, execution of the smart code results in an update to the distributed database of records, or ledger, implementing state change once the smart contract has completed."^^rdfs:Literal ;
          rdfs:label "Digital Record" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TokenizedLemieux2017
:TokenizedLemieux2017 rdf:type owl:NamedIndividual ,
                   :Tokenisation ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :TokenisationCanonical ;
          :ContextAndProblem "Many current and proposed applications of blockchain technology aim to address recordkeeping challenges, such as more efficient and secure processing of land title transfers, greater patient control over their sensitive health information, and more efficient recording of financial payments and settlements. All of the blockchain systems offer a new form of records generation use, storage and/or control."^^rdfs:Literal ;
          :Solution "With this type of system, not only are records captured on chain, but assets are represented and captured on chain. These assets can represent anything of value – currency, as in the original use case for the blockchain – Bitcoin land, fine wine, food, diamonds, artworks, etc. Readers may ask whether these assets are records. "^^rdfs:Literal ;
          rdfs:label "Tokenized" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PullPaymentWohrer2018
:PullPaymentWohrer2018 rdf:type owl:NamedIndividual ,
                   :PullPayment ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :PullPaymentCanonical ;
          :ContextAndProblem "A common task when coding smart contracts is to transfer funds. Unfortunately, there are several circumstances under which a transfer can fail. This is due to the fact that the implementation to send funds involves an external call, which basically hands over control to the called contract. Therefore, security considerations regarding external calls and re-entrancy attacks have to be considered. A re-entrancy attack describes the scenario where the called contract calls back the current contract, before the first invocation of the function containing the call, was finished. This can lead to an unwanted execution behaviour of functions."^^rdfs:Literal ;
          :Solution "Due to the possibility of deliberately sabotaging the transfer&#10;of funds by executing expensive operations in the fallback method, causing an “out of gas” (OOG) error, or manipulations involving re-entrancy attacks, a more favourable approach is to reverse the payment process (let users withdraw their funds themselves)."^^rdfs:Literal ;
          rdfs:label "Pull payment" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#StateMachineWohrer2018
:StateMachineWohrer2018 rdf:type owl:NamedIndividual ,
                   :StateMachine ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :StateMachineCanonical ;
          :ContextAndProblem "A state machine models the behaviour of a system based on its history and current inputs. Developers use this construct to break complex problems into simple states and state transitions. These are then used to represent and control the execution flow of a program."^^rdfs:Literal ;
          :Solution "State machines can also be applied in smart contracts. Many usage scenarios require a contract to have different behavioural stages, in which different functions can be called. When interacting with such a contract, a function call might end the current stage and initiate a change into a consecutive stage."^^rdfs:Literal ;
          rdfs:label "State machine" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#CommitAndRevealWohrer2018
:CommitAndRevealWohrer2018 rdf:type owl:NamedIndividual ,
                   :CommitAndReveal ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :CommitAndRevealCanonical ;
          :ContextAndProblem "A characteristic of blockchains is, that it is not possible to restrict anyone from reading contents of a transaction or transaction’s state. This transparency leads to problems, especially when contract participants compete with each other. All data and every transaction is publicly visible on the blockchain, but an application scenario requires that contract interactions, specifically submitted parameter values, are treated confidentially."^^rdfs:Literal ;
          :Solution "Apply a commitment scheme to ensure that a value submission is binding and concealed until a consolidation phase runs out, after which the value is revealed, and it is publicly verifiable that the value remained unchanged."^^rdfs:Literal ;
          rdfs:label "Commit and reveal" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OracleDataProviderWohrer2018
:OracleDataProviderWohrer2018 rdf:type owl:NamedIndividual ,
                   :Oracle ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :OracleCanonical ;
          :ContextAndProblem "Ethereum contracts run within their own ecosystem, where they communicate with each other, but external data can only enter the system through outside interaction via a transaction (by passing data to a method). This is a drawback, because many contract use cases depend on external knowledge outside the blockchain (e.g. price feeds). "^^rdfs:Literal ;
          :Solution "A solution to this problem is to utilize oracles with a connection to the outside world. The oracle service acts as a data carrier, where the interaction between an oracle service and a smart contract is asynchronous. First, a transaction invokes a function of a smart contract that contains an instruction to send a request to an oracle. Then, according to the parameters of such a request, the oracle will fetch a result and return it by executing a callback function placed in the primary contract."^^rdfs:Literal ;
          rdfs:label "Oracle (Data Provider)" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OwnershipWohrer2018
:OwnershipWohrer2018 rdf:type owl:NamedIndividual ,
                   :Ownership ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :OwnershipCanonical ;
          :ContextAndProblem "By default any party can call a contract method, but it must be ensured that sensitive contract methods can only be executed by the owner of a contract."^^rdfs:Literal ;
          :Solution "Store the contract creator’s address as owner of a contract and restrict method execution dependent on the callers address."^^rdfs:Literal ;
          rdfs:label "Ownership" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AccessRestrictionWohrer2018
:AccessRestrictionWohrer2018 rdf:type owl:NamedIndividual ,
                   :AccessRestriction ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :AccessRestrictionCanonical ;
          :ContextAndProblem "By default a contract method is executed without any preconditions being checked, but it is desired that the execution is only allowed if certain requirements are met."^^rdfs:Literal ;
          :Solution "Since there is no built in mechanism to control execution&#10;privileges, a common pattern is to restrict function execution. It is often required that functions should only be executed based on the presence of certain prerequisites. These can refer to different categories, such as temporal conditions, caller and transaction info, or other requirements that need to be checked prior a function execution. Listing"^^rdfs:Literal ;
          rdfs:label "Access Restriction" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MortalWohrer2018
:MortalWohrer2018 rdf:type owl:NamedIndividual ,
                   :Mortal ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :MortalCanonical ;
          :ContextAndProblem "A contract is defined by its creator, but the execution, and subsequently the services it offers are provided by the Ethereum network itself. Thus, a contract will exist and be executable as long as the whole network exists, and will only disappear if it was programmed to self destruct."^^rdfs:Literal ;
          :Solution "Use a selfdestruct call within a method that does a preliminary authorization check of the invoking party."^^rdfs:Literal ;
          rdfs:label "Mortal" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AutomaticDeprecationWohrer2018
:AutomaticDeprecationWohrer2018 rdf:type owl:NamedIndividual ,
                   :AutomaticDeprecation ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :AutomaticDeprecationCanonical ;
          :ContextAndProblem "A usage scenario requires a temporal constraint defining a point in time when functions become deprecated."^^rdfs:Literal ;
          :Solution "Define an expiration time and apply modifiers in function definitions to disable function execution if the expiration date has been reached."^^rdfs:Literal ;
          rdfs:label "Automatic Deprecation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DataSegregationWohrer2018
:DataSegregationWohrer2018 rdf:type owl:NamedIndividual ,
                   :DataContract ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :DataContractCanonical ;
          :ContextAndProblem "Contract data and its logic are usually kept in the same contract, leading to a closely entangled coupling. Once a contract is replaced by a newer version, the former contract data must be migrated to the new contract version."^^rdfs:Literal ;
          :Solution "The data segregation pattern separates contract logic from its underlying data. Segregation promotes the separation of concerns and mimics a layered design (e.g. logic layer, data layer). Following this principle avoids costly data migrations when code functionality changes. Meaning a new contract version would not have to recreate all of the existing data contained in the previous contract."^^rdfs:Literal ;
          rdfs:label "Data Segregation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SatelliteWohrer2018
:SatelliteWohrer2018 rdf:type owl:NamedIndividual ,
                   :Satellite ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :SatelliteCanonical ;
          :ContextAndProblem "Contracts are immutable. Changing contract functionality requires the deployment of a new contract."^^rdfs:Literal ;
          :Solution "The satellite pattern allows to modify and replace contract functionality. This is achieved through the creation of separate satellite contracts that encapsulate certain contract functional- ity. The addresses of these satellite contracts are stored in a base contract. This contract can then can call out to the satellite contracts when it needs to reference certain functionalities, by using the stored address pointers. If this pattern is properly implemented, modifying functionality is as simple as creating new satellite contracts and changing the corresponding satellite addresses."^^rdfs:Literal ;
          rdfs:label "Satellite" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractRegisterWohrer2018
:ContractRegisterWohrer2018 rdf:type owl:NamedIndividual ,
                   :ContractRegistry ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :ContractRegistryCanonical ;
          :ContextAndProblem "Contract participants must be referred to the latest contract version."^^rdfs:Literal ;
          :Solution "The register pattern is an approach to handle the update process of a contract. The pattern keeps track of different versions (addresses) of a contract and points on request to the latest one. In conclusion, before interacting with a contract, a user would always have to query the register for the contract’s latest address. When following this update approach, it is also important to determine how to handle existing contract data, when an old contract version is replaced. An alternative solution to point to the latest contract address would be to utilize the Ethereum Name Service (ENS). It is a register that enables a secure and decentralised way to resolve human-readable names, like ’mycontract.eth’, into machine-readable identifiers, including Ethereum addresses."^^rdfs:Literal ;
          rdfs:label "Contract register" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractRelayWohrer2018
:ContractRelayWohrer2018 rdf:type owl:NamedIndividual ,
                   :ProxyContract ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :ProxyContractCanonical ;
          :ContextAndProblem "Contract participants must be referred to the latest contract version."^^rdfs:Literal ;
          :Solution "A relay is another approach to handle the update process of a contract. The relay pattern provides a method to update a contract to a newer version while keeping the old contract address. This is achieved by using a kind of proxy contract that forwards calls and data to the latest version of the contract."^^rdfs:Literal ;
          rdfs:label "Contract Relay" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MultipleBlockchainsSchinle2020
:MultipleBlockchainsSchinle2020 rdf:type owl:NamedIndividual ,
                   :MultipleBlockchains ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :MultipleBlockchainsCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "For each product a separate Blockchain is set up between the respective supply chain organizations. All product data is stored in the Blockchain and shared between the participating organizations. No competitor can access any data by himself. This architecture comes with the properties of a standard permissioned Blockchain system with the additional effort of setting up separate Blockchain systems per product."^^rdfs:Literal ;
          rdfs:label "Multiple Blockchains" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OnChainEncryptionSchinle2020
:OnChainEncryptionSchinle2020 rdf:type owl:NamedIndividual ,
                   :OnChainEncryption ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;
          :fromPattern :EncryptingOnChainDataXu2018 ;

          :hasCanonical :OnChainEncryptionCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "All data in the Blockchain-based system is symmetrically encrypted on-chain on a single permissioned Blockchain to preserve data privacy. Every event or asset is encrypted with a separate cryptographic key, which is stored off-chain in a distributed and decentralized database with all organizations that are part of the supply chain of a product. Only these organizations have access to the keys and therefore can decrypt or encrypt the corresponding data. "^^rdfs:Literal ;
          rdfs:label "On-chain encryption" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#HashTimestampingSchinle2020
:HashTimestampingSchinle2020 rdf:type owl:NamedIndividual ,
                   :HashTimestamping ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :HashTimestampingCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "A Blockchain connects all members of different supply chains. For each product a distributed and decentralized off-chain database is created which contains all relevant product information. Each data point is linked in the Blockchain with it’s hash value. This ensures that the organizations in possession of the data can confirm that it is not tampered. "^^rdfs:Literal ;
          rdfs:label "Hash timestamping" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PullPaymentWohrer2020
:PullPaymentWohrer2020 rdf:type owl:NamedIndividual ,
                   :PullPayment ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :PullPaymentWohrer2018 ;

          :hasCanonical :PullPaymentCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "As a send operation can fail, let the receiver withdraw the payment."^^rdfs:Literal ;
          rdfs:label "Pull payment" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#StateMachineWohrer2020
:StateMachineWohrer2020 rdf:type owl:NamedIndividual ,
                   :StateMachine ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :StateMachineWohrer2018 ;

          :hasCanonical :StateMachineCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When different contract stages are needed, these are modeled and represented by a state machine."^^rdfs:Literal ;
          rdfs:label "State machine" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#CommitAndRevealWohrer2020
:CommitAndRevealWohrer2020 rdf:type owl:NamedIndividual ,
                   :CommitAndReveal ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :CommitAndRevealWohrer2018 ;

          :hasCanonical :CommitAndRevealCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "As blockchain data is public, a commitment scheme ensures confidentiality of contract interactions."^^rdfs:Literal ;
          rdfs:label "Commit and reveal" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OracleDataProviderWohrer2020
:OracleDataProviderWohrer2020 rdf:type owl:NamedIndividual ,
                   :Oracle ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :OracleDataProviderWohrer2018 ;

          :hasCanonical :OracleCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When knowledge outside the blockchain is required, an oracle pushes information into the network."^^rdfs:Literal ;
          rdfs:label "Oracle (Data Provider)" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OwnershipWohrer2020
:OwnershipWohrer2020 rdf:type owl:NamedIndividual ,
                   :Ownership ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :OwnershipWohrer2018 ;

          :hasCanonical :OwnershipCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "As anyone can call a contract method, restrict the execution to the contract owner’s address."^^rdfs:Literal ;
          rdfs:label "Ownership" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AccessRestrictionWohrer2020
:AccessRestrictionWohrer2020 rdf:type owl:NamedIndividual ,
                   :AccessRestriction ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :AccessRestrictionWohrer2018 ;

          :hasCanonical :AccessRestrictionCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When function execution checkups are needed, these are handled by generally applicable modifiers"^^rdfs:Literal ;
          rdfs:label "Access Restriction" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MortalWohrer2020
:MortalWohrer2020 rdf:type owl:NamedIndividual ,
                   :Mortal ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :MortalWohrer2018 ;

          :hasCanonical :MortalCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Since deployed contracts do not expire, self-destruction with a preliminary authorization check is used."^^rdfs:Literal ;
          rdfs:label "Mortal" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AutomaticDeprecationWohrer2020
:AutomaticDeprecationWohrer2020 rdf:type owl:NamedIndividual ,
                   :AutomaticDeprecation ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :AutomaticDeprecationWohrer2018 ;

          :hasCanonical :AutomaticDeprecationCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When functions shall become deprecated, apply function modifiers to disable their future execution."^^rdfs:Literal ;
          rdfs:label "Automatic Deprecation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DataSegregationWohrer2020
:DataSegregationWohrer2020 rdf:type owl:NamedIndividual ,
                   :DataContract ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :DataSegregationWohrer2018 ;

          :hasCanonical :DataContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "As data and logic usually reside in the same contract, avoid data migration on updates by decoupling."^^rdfs:Literal ;
          rdfs:label "Data Segregation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SatelliteWohrer2020
:SatelliteWohrer2020 rdf:type owl:NamedIndividual ,
                   :Satellite ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :SatelliteWohrer2018 ;

          :hasCanonical :SatelliteCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "As contracts are immutable, functions that are likely to change are outsourced into separate contracts."^^rdfs:Literal ;
          rdfs:label "Satellite" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractRegisterWohrer2020
:ContractRegisterWohrer2020 rdf:type owl:NamedIndividual ,
                   :ContractRegistry ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :ContractRegisterWohrer2018 ;

          :hasCanonical :ContractRegistryCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When the latest contract version is unknown, participants pro-actively query a register."^^rdfs:Literal ;
          rdfs:label "Contract register" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractRelayWohrer2020
:ContractRelayWohrer2020 rdf:type owl:NamedIndividual ,
                   :ProxyContract ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :ContractRelayWohrer2018 ;

          :hasCanonical :ProxyContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When the latest contract version is unknown, participants interact with a proxy contract."^^rdfs:Literal ;
          rdfs:label "Contract Relay" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ChecksEffectsInteractionWohrer2020
:ChecksEffectsInteractionWohrer2020 rdf:type owl:NamedIndividual ,
                   :CheckEffectInteraction ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :ChecksEffectsInteractionWohrer2018 ;

          :hasCanonical :CheckEffectInteractionCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "As calls to other contracts hand over control, avoid security issues by a functional code order."^^rdfs:Literal ;
          rdfs:label "Checks-Effects-Interaction" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EmergencyStopWohrer2020
:EmergencyStopWohrer2020 rdf:type owl:NamedIndividual ,
                   :EmergencyStop ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :EmergencyStopWohrer2018 ;

          :hasCanonical :EmergencyStopCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Since contracts are executed autonomously, sensitive functions include a halt in the case of bugs."^^rdfs:Literal ;
          rdfs:label "Emergency Stop" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SpeedBumpWohrer2020
:SpeedBumpWohrer2020 rdf:type owl:NamedIndividual ,
                   :SpeedBump ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :SpeedBumpWohrer2018 ;

          :hasCanonical :SpeedBumpCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When task execution by a huge number of users is unwanted, prolong completion for counter measures."^^rdfs:Literal ;
          rdfs:label "Speed Bump" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#RateLimitWohrer2020
:RateLimitWohrer2020 rdf:type owl:NamedIndividual ,
                   :RateLimit ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :RateLimitWohrer2018 ;

          :hasCanonical :RateLimitCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When a request rush on a task is not desired, regulate how often a task can be executed within a period."^^rdfs:Literal ;
          rdfs:label "Rate Limit" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MutexWohrer2020
:MutexWohrer2020 rdf:type owl:NamedIndividual ,
                   :Mutex ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :MutexWohrer2018 ;

          :hasCanonical :MutexCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "As re-entrancy attacks can manipulate contract state, a mutex hinders external calls from re-entering."^^rdfs:Literal ;
          rdfs:label "Mutex" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#BalanceLimitWohrer2020
:BalanceLimitWohrer2020 rdf:type owl:NamedIndividual ,
                   :ContractBalanceLimit ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :fromPattern :BalanceLimitWohrer2018 ;

          :hasCanonical :ContractBalanceLimitCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "There is always a risk that a contract gets compromised, thus limit the maximum amount of funds held."^^rdfs:Literal ;
          rdfs:label "Balance Limit" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OnChainAndOffChainLu2019
:OnChainAndOffChainLu2019 rdf:type owl:NamedIndividual ,
                   :OffChainDataStorage ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :OffChainDataStorageCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "To address the issues of blockchain storage capability limitation and data privacy, an on-chain and off-chain service is proposed to store the critical data which is required to be immutable on-chain while keep all the data off-chain to enhance the data reading efficiency."^^rdfs:Literal ;
          rdfs:label "On-chain and off-chain" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DataEncryptionLu2019
:DataEncryptionLu2019 rdf:type owl:NamedIndividual ,
                   :OnChainEncryption ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :OnChainEncryptionCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "To preserve the privacy of the involved participants, we provide a data encryption service that encrypts on-chain data to ensure confidentiality of the data stored on blockchain. Users first encrypt the data item using the secret key and then store it on blockchain. The blockchain participants who have the secret key are allowed to access the transaction and decrypt the information."^^rdfs:Literal ;
          rdfs:label "Data Encryption" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#HashIntegrityLu2019
:HashIntegrityLu2019 rdf:type owl:NamedIndividual ,
                   :OffChainDataStorage ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :OffChainDataStorageCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "The hash integrity service focuses on how to use blockchain to ensure the integrity of large amounts of data. Hashing is applied to guarantee the integrity of arbitrarily large datasets which may not fit directly on the blockchain. The service&#10;stores the hash of the raw data on blockchain to achieve data integrity of the raw data for the participants of the blockchain network that lack trust for each other. The integrity of the raw data can be checked using the on-chain hash value."^^rdfs:Literal ;
          rdfs:label "Hash integrity" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MultipleAuthoritiesLu2019
:MultipleAuthoritiesLu2019 rdf:type owl:NamedIndividual ,
                   :MultipleAuthorization ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :MultipleAuthorizationCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "The multiple authorities service focuses on activities in blockchain-based applications (i.e. transactions) that need to be authorised by multiple blockchain addresses. Users can predefine a group of blockchain addresses which can authorise a transaction (i.e. calling a function in the smart contract) and set the minimal number of authorisations for transaction approval."^^rdfs:Literal ;
          rdfs:label "Multiple Authorities" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DynamicBindingLu2019
:DynamicBindingLu2019 rdf:type owl:NamedIndividual ,
                   :DynamicBinding ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :DynamicBindingCanonical ;
          :ContextAndProblem "In blockchain applications, some activities need to be approved by one or more participants who are unknown when a first transaction is submitted to blockchain. The authority who can authorise to a given activity is unknown when the correspond- ing smart contract is deployed, or the corresponding trans- action is submitted to the blockchain."^^rdfs:Literal ;
          :Solution "The dynamic binding service supports dynamic association with an address of a participant which is not defined in the respective transaction or smart contract. An off-chain secret is used to enable a dynamic authorisa-&#10;tion when the participant approving a transaction is unknown beforehand. Users need to provide an off-chain secret and select the corresponding function in the smart contract. The service modifies the function code by adding hash secret code and generates the updated smart contract. There is no need for a special protocol to exchange the secret. The secret can be exchanged in any ways off-chain."^^rdfs:Literal ;
          rdfs:label "Dynamic Binding" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EmbeddedPermissionLu2019
:EmbeddedPermissionLu2019 rdf:type owl:NamedIndividual ,
                   :EmbeddedPermission ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :EmbeddedPermissionCanonical ;
          :ContextAndProblem "All the smart contracts running on blockchain can be accessed and called by all the participants and other smart contracts by default. A smart contract by default has no owner, which means that the author of the smart contract has no special privilege on the smart contract once the smart contract is deployed."^^rdfs:Literal ;
          :Solution "The embedded permission service restricts access to the invocation of the functions defined in the smart contracts. Users can identify the authorities for the selected function in the smart contract by providing the authority addresses. The service adds permission control code to the smart contract function to check permission for every caller based on the blockchain address of the caller, which is done before executing the function logic."^^rdfs:Literal ;
          rdfs:label "Embedded permission" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#CheckEffectInteractionMarchesi2020
:CheckEffectInteractionMarchesi2020 rdf:type owl:NamedIndividual ,
                   :CheckEffectInteraction ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :ChecksEffectsInteractionWohrer2018 ;

          :hasCanonical :CheckEffectInteractionCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When performing a function in a SC: first, check all the preconditions, then apply the effects to the contract's state, and finally interact with other contracts. Never alter this sequence."^^rdfs:Literal ;
          rdfs:label "Check Effect Interaction" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ProxyDelegateDecoratorMarchesi2020
:ProxyDelegateDecoratorMarchesi2020 rdf:type owl:NamedIndividual ,
                   :ProxyContract ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :Unknown ;
          :fromPattern :Unknown ;
          :fromPattern :ProxyZhang2017 ;
          :fromPattern :ContractFacadeLiu2018 ;
          :fromPattern :ProxyMarchesi2020 ;

          :hasCanonical :ProxyContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Proxy patterns are a set of SCs working together to facilitate upgrading of SCs, despite their intrinsic immutability. A Proxy is used to refer to another SC, whose address can be changed. This approach also ensures that blockchain resources are used sparingly, thus saving GAS."^^rdfs:Literal ;
          rdfs:label "Proxy Delegate / Decorator" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AuthorizationMarchesi2020
:AuthorizationMarchesi2020 rdf:type owl:NamedIndividual ,
                   :EmbeddedPermission ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :AuthorizationBartoletti2017 ;

          :hasCanonical :EmbeddedPermissionCanonical ;
          :ContextAndProblem "Since SCs are publicly accessible to all blockchain participants, it is critical to restrict authorizations to perform specific tasks. Specifically, for each contract method, developers must specify the subset of participants who can call it. Contracts usually define at least one contract owner, which is the only entity authorised to call critical methods."^^rdfs:Literal ;
          :Solution "Restrict the execution of critical methods to specific users. This is accomplished using mappings of addresses, and is typically checked using modifiers."^^rdfs:Literal ;
          rdfs:label "Authorization" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OwnershipMarchesi2020
:OwnershipMarchesi2020 rdf:type owl:NamedIndividual ,
                   :Ownership ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :OwnershipCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Specify the contract owner, which is responsible for contract management and has special permissions, e.g. it is the only address authorized to call critical methods. This patter can be seen as a special instance of the authorization pattern."^^rdfs:Literal ;
          rdfs:label "Ownership" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OracleMarchesi2020
:OracleMarchesi2020 rdf:type owl:NamedIndividual ,
                   :Oracle ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :OracleBartoletti2017 ;
          :fromPattern :OracleXu2018 ;

          :hasCanonical :OracleCanonical ;
          :ContextAndProblem "A smart contract is by nature isolated, and cannot acquire information directly. This is due to the fact that network nodes must agree on the state of transactions. To accomplish this, nodes should evaluate only static data. On the contrary, the outside world, for instance a website API, could provide different responses to the same query performed by different network nodes, breaking blockchain consensus."^^rdfs:Literal ;
          :Solution "An oracle is a SC providing data from outside the blockchain, which are in turn fed to the oracle by a trusted source. Here the security risk lies in how actually the source can be trusted."^^rdfs:Literal ;
          rdfs:label "Oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ReverseOracleMarchesi2020
:ReverseOracleMarchesi2020 rdf:type owl:NamedIndividual ,
                   :ReverseOracle ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :ReverseOracleXu2018 ;

          :hasCanonical :ReverseOracleCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "A reverse oracle is a SC providing data to be read by off-chain components for checking specific conditions."^^rdfs:Literal ;
          rdfs:label "Reverse Oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#RateLimitMarchesi2020
:RateLimitMarchesi2020 rdf:type owl:NamedIndividual ,
                   :RateLimit ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :RateLimitWohrer2018 ;
          :benefitsFrom :TimeConstraintMarchesi2020 ;

          :hasCanonical :RateLimitCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Regulate how often a task can be executed within a period of time, to limit the number of messages sent to a SC, and thus its computational load."^^rdfs:Literal ;
          rdfs:label "Rate Limit" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#BalanceLimitMarchesi2020
:BalanceLimitMarchesi2020 rdf:type owl:NamedIndividual ,
                   :ContractBalanceLimit ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :BalanceLimitWohrer2018 ;

          :hasCanonical :ContractBalanceLimitCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Limit the maximum amount of funds held within a SC."^^rdfs:Literal ;
          rdfs:label "Balance Limit" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#GuardCheckMarchesi2020
:GuardCheckMarchesi2020 rdf:type owl:NamedIndividual ,
                   :GuardCheck ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :Unknown ;

          :hasCanonical :GuardCheckCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Ensure that all requirements on a SC state and on function inputs are met."^^rdfs:Literal ;
          rdfs:label "Guard Check" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TimeConstraintMarchesi2020
:TimeConstraintMarchesi2020 rdf:type owl:NamedIndividual ,
                   :TimeConstraint ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :TimeConstraintBartoletti2017 ;

          :hasCanonical :TimeConstraintCanonical ;
          :ContextAndProblem "Different blockchain nodes could process transactions at different timestamps, due to network latency or further causes. Consequently, part of the network could consider an action as executed beyond the time constraint, and the corresponding transaction could be rejected by the whole network."^^rdfs:Literal ;
          :Solution "A time constraint specifies when an action is permitted, depending on the time registered in the block holding the transaction. It could be also used in Speed Bump and Rate Limit patterns."^^rdfs:Literal ;
          rdfs:label "Time Constraint" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TerminationMarchesi2020
:TerminationMarchesi2020 rdf:type owl:NamedIndividual ,
                   :Termination ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :TerminationBartoletti2017 ;
          :benefitsFrom :OwnershipMarchesi2020 ;

          :hasCanonical :TerminationCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Used when the life of a SC has come to an end. This can be done by inserting ad-hoc code in the contract, or calling the selfdestruct function. Usually, only the contract owner is authorized to terminate a contract."^^rdfs:Literal ;
          rdfs:label "Termination" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MathMarchesi2020
:MathMarchesi2020 rdf:type owl:NamedIndividual ,
                   :Math ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :MathBartoletti2017 ;

          :hasCanonical :MathCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "A logic which computes some critical operations, protecting from overflows, underflows or other undesired characteristics of finite arithmetic."^^rdfs:Literal ;
          rdfs:label "Math" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PrivacyMarchesi2020
:PrivacyMarchesi2020 rdf:type owl:NamedIndividual ,
                   :OnChainEncryption ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :EncryptingOnChainDataXu2018 ;

          :hasCanonical :OnChainEncryptionCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Encrypt on-chain critical data improving confidentiality and meeting legal requirements, such as the European GDPR."^^rdfs:Literal ;
          rdfs:label "Privacy" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ReusabilityMarchesi2020
:ReusabilityMarchesi2020 rdf:type owl:NamedIndividual ,
                   :FactoryContract ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :FactoryContractXu2018 ;

          :hasCanonical :FactoryContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Use contract libraries and templates as a factory for creating multiple instances."^^rdfs:Literal ;
          rdfs:label "Reusability" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MutexMarchesi2020
:MutexMarchesi2020 rdf:type owl:NamedIndividual ,
                   :Mutex ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :MutexWohrer2018 ;

          :hasCanonical :MutexCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "A mutex is a mechanism to restrict concurrent access to a resource. Utilize it to hinder an external call from re-entering its caller function again."^^rdfs:Literal ;
          rdfs:label "Mutex" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SpeedBumpMarchesi2020
:SpeedBumpMarchesi2020 rdf:type owl:NamedIndividual ,
                   :SpeedBump ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :SpeedBumpWohrer2018 ;
          :benefitsFrom :TimeConstraintMarchesi2020 ;

          :hasCanonical :SpeedBumpCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Slow down contract sensitive tasks, so when malicious actions occur, the damage is limited and more time to counteract is available. For instance, limit the amount of money a user can withdraw per day, or impose a delay before withdrawals."^^rdfs:Literal ;
          rdfs:label "Speed Bump" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PublisherSubscriberMarchesi2020
:PublisherSubscriberMarchesi2020 rdf:type owl:NamedIndividual ,
                   :PublisherSubscriber ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :PublisherSubscriberZhang2017 ;

          :hasCanonical :PublisherSubscriberCanonical ;
          :ContextAndProblem "When a module needs to receive some messages from other software modules (e.g. a smart contract), developers should implement a messag- ing infrastructure that allows each module to be easily notified when a new message is generated."^^rdfs:Literal ;
          :Solution "When a state change must trigger a computation in a different object, implement a messaging infrastructure where the contracts that produce messages (called publishers) can generate messages and the other contracts (called subscribers) receive them. The pattern, also known as Observer, reduces the overhead of constant information filtering."^^rdfs:Literal ;
          rdfs:label "Publisher-Subscriber" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#TokenisationMarchesi2020
:TokenisationMarchesi2020 rdf:type owl:NamedIndividual ,
                   :Tokenisation ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :TokenisationXu2018 ;

          :hasCanonical :TokenisationCanonical ;
          :ContextAndProblem "The Ethereum ecosystem provides standards to handle several types of tokens, such as the ERC20 and ERC721."^^rdfs:Literal ;
          :Solution "Use tokens for transferring digital or physical services. Use standards, such as ERC20 and ERC721."^^rdfs:Literal ;
          rdfs:label "Tokenisation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#XConfirmationMarchesi2020
:XConfirmationMarchesi2020 rdf:type owl:NamedIndividual ,
                   :XConfirmation ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :XConfirmationXu2018 ;

          :hasCanonical :XConfirmationCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "In order to ensure that a transaction is confirmed (i.e. there is a low probability that a fork happens), wait for new blocks to be added to the blockchain. The amount of blocks depends on the adopted blockchain."^^rdfs:Literal ;
          rdfs:label "X-confirmation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractRegistryMarchesi2020
:ContractRegistryMarchesi2020 rdf:type owl:NamedIndividual ,
                   :ContractRegistry ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :ContractRegistryXu2018 ;

          :hasCanonical :ContractRegistryCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Often a smart contract needs to interact with other contracts which can be updated over time. A contract registry maps each smart contract to the address of its latest version. Accordingly, when invoking a smart contract, the correct address should be retrieved from the registry."^^rdfs:Literal ;
          rdfs:label "Contract Registry" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EternalStorageDataContractMarchesi2020
:EternalStorageDataContractMarchesi2020 rdf:type owl:NamedIndividual ,
                   :DataContract ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :DataContractXu2018 ;

          :hasCanonical :DataContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Contract data and logic should be stored into separate contracts. In this way, when the logic need to be updated (by using a new smart contract), there is no need to migrate old data."^^rdfs:Literal ;
          rdfs:label "Eternal storage / Data Contract" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AbstractFactoryMarchesi2020
:AbstractFactoryMarchesi2020 rdf:type owl:NamedIndividual ,
                   :FactoryContract ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;
          :fromPattern :AbstractFactoryZhang2017 ;
          :fromPattern :ContractFactoryLiu2018 ;
          :fromPattern :FactoryContractXu2018 ;

          :hasCanonical :FactoryContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Sometimes, systems need to work with groups of related contracts, for instance with contracts which represent various level user account. In order to keep the system independent from the different contracts, define an abstract contract for creating all the related contracts."^^rdfs:Literal ;
          rdfs:label "Abstract factory" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AbstractFactoryZhang2017
:AbstractFactoryZhang2017 rdf:type owl:NamedIndividual ,
                   :FactoryContract ,
                   :PaperBased ,
                   :Healthcare ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :FactoryContractCanonical ;
          :ContextAndProblem "Smart contracts allow code to be executed on the blockchain by the EVM. The incorruptibility property of blockchain ensures that interfaces (e.g. methods and properties) of already instantiated contracts cannot be modified or upgraded. Each new version of a smart contract has to be created as a new contract object on the blockchain and distributed among all the network nodes to be executed on demand. Therefore, it is important to design a contract class to modularize code and minimize changes to its interface over time."^^rdfs:Literal ;
          :Solution "The Abstract Factory pattern can facilitate this scenario because its factory object (the factory itself is a contract instance) is then responsible for providing creation services of concrete departmental contracts for the entire health organization. Each factory object can create contracts for a group of departments or subdivisions that are related or always interact, and it is easy to instantiate another factory object when new interactions take place."^^rdfs:Literal ;
          rdfs:label "Abstract factory" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#FlyweightZhang2017
:FlyweightZhang2017 rdf:type owl:NamedIndividual ,
                   :Flyweight ,
                   :PaperBased ,
                   :Healthcare ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :FlyweightCanonical ;
          :ContextAndProblem "In order to achieve blockchain’s transparency and immutability properties, all of the data and transaction records are maintained in the blockchain by replicating and distributing to every node in the network. It is important to limit the amount of data stored in the blockchain to avoid high cost of data storage and unattended data when it is no longer needed."^^rdfs:Literal ;
          :Solution "In order to achieve blockchain’s transparency and immutability properties, all of the data and&#10;transaction records are maintained in the blockchain by replicating and distributing to every node in the network. It is important to limit the amount of data stored in the blockchain to avoid high cost of data storage and unattended data when it is no longer needed."^^rdfs:Literal ;
          rdfs:label "Flyweight" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ProxyZhang2017
:ProxyZhang2017 rdf:type owl:NamedIndividual ,
                   :ProxyContract ,
                   :PaperBased ,
                   :Healthcare ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :Unknown ;

          :hasCanonical :ProxyContractCanonical ;
          :ContextAndProblem "A fundamental aspect of a blockchain is that all data stored in the blockchain is public, immutable, and verifiable. For financial transactions that are focused on proving that transfer of an asset occurred, these properties are critical. However, when the goal is to store data in the blockchain, it is important to understand how these properties will impact the use case."^^rdfs:Literal ;
          :Solution "The Proxy pattern is a well-known software pattern that can be applied to blockchain-based data storage to&#10;resolve the tension created by the public and immutable aspects of the blockchain. Using the proxy pattern with a blockchain, a proxy contract is created to provide some lightweight representation or placeholder for the data with more intensive computation (such as acquiring data from off-blockchain storage via an Oracle. The proxy contract can expose some simpler metadata of a patient and later refer to the heavyweight implementation on demand to obtain the real data object. Each read request and modification operation of the data store can be logged in an audit trail that is transparent to the entire blockchain network for verification against data corruption. When the proxified contract (with heavyweight implementation) is updated with new storage option, for instance, interface to the proxy contract can remain the same, encapsulating detailed implementation variations."^^rdfs:Literal ;
          rdfs:label "Proxy" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PublisherSubscriberZhang2017
:PublisherSubscriberZhang2017 rdf:type owl:NamedIndividual ,
                   :PublisherSubscriber ,
                   :PaperBased ,
                   :Healthcare ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :PublisherSubscriberCanonical ;
          :ContextAndProblem "The Ethereum blockchain maintains a public record of contract creations and operation executions along with regular cryptocurrency transactions. The availability of information makes blockchain a more autonomous approach to improve the coordination of patient care across different teams (e.g. physicians, pharmacists, insurance agents, etc) who would normally communicate through various channels with a lot of manual effort, such as through telephoning or faxing. Although, from a continually growing list of records, directly capturing any specific health-related topic of occurred events would require a lot of transaction receipt lookups and topic filtering, which requires non-trivial computation and may result in delayed responses."^^rdfs:Literal ;
          :Solution "The Publisher-Subscriber pattern can assist in broadcasting the information only to care providers that subscribe to events relating to this patient. It solves the issue of constant information filtering by actively monitoring patient activities and sending notifications to the patient’s care team as the activities take place. To avoid computation overhead on the blockchain, the actual processing of patient activities data can be done off-chain by a back-end server. When receiving the events of interest, the subscribers can then pass the heavy computation tasks to the server."^^rdfs:Literal ;
          rdfs:label "Publisher-Subscriber" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ChecksEffectsInteractionWohrer2018
:ChecksEffectsInteractionWohrer2018 rdf:type owl:NamedIndividual ,
                   :CheckEffectInteraction ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :CheckEffectInteractionCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Follow a recommended functional code order, in which calls to external contracts are always the last step, to reduce the attack surface of a contract being manipulated by its own externally called contracts."^^rdfs:Literal ;
          rdfs:label "Checks-Effects-Interaction" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#EmergencyStopWohrer2018
:EmergencyStopWohrer2018 rdf:type owl:NamedIndividual ,
                   :EmergencyStop ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :EmergencyStopCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Incorporate an emergency stop functionality into the contract that can be triggered by an authenticated party to disable sensitive functions."^^rdfs:Literal ;
          rdfs:label "Emergency Stop" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#SpeedBumpWohrer2018
:SpeedBumpWohrer2018 rdf:type owl:NamedIndividual ,
                   :SpeedBump ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :SpeedBumpCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Prolong the completion of sensitive tasks to take steps against fraudulent activities. "^^rdfs:Literal ;
          rdfs:label "Speed Bump" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#RateLimitWohrer2018
:RateLimitWohrer2018 rdf:type owl:NamedIndividual ,
                   :RateLimit ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :RateLimitCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Regulate how often a task can be executed within a period of time."^^rdfs:Literal ;
          rdfs:label "Rate Limit" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MutexWohrer2018
:MutexWohrer2018 rdf:type owl:NamedIndividual ,
                   :Mutex ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :MutexCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Utilize a mutex to hinder an external call from re-entering its caller function again. "^^rdfs:Literal ;
          rdfs:label "Mutex" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#BalanceLimitWohrer2018
:BalanceLimitWohrer2018 rdf:type owl:NamedIndividual ,
                   :ContractBalanceLimit ,
                   :PaperBased ,
                   :General ,
                   :Ethereum ;

          :hasCanonical :ContractBalanceLimitCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Limit the maximum amount of funds at risk held within a contract."^^rdfs:Literal ;
          rdfs:label "Balance Limit" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ChallengeResponseEberhardt2017
:ChallengeResponseEberhardt2017 rdf:type owl:NamedIndividual ,
                   :ChallengeResponse ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :ChallengeResponseCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Instead of checking whether a state is final or not in a smart contract on a blockchain, the same check is performed off-chain on the client side. A client can notify a smart contract when a final state has been reached. Other clients can prove claims wrong by providing a valid state transition. Using this pattern, the computation never has to be performed on-chain"^^rdfs:Literal ;
          rdfs:label "Challenge Response" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#OffChainSignaturesEberhardt2017
:OffChainSignaturesEberhardt2017 rdf:type owl:NamedIndividual ,
                   :OffChainSignatures ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :OffChainSignaturesCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Together, the two participants specify a smart contract including a function, which applies an external state given as argument to the contract state. This function includes a signature check to ensure both participants agree with the state change. Only if valid signatures of both participants are supplied with a requested new state, the new state is applied. This contract is deployed to the blockchain and both participants optionally make a deposit. Then, the participants perform transactions purely off-chain and peer-topeer, without involving the blockchain: One participant computes a new state, wraps it in a transaction, signs it and sends it to his counterpart. The recipient then checks the new state, signs the transaction as well in case he agrees and sends it back to the sender. This transaction, signed by both parties, can now be sent to the smart contract by a participant at any point in time. After validating both signatures, the contract updates its state accordingly."^^rdfs:Literal ;
          rdfs:label "Off-chain Signatures" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContentAddressableStorageEberhardt2017
:ContentAddressableStorageEberhardt2017 rdf:type owl:NamedIndividual ,
                   :OffChainDataStorage ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :OffChainDataStorageCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Store the data off-chain in a content-addressable storage system and store the reference in the smart contract. Clients using the smart contract can retrieve the reference and based on that retrieve the data. Then, they can verify the data’s correctness by recomputing its address from itself and comparing it to the reference stored in the smart contract."^^rdfs:Literal ;
          rdfs:label "Content-Addressable Storage" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#DelegatedComputationEberhardt2017
:DelegatedComputationEberhardt2017 rdf:type owl:NamedIndividual ,
                   :DelegatedComputation ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :DelegatedComputationCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Outsource computation to an untrusted third party and, besides the result, generate a proof of correct execution. Instead of executing the computation itself, verify the proof of correct execution on-chain."^^rdfs:Literal ;
          rdfs:label "Delegated Computation" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#LowContractFootprintEberhardt2017
:LowContractFootprintEberhardt2017 rdf:type owl:NamedIndividual ,
                   :LowContractFootprint ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :LowContractFootprintCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "To optimize fees, contracts should be designed in a way that minimizes the number and size of on-chain transactions. The following two techniques can be used to reduce the footprint. – Do not check conditions on-chain after a state change. Let nodes perform the condition check locally and trigger an on-chain check in case of success. – Optimize for writes, not reads. Reading from a smart contracts is a local off-chain operation and does not require an on-chain transaction. Minimize writes and store information free of redundancy. Compute derived data locally during reads."^^rdfs:Literal ;
          rdfs:label "Low Contract Footprint" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#AbstractFactoryRaj2018
:AbstractFactoryRaj2018 rdf:type owl:NamedIndividual ,
                   :FactoryContract ,
                   :PaperBased ,
                   :Healthcare ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :FactoryContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "This pattern allows DApps like DASH to delegate the responsibility for providing account creation services to an abstract factory object (which is a contract instance itself). A concrete factory object can then inherit methods from the abstract factory and customize them to create accounts for a specific set of related or interacting sub-entities."^^rdfs:Literal ;
          rdfs:label "Abstract factory" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#FlyweightRaj2018
:FlyweightRaj2018 rdf:type owl:NamedIndividual ,
                   :Flyweight ,
                   :PaperBased ,
                   :Healthcare ,
                   :SmartContractEnabledBlockchains ;
          :requires :AbstractFactoryRaj2018 ;

          :hasCanonical :FlyweightCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Combining the FLYWEIGHT pattern with a factory object can help minimize data storage in the Blockchain. In particular, the factory can establish a registry model that stores shared data between a set of entities in a common contract, i.e., the registry, while externalizing varying data to be stored in entity-specific contracts. The registry can also maintain references (i.e., addresses) to entity-specific contracts and return a combined extrinsic and intrinsic (common) data set upon request. "^^rdfs:Literal ;
          rdfs:label "Flyweight" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ProxyRaj2018
:ProxyRaj2018 rdf:type owl:NamedIndividual ,
                   :ProxyContract ,
                   :PaperBased ,
                   :Healthcare ,
                   :SmartContractEnabledBlockchains ;
          :requires :OracleCanonical ;

          :hasCanonical :ProxyContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Combining the PROXY pattern with a secure data retrieving service, such as an oracle, can enable secure and private data exchange services. The oracle network is a third-party service that allows a smart contract to query or retrieve data sources outside the Blockchain address space and ensures that retrieved data is genuine and uncompromised. To reduce computation overhead on-chain, a proxy can be created as a lightweight representation or placeholder for the real data until its retrieval is required."^^rdfs:Literal ;
          rdfs:label "Proxy" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PublisherSubscriberRaj2018
:PublisherSubscriberRaj2018 rdf:type owl:NamedIndividual ,
                   :PublisherSubscriber ,
                   :PaperBased ,
                   :Healthcare ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :PublisherSubscriberCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Incorporating a notification service using the PUBLISHER-SUBSCRIBER pattern can facilitate scalable information filtering. In this design, health activities are only broadcast to providers who subscribe to events relating to their patients. It alleviates the tedious filtering process of determining which care provider should be notified about what patient activities as large volumes of transactions take place."^^rdfs:Literal ;
          rdfs:label "Publisher-Subscriber" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PullBasedInboundOracleMühlberger2020
:PullBasedInboundOracleMühlberger2020 rdf:type owl:NamedIndividual ,
                   :PullBasedInboundOracle ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :PullBasedInboundOracleCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "A pull-based inbound oracle allows blockchain applications to request states from off-chain components. When a blockchain application requests an off-chain state, the pull-based inbound oracle receives this request, gathers the state from off-chain components, and sends the result back to the blockchain (via a transaction)."^^rdfs:Literal ;
          rdfs:label "Pull-based inbound oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PushBasedInboundOracleMühlberger2020
:PushBasedInboundOracleMühlberger2020 rdf:type owl:NamedIndividual ,
                   :PushBasedInboundOracle ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :PushBasedInboundOracleCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "A push-based inbound oracle allows off-chain information to be propagated to the blockchain by monitoring off-chain state changes and forwarding them to the blockchain."^^rdfs:Literal ;
          rdfs:label "Push-based inbound oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PullBasedOutboundOracleMühlberger2020
:PullBasedOutboundOracleMühlberger2020 rdf:type owl:NamedIndividual ,
                   :PullBasedOutboundOracle ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :PullBasedOutboundOracleCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "A pull-based outbound oracle allows blockchain data to be queried and filtered to make it available to the outside world. It can be called from (off-chain) components to pull (all) blockchain data and query relevant information"^^rdfs:Literal ;
          rdfs:label "Pull-based outbound oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#PushBasedOutboundOracleMühlberger2020
:PushBasedOutboundOracleMühlberger2020 rdf:type owl:NamedIndividual ,
                   :PushBasedOutboundOracle ,
                   :PaperBased ,
                   :General ,
                   :AllBlockchains ;

          :hasCanonical :PushBasedOutboundOracleCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "A push-based outbound oracle monitors the blockchain for relevant changes to subsequently trigger or perform activities outside the blockchain."^^rdfs:Literal ;
          rdfs:label "Push-based outbound oracle" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractFactoryLiu2018
:ContractFactoryLiu2018 rdf:type owl:NamedIndividual ,
                   :FactoryContract ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :relatedTo :ContractComposerLiu2018 ;

          :hasCanonical :FactoryContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "As the compiled code of a smart contract deployed on blockchain is not readable, it is tedious to deploy and manage smart contracts that have same properties but aim to diverse clients. With the help of this pattern, developers do not need to deploy the smart contracts one after another, but deploy a contract factory once, through which the required multiple instances can be instantiated."^^rdfs:Literal ;
          rdfs:label "Contract Factory" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractComposerLiu2018
:ContractComposerLiu2018 rdf:type owl:NamedIndividual ,
                   :ContractComposer ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :relatedTo :ContractFactoryLiu2018 ;

          :hasCanonical :ContractComposerCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "In a blockchain-based application, the combination of services or objects is inevitable. Consequently, how to effectively control such a combination becomes a challenge to developers, especially under the condition that each service or object is represented in the form of smart contract. Compared with Contract Factory, Contract Composer focuses on the complex structure of a contract instance, as it can construct a complicated target through multiple small pieces."^^rdfs:Literal ;
          rdfs:label "Contract Composer" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractDecoratorLiu2018
:ContractDecoratorLiu2018 rdf:type owl:NamedIndividual ,
                   :ContractDecorator ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :ContractComposerLiu2018 ;
          :benefitsFrom :ContractDecoratorLiu2018 ;

          :hasCanonical :ContractDecoratorCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Once a smart contract is deployed on blockchain, it is not allowed to modify or update the source code of that contract. Contract Decorator pattern can avoid rewriting the whole contract when there are new requirements, developers just need to encapsulate the old contracts and append the required features into a new version of the contract through this pattern, to achieve updatability and modifiability."^^rdfs:Literal ;
          rdfs:label "Contract Decorator" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractFacadeLiu2018
:ContractFacadeLiu2018 rdf:type owl:NamedIndividual ,
                   :ProxyContract ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :ContractComposerLiu2018 ;
          :benefitsFrom :ContractDecoratorLiu2018 ;
          :benefitsFrom :ContractMediatorLiu2018 ;
          :benefitsFrom :ContractObserverLiu2018 ;

          :hasCanonical :ProxyContractCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "Managing smart contracts may be a burdensome work as there are massive contracts having similar features in a blockchain-based system. Contract Facade pattern can relieve such pressure via providing a simple interface by coping with contract addresses. Such an interface is also in the form of smart contract, for developers to call the functions of similar contracts."^^rdfs:Literal ;
          rdfs:label "Contract Facade" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractMediatorLiu2018
:ContractMediatorLiu2018 rdf:type owl:NamedIndividual ,
                   :ContractMediator ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :ContractMediatorCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "In a business process, smart contracts need to interact with each other to finish a certain activity, which may result in tight coupling of the contracts. Contract Mediator pattern aims to reduce the communication complexity of smart contracts, an instance of this pattern is in the form of smart contract, which collects and encapsulates the interactions and invocations from one contract to the others, to decoupling the smart contracts."^^rdfs:Literal ;
          rdfs:label "Contract Mediator" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#ContractObserverLiu2018
:ContractObserverLiu2018 rdf:type owl:NamedIndividual ,
                   :ContractObserver ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;
          :benefitsFrom :ContractDecoratorLiu2018 ;

          :hasCanonical :ContractObserverCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "When a smart contract is modified due to the changing requirements in industry, all the related contracts need to be informed and updated automatically. Contract Observer pattern can deal with such problem to achieve interoperability and updatability among the contracts via an observer instance. An instance of Contract Observer needs to define the objects and information involved, once there are any changes, it should notify all the objects to update information."^^rdfs:Literal ;
          rdfs:label "Contract Observer" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#HashSecretLiu2018
:HashSecretLiu2018 rdf:type owl:NamedIndividual ,
                   :HashSecret ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :HashSecretCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "This pattern can help a user to achieve authorisation of a particular activity to unknown authorities, by generating a digital secret key known as the hash secret. When the authority is decided, it will then receive the hash secret and thus have the ability to finish further task."^^rdfs:Literal ;
          rdfs:label "Hash Secret" .

###  http://www.semanticweb.org/nicolas/ontologies/2021/8/patterns#MultiSignatureLiu2018
:MultiSignatureLiu2018 rdf:type owl:NamedIndividual ,
                   :MultipleAuthorization ,
                   :PaperBased ,
                   :General ,
                   :SmartContractEnabledBlockchains ;

          :hasCanonical :MultipleAuthorizationCanonical ;
          :ContextAndProblem ""^^rdfs:Literal ;
          :Solution "As there are multiple authorities in a blockchain network, this pattern can provide a flexible way to achieve better cooperation. A transaction is valid only when there are enough signatures from the authorities. In addition, this pattern can also be considered as an individual safeguard mechanism as the current blockchain technology does not provide a way to recover the lost private key."^^rdfs:Literal ;
          rdfs:label "Multi-signature" .

